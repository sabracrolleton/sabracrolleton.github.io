<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-04-12 Wed 13:16 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Review of CL JSON Libraries UPDATED 12 Apr 2023</title>
<meta name="author" content="Sabra Crolleton" />
<meta name="description" content="This is a tutorial chapter for the sc-webapp-tutorial" />
<meta name="keywords" content="common-lisp, postmodern, postgresql, webapp, easy-routes, djula, hunchentoot" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Review of CL JSON Libraries UPDATED 12 Apr 2023</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#changelog">Changelog</a>
<ul>
<li><a href="#orgf37f0fc">12 Apr 2023</a></li>
<li><a href="#org8f7a722">1 Feb 2022</a></li>
<li><a href="#org58d5d83">19 Jan 2022</a></li>
<li><a href="#orga26faf9">18 Jan 2022</a></li>
<li><a href="#org7fcfb18">15 Jan 2022</a></li>
</ul>
</li>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#libraries">Common Lisp Encoding and Decoding Libraries</a></li>
<li><a href="#helper-libraries-top">Helper Libraries</a></li>
</ul>
</li>
<li><a href="#quick-summary">Quick Summary</a></li>
<li><a href="#decoding">Decoding/Reading/Parsing JSON Data to Lisp</a>
<ul>
<li><a href="#decoding-streams-or-strings">Decoding Streams or Strings</a></li>
<li><a href="#mapping-json-cl">Mapping Data Types and Structures from JSON to CL</a>
<ul>
<li><a href="#decode-unicode">Unicode</a></li>
<li><a href="#number-mapping">Number Mapping</a></li>
<li><a href="#true-false-null-mapping">True, False, Null, Empty Array Mapping</a></li>
<li><a href="#decoding-arrays">Decoding JSON Arrays</a></li>
<li><a href="#decoding-objects">Decoding JSON Objects</a></li>
<li><a href="#decoding-nested-objects">Decoding Nested JSON Objects</a></li>
</ul>
</li>
<li><a href="#decode-to-clos">Converting JSON data to a CLOS object</a>
<ul>
<li><a href="#decode-to-clos-boost-json">Boost-json</a></li>
<li><a href="#decode-to-clos-cl-json">Cl-json</a></li>
<li><a href="#decode-to-clos-trivial-json-codec">Trivial-json-codec</a></li>
</ul>
</li>
<li><a href="#extracting-subset">Extracting a Subset of a JSON object</a></li>
<li><a href="#determining-object-keywords">Determining Object Keywords</a></li>
<li><a href="#decoding-nil">Handling NIL</a></li>
</ul>
</li>
<li><a href="#encoding">Encoding Lisp Data to JSON</a>
<ul>
<li><a href="#encoding-streams-or-strings">Encoding to Streams or Strings</a></li>
<li><a href="#encoding-symbols">Encoding Symbols, Chars, T, nil and :null</a></li>
<li><a href="#encoding-numbers">Encoding Numbers</a></li>
<li><a href="#encoding-pathnames">Encoding Pathnames</a></li>
<li><a href="#encoding-timestamps">Encoding Local-Time Timestamps</a></li>
<li><a href="#encoding-data-structures">Encoding Data Structures to JSON (Summary)</a></li>
<li><a href="#encoding-lists">Encoding Lists (Summary)</a></li>
<li><a href="#encoding-plain-lists">Encoding Plain Lists</a></li>
<li><a href="#encoding-alists">Encoding Alists</a></li>
<li><a href="#encoding-plists">Encoding Plists</a></li>
<li><a href="#encoding-arrays">Encoding Arrays</a>
<ul>
<li><a href="#encoding-vectors">Encoding Single Dimensional Vector</a></li>
<li><a href="#encoding-bit-vectors">Encoding Simple Bit Vector</a></li>
<li><a href="#encoding-nested-arrays">Encoding Nested Arrays</a></li>
<li><a href="#encoding-2d-array">Encoding 2 Dimensional Array Version</a></li>
</ul>
</li>
<li><a href="#encoding-hash-tables">Encoding hash-tables</a>
<ul>
<li><a href="#using-string-as-a-key">Using string as key</a></li>
<li><a href="#using-symbol-as-a-key">Using symbol as key</a></li>
</ul>
</li>
<li><a href="#encoding-objects">Encoding CLOS objects</a></li>
<li><a href="#encoding-structs">Encoding Structs</a></li>
<li><a href="#incremental-encoding">Incremental Encoding</a></li>
</ul>
</li>
<li><a href="#symmetry">Symmetry</a>
<ul>
<li><a href="#symmetry-json-cl-json">JSON -&gt; CL -&gt; JSON</a>
<ul>
<li><a href="#symmetry-json-cl-json1">First test (Easy)</a></li>
<li><a href="#symmetry-json-cl-json2">Second Test (Array Inside a JSON Object)</a></li>
<li><a href="#symmetry-json-cl-json3">Third test (Trickier Data Types)</a></li>
</ul>
</li>
<li><a href="#symmetry-cl-json-cl">CL -&gt; JSON -&gt; CL</a></li>
</ul>
</li>
<li><a href="#security">Security</a></li>
<li><a href="#standard-conformity">Standard Conformity and Dealing with Malformed Data</a>
<ul>
<li><a href="#conformity-testing">Conformity Testing</a>
<ul>
<li><a href="#must-accept">Must Accept</a></li>
<li><a href="#can-accept">Can Accept or Reject</a></li>
</ul>
</li>
<li><a href="#malformed-data">Malformed Data</a></li>
</ul>
</li>
<li><a href="#benchmarking">Benchmarking</a>
<ul>
<li><a href="#read-times">Read Times</a>
<ul>
<li><a href="#benchmarking-read-stream">Read Times From Stream (SBCL)</a></li>
</ul>
</li>
<li><a href="#write-times">Write Times</a></li>
</ul>
</li>
<li><a href="#json-libraries-specific-comments">JSON Libraries Specific Comments</a>
<ul>
<li><a href="#boost-json">boost-json</a>
<ul>
<li><a href="#boost-json-mapping">Default Mapping</a></li>
<li><a href="#boost-json-decoding">Decoding</a></li>
<li><a href="#boost-json-encoding">Encoding</a></li>
<li><a href="#boost-json-symmetry">Symmetry</a></li>
<li><a href="#boost-json-security">Security</a></li>
<li><a href="#boost-json-conformity">Conformity with JSON Standard</a></li>
<li><a href="#boost-json-benchmarkiing">Benchmarking</a></li>
<li><a href="#boost-json-exported-symbols">boost-json exported symbols</a></li>
</ul>
</li>
<li><a href="#cl-json">cl-json</a>
<ul>
<li><a href="#cl-json-mapping">Default Mapping</a></li>
<li><a href="#cl-json-decoding">Decoding</a></li>
<li><a href="#cl-json-encoding">Encoding</a></li>
<li><a href="#cl-json-symmetry">Symmetry</a></li>
<li><a href="#cl-json-security">Security</a></li>
<li><a href="#cl-json-conformity">Conformity with JSON Standard</a></li>
<li><a href="#cl-json-benchmarking">Benchmarking</a></li>
<li><a href="#cl-json-other-information">Miscellaneous Information</a></li>
<li><a href="#cl-json-exported-symbols">cl-json exported symbols</a></li>
</ul>
</li>
<li><a href="#com.gigamonkeys.json">com.gigamonkeys.json</a>
<ul>
<li><a href="#gigamonkeys-mapping">Default Mapping</a></li>
<li><a href="#gigamonkeys-decoding">Decoding</a></li>
<li><a href="#gigamonkeys-encoding">Encoding</a></li>
<li><a href="#gigamonkeys-symmetry">Symmetry</a></li>
<li><a href="#gigamonkeys-security">Security</a></li>
<li><a href="#gigamonkeys-conformity">Conformity with JSON Standard</a></li>
<li><a href="#gigamonkeys-benchmarking">Benchmarking</a></li>
<li><a href="#gigamonkeys-exported-symbols">com.gigamonkeys.json exported symbols</a></li>
</ul>
</li>
<li><a href="#com.inuoe.jzon">com.inuoe.jzon</a>
<ul>
<li><a href="#jzon-mapping">Default Mapping</a></li>
<li><a href="#jzon-decoding">Decoding</a></li>
<li><a href="#jzon-encoding">Encoding</a></li>
<li><a href="#jzon-symmetry">Symmetry</a></li>
<li><a href="#jzon-security">Security</a></li>
<li><a href="#jzon-conformity">Conformity with JSON Standard</a></li>
<li><a href="#jzon-benchmarking">Benchmarking</a></li>
<li><a href="#jzon-exported-symbols">com.inuoe.jzon exported symbols</a></li>
</ul>
</li>
<li><a href="#jonathan">jonathan</a>
<ul>
<li><a href="#jonathan-mapping">Default Mappping</a></li>
<li><a href="#jonathan-decoding">Decoding</a></li>
<li><a href="#jonathan-encoding">Encoding</a></li>
<li><a href="#jonathan-symmetry">Symmetry</a></li>
<li><a href="#jonathan-security">Security</a></li>
<li><a href="#jonathan-conformity">Conformity with JSON Standard</a></li>
<li><a href="#jonathan-benchmarking">Benchmarking</a></li>
<li><a href="#jonathan-exported-symbols">jonathan exported symbols</a></li>
</ul>
</li>
<li><a href="#json-lib">json-lib</a>
<ul>
<li><a href="#json-lib-mapping">Mapping</a></li>
<li><a href="#json-lib-decoding">Decoding</a></li>
<li><a href="#json-lib-encoding">Encoding</a></li>
<li><a href="#json-lib-symmetry">Symmetry</a></li>
<li><a href="#json-lib-security">Security</a></li>
<li><a href="#json-lib-conformity">Conformity with JSON Standard</a></li>
<li><a href="#json-lib-benchmarking">Benchmarking</a></li>
<li><a href="#json-lib-miscellaneous-comments">Miscellaneous Comments</a></li>
<li><a href="#json-lib-exported-symbols">Json-lib exported symbols</a></li>
</ul>
</li>
<li><a href="#json-streams">json-streams</a>
<ul>
<li><a href="#json-streams-mapping">Default Mapping</a></li>
<li><a href="#json-streams-decoding">Decoding</a></li>
<li><a href="#json-streams-encoding">Encoding</a></li>
<li><a href="#json-streams-symmetry">Symmetry</a></li>
<li><a href="#json-streams-security">Security</a></li>
<li><a href="#json-streams-conformity">Conformity with JSON Standard</a></li>
<li><a href="#json-streams-benchmarking">Benchmarking</a></li>
<li><a href="#json-streams-exported-symbols">json-streams exported symbols</a></li>
</ul>
</li>
<li><a href="#jsown">jsown</a>
<ul>
<li><a href="#jsown-mapping">Default Mappping</a></li>
<li><a href="#jsown-decoding">Decoding</a></li>
<li><a href="#jsown-encoding">Encoding</a></li>
<li><a href="#jsown-symmetry">Symmetry</a></li>
<li><a href="#jsown-security">Security</a></li>
<li><a href="#jsown-conformity">Conformity with JSON Standard</a></li>
<li><a href="#jsown-benchmarking">Benchmarking</a></li>
<li><a href="#jsown-miscellaneous">Miscellaneous</a></li>
<li><a href="#jsown-exported-symbols">jsown exported symbols</a></li>
</ul>
</li>
<li><a href="#shasht">shasht</a>
<ul>
<li><a href="#shasht-mapping">Default Mappping</a></li>
<li><a href="#shasht-decoding">Decoding</a></li>
<li><a href="#shasht-encoding">Encoding</a></li>
<li><a href="#shasht-symmetry">Symmetry</a></li>
<li><a href="#shasht-security">Security</a></li>
<li><a href="#shasht-conformity">Conformity with JSON Standard</a></li>
<li><a href="#shasht-benchmarking">Benchmarking</a></li>
<li><a href="#shasht-exported-symbols">Shasht Exported Symbols</a></li>
</ul>
</li>
<li><a href="#st-json">st-json</a>
<ul>
<li><a href="#st-json-mapping">Default Mappping</a></li>
<li><a href="#st-json-decoding">Decoding</a></li>
<li><a href="#st-json-encoding">Encoding</a></li>
<li><a href="#st-json-symmetry">Symmetry</a></li>
<li><a href="#st-json-security">Security</a></li>
<li><a href="#st-json-conformity">Conformity with JSON Standard</a></li>
<li><a href="#st-json-benchmarking">Benchmarking</a></li>
<li><a href="#st-json-other-information">Other Information</a></li>
<li><a href="#st-json-exported-symbols">st-json exported symbols</a></li>
</ul>
</li>
<li><a href="#trivial-json-codec">trivial-json-codec</a>
<ul>
<li><a href="#trivial-json-codec-mapping">Default Mappping</a></li>
<li><a href="#trivial-json-codec-decoding">Decoding</a></li>
<li><a href="#trivial-json-codec-encoding">Encoding</a></li>
<li><a href="#trivial-json-codec-symmetry">Symmetry</a></li>
<li><a href="#trivial-json-codec-security">Security</a></li>
<li><a href="#trivial-json-codec-conformity">Conformity with JSON Standard</a></li>
<li><a href="#trivial-json-codec-benchmarking">Benchmarking</a></li>
<li><a href="#trivial-json-codec-exported-symbols">trivial-json-codec exported symbols</a></li>
</ul>
</li>
<li><a href="#yason">yason</a>
<ul>
<li><a href="#yason-mapping">Mapping DataTypes and Structures</a></li>
<li><a href="#yason-decoding">Decoding</a></li>
<li><a href="#yason-encloding">Encoding</a></li>
<li><a href="#yason-symmetry">Symmetry</a></li>
<li><a href="#yason-security">Security</a></li>
<li><a href="#yason-conformity">Conformity with JSON Standard</a></li>
<li><a href="#yason-benchmarking">Benchmarking</a></li>
<li><a href="#yason-exported-symbols">yason exported symbols</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#helper-libraries">Helper Libraries</a>
<ul>
<li><a href="#cl-json-helper">cl-json-helper</a>
<ul>
<li><a href="#cl-json-helper-exported-symbols">cl-json-helper exported symbols</a></li>
<li><a href="#json-bool">Json-bool</a></li>
<li><a href="#json-empty">json-empty</a></li>
<li><a href="#json-key-value">Json-key-value</a></li>
</ul>
</li>
<li><a href="#define-json-expander">define-json-expander</a>
<ul>
<li><a href="#define-json-expander-exported-symbols">define-json-expander exported symbols</a></li>
<li><a href="#define-json-expander-explanation">Explanation</a></li>
</ul>
</li>
<li><a href="#herodotus">herodotus</a>
<ul>
<li><a href="#herodotus-exported-symbols">herodotus exported symbols</a></li>
<li><a href="#herodotus-setup">Setup</a></li>
<li><a href="#herodotus-decoding">Decoding</a></li>
<li><a href="#herodotus-encoding">Encoding</a></li>
<li><a href="#herodotus-additional-info">Additional Info</a></li>
</ul>
</li>
<li><a href="#json-mop">json-mop</a>
<ul>
<li><a href="#json-mop-exported-symbols">json-mop exported symbols</a></li>
</ul>
</li>
<li><a href="#cl-json-pointer">cl-json-pointer</a>
<ul>
<li><a href="#cl-json-pointer-exported-symbols">cl-json-pointer exported symbols</a></li>
</ul>
</li>
<li><a href="#cl-json-schema">cl-json-schema</a></li>
</ul>
</li>
<li><a href="#appendix">Appendix</a>
<ul>
<li><a href="#json-refresher">JSON Refresher</a></li>
<li><a href="#decoding-benchmark-detail">Decoding Trivial-Benchmark Summary</a></li>
<li><a href="#decoding-benchmark-detail-by-library">Decoding Trivial-Benchmark Detail By Library</a>
<ul>
<li><a href="#decoding-benchmark-detail-by-library12">1.2 MB JSON File</a></li>
<li><a href="#decoding-benchmark-detail-by-library98">9.8 MB File</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-changelog" class="outline-2">
<h2 id="changelog">Changelog</h2>
<div class="outline-text-2" id="text-changelog">
</div>
<div id="outline-container-orgf37f0fc" class="outline-3">
<h3 id="orgf37f0fc">12 Apr 2023</h3>
<div class="outline-text-3" id="text-orgf37f0fc">
<p>
com.inuoe.jzon (aka jzon) is now in quicklisp. Both jzon and shasht have had active development. The versions used are the github repositories as of 11 Apr 2023. Benchmarking has been updated.
</p>

<p>
A summary of changes in jzon:
</p>
<ol class="org-ol">
<li>incremental parsing and writing are now implemented</li>
<li>The issue with empty object on pathname has been 'fixed' - we now coerce to namestring</li>
<li>Float&lt;-&gt;JSON encoding/decoding have both been substantially improved in terms of speed, accuracy, and portability across lisp implementations (bundled float encoder/decoder)</li>
<li>Parsing is now safe on the stack regardless of object nesting setting</li>
<li>Parsing performance improvements across the board for a variety of file sizes/varieties</li>
<li>Coerce strings to simple-base-string when possible for 1/4 memory usage on SBCL (ASCII vs UTF32 encoding) with minimal overhead.</li>
<li>New :allow-trailing-comma, and block comment support for :allow-comments in order to allow for parsing jwcc data (<a href="https://nigeltao.github.io/blog/2021/json-with-commas-comments.html">https://nigeltao.github.io/blog/2021/json-with-commas-comments.html</a>)</li>
<li>Much more detailed errors across the board when a parse error occurs</li>
</ol>

<p>
Changes in shasht include adding read-level and read-length limits to address potential security concerns. (These are set to nil by default).
</p>
</div>
</div>

<div id="outline-container-org8f7a722" class="outline-3">
<h3 id="org8f7a722">1 Feb 2022</h3>
<div class="outline-text-3" id="text-org8f7a722">
<p>
Picks up updates in shasht and now includes warnings on libraries with safety 0 (<code>jsown</code>, <code>jonathan</code>, <code>st-json</code>).
</p>
</div>
</div>

<div id="outline-container-org58d5d83" class="outline-3">
<h3 id="org58d5d83">19 Jan 2022</h3>
<div class="outline-text-3" id="text-org58d5d83">
<p>
Updated shasht for fixes in character, 2D arrays, and nil handling. Fixed some typos, including a missing earmuff.
</p>
</div>
</div>

<div id="outline-container-orga26faf9" class="outline-3">
<h3 id="orga26faf9">18 Jan 2022</h3>
<div class="outline-text-3" id="text-orga26faf9">
<p>
Corrected JSON conformity tests on <code>boost-json</code>, <code>cl-json</code>, <code>json-lib</code>, <code>shasht</code>, <code>st-json</code>, <code>trivial-json-codec</code> and <code>yason</code>. If <code>*read-default-float-format*</code> is set to <code>'single-float</code>, those libraries would refuse to accept:  <code>"[123e65]"</code>, <code>"[123e45]"</code> and <code>"[123.456e78]"</code>. If <code>*read-default-float-format*</code> is set to <code>'double-float</code>, then those JSON strings would be correctly accepted. Net result: with that caveat, <a href="#boost-json">boost-json</a>, <a href="#cl-json">cl-json</a>, <a href="#com.gigamonkeys.json">com.gigamonkeys.json</a>, <a href="#com.inuoe.jzon">com.inuoe.jzon</a>, <a href="#json-lib">json-lib</a>, <a href="#shasht">shasht</a>, <a href="#st-json">st-json</a> and <a href="#yason">yason</a> all score 95/95 on the JSON strings that must be accepted. See <a href="#must-accept">Standard Conformity - Must Accept</a>.
</p>
</div>
</div>

<div id="outline-container-org7fcfb18" class="outline-3">
<h3 id="org7fcfb18">15 Jan 2022</h3>
<div class="outline-text-3" id="text-org7fcfb18">
<p>
Complete rewrite of 1st edition.
</p>
</div>
</div>
</div>

<div id="outline-container-introduction" class="outline-2">
<h2 id="introduction">Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
The Common Lisp (CL) landscape with respect to JSON libraries has changed since the first edition of this review eight years ago. While I sometimes complain about someone writing new libraries when there are already so many, there have been major improvements and a couple of the new generation of CL JSON libraries are actually quite exciting. It still remains the case, however, that your choice of data structures for your application may drive your choice of JSON library, and vice versa. Like everything else in life, there are trade-offs to be made and I hope this paper helps you think about what may or may not be relevant for your situation.
</p>

<p>
Corrections to this report are welcomed. Please submit issues to <a href="https://github.com/sabracrolleton/sabracrolleton.github.io">https://github.com/sabracrolleton/sabracrolleton.github.io</a> or pull requests against the json-view.org file.
</p>
</div>

<div id="outline-container-libraries" class="outline-3">
<h3 id="libraries">Common Lisp Encoding and Decoding Libraries</h3>
<div class="outline-text-3" id="text-libraries">
<p>
CL currently has at least twelve libraries that address importing and exporting JSON data. The libraries considered in this report are listed in the table below. (For purposes of this comparison, I will refer to "encoding" as converting from CL to JSON and "decoding" or "parsing" as converting from JSON to CL.)
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 1:</span> Common Lisp JSON Libraries Compared</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Quicklisp?</th>
<th scope="col" class="org-left">Updated</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#boost-json">boost-json</a></td>
<td class="org-left">Jeffrey Massung</td>
<td class="org-left">Apache</td>
<td class="org-left"><a href="https://github.com/cl-boost/json">homepage</a></td>
<td class="org-left">No</td>
<td class="org-left">16 Dec 2021</td>
</tr>

<tr>
<td class="org-left"><a href="#cl-json">cl-json</a></td>
<td class="org-left">Henrik Hjelte, Boris Smilga, Robert Goldman</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/hankhero/cl-json">homepage</a></td>
<td class="org-left">Yes</td>
<td class="org-left">7 Nov 2014</td>
</tr>

<tr>
<td class="org-left"><a href="#com.gigamonkeys.json">com.gigamonkeys.json</a></td>
<td class="org-left">Peter Seibel</td>
<td class="org-left">BSD-3</td>
<td class="org-left"><a href="https://github.com/gigamonkey/monkeylib-json">homepage </a></td>
<td class="org-left">Yes</td>
<td class="org-left">15 Apr 2017</td>
</tr>

<tr>
<td class="org-left"><a href="#com.inuoe.jzon">com.inuoe.jzon</a></td>
<td class="org-left">Wilfredo Velázquez-Rodríguez</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/Zulu-Inuoe/jzon">homepage</a></td>
<td class="org-left">Yes</td>
<td class="org-left">20 Mar 2023</td>
</tr>

<tr>
<td class="org-left"><a href="#jonathan">jonathan</a></td>
<td class="org-left">Rudolph Miller</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/Rudolph-Miller/jonathan">homepage</a></td>
<td class="org-left">Yes</td>
<td class="org-left">1 Sep 2020</td>
</tr>

<tr>
<td class="org-left"><a href="#json-lib">json-lib</a></td>
<td class="org-left">Alex Nygren</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/KinaKnowledge/json-lib">homepage</a></td>
<td class="org-left">Yes</td>
<td class="org-left">22 Oct 2022</td>
</tr>

<tr>
<td class="org-left"><a href="#json-streams">json-streams</a></td>
<td class="org-left">Thomas Bakketun, Stian Sletner</td>
<td class="org-left">GPL3</td>
<td class="org-left"><a href="http://github.com/rotatef/json-streams">homepage</a></td>
<td class="org-left">Yes</td>
<td class="org-left">12 Oct 2017</td>
</tr>

<tr>
<td class="org-left"><a href="#jsown">jsown</a></td>
<td class="org-left">Aad Versteden</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/madnificent/jsown">homepage</a></td>
<td class="org-left">Yes</td>
<td class="org-left">4 Feb 2020</td>
</tr>

<tr>
<td class="org-left"><a href="#shasht">shasht</a></td>
<td class="org-left">Tarn W. Burton</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/yitzchak/shasht">homepage</a></td>
<td class="org-left">Yes</td>
<td class="org-left">23 Feb 2023</td>
</tr>

<tr>
<td class="org-left"><a href="#st-json">st-json</a></td>
<td class="org-left">Marijn Haverbeke</td>
<td class="org-left">zlib</td>
<td class="org-left"><a href="https://github.com/marijnh/ST-JSON">homepage</a></td>
<td class="org-left">Yes</td>
<td class="org-left">28 Jun 2021</td>
</tr>

<tr>
<td class="org-left"><a href="#trivial-json-codec">trivial-json-codec</a> (2)</td>
<td class="org-left">Eric Diethelm</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://gitlab.com/ediethelm/trivial-json-codec">homepage</a></td>
<td class="org-left">Yes</td>
<td class="org-left">26 Apr 2022</td>
</tr>

<tr>
<td class="org-left"><a href="#yason">yason</a>  (1)</td>
<td class="org-left">Hans Huebner</td>
<td class="org-left">BSD</td>
<td class="org-left"><a href="https://github.com/phmarek/yason">homepage</a></td>
<td class="org-left">Yes</td>
<td class="org-left">2 Feb 2023</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) IMPORTANT: Notice the GitHub location has moved. Hans Huebner's old GitHub location will automatically redirect to Phil Marek's.</li>
<li>(2) trivial-json-codec seems more targeted at decoding from JSON to CL than serializing to JSON. Its main purpose is in serializing JSON data to CLOS hierarchical objects.</li>
</ul>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 2:</span> Dependencies</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Dependencies</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#boost-json">boost-json</a></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#cl-json">cl-json</a></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#com.gigamonkeys.json">com.gigamonkeys.json</a></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#com.inuoe.jzon">com.inuoe.jzon</a></td>
<td class="org-left">closer-mop, flexi-streams, trivial-gray-streams, uiop and float-features (except when using ECL)</td>
</tr>

<tr>
<td class="org-left"><a href="#jonathan">jonathan</a></td>
<td class="org-left">cl-syntax, cl-syntax-annot, fast-io, trivial-types, babel, proc-parse, cl-ppcre, cl-annot</td>
</tr>

<tr>
<td class="org-left"><a href="#json-lib">json-lib</a></td>
<td class="org-left">alexandria, str, parse-float, cl-fad, babel</td>
</tr>

<tr>
<td class="org-left"><a href="#json-streams">json-streams</a></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#jsown">jsown</a></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#shasht">shasht</a></td>
<td class="org-left">trivial-do, closer-mop</td>
</tr>

<tr>
<td class="org-left"><a href="#st-json">st-json</a></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#trivial-json-codec">trivial-json-codec</a></td>
<td class="org-left">trivial-utilities, log4cl, closer-mop, iterate, parse-number</td>
</tr>

<tr>
<td class="org-left"><a href="#yason">yason</a></td>
<td class="org-left">alexandria, trivial-gray-streams</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-helper-libraries-top" class="outline-3">
<h3 id="helper-libraries-top">Helper Libraries</h3>
<div class="outline-text-3" id="text-helper-libraries-top">
<p>
We should also talk a bit about some helper libraries.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Works With</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#define-json-expander">define-json-expander</a></td>
<td class="org-left">Johan Sjölén</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/ejbs/define-json-expander">homepage</a></td>
<td class="org-left">cl-json</td>
<td class="org-left">CLOS&lt;-&gt;JSON</td>
</tr>

<tr>
<td class="org-left"><a href="#herodotus">herodotus</a></td>
<td class="org-left">Henry Steere</td>
<td class="org-left">BSD (1)</td>
<td class="org-left"><a href="https://github.com/HenryS1/herodotus">homepage</a></td>
<td class="org-left">yason</td>
<td class="org-left">CLOS&lt;-&gt;JSON</td>
</tr>

<tr>
<td class="org-left"><a href="#json-mop">json-mop</a></td>
<td class="org-left">Grim Schjetne</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/gschjetne/json-mop">homepage</a></td>
<td class="org-left">yason</td>
<td class="org-left">CLOS&lt;-&gt;JSON</td>
</tr>

<tr>
<td class="org-left"><a href="#cl-json-helper">cl-json-helper</a></td>
<td class="org-left">Bob Felts</td>
<td class="org-left">BSD</td>
<td class="org-left"><a href="https://github.com/stablecross/cl-json-helper">homepage</a></td>
<td class="org-left">cl-json</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#cl-json-schema">cl-json-schema</a></td>
<td class="org-left">Mark Skilbeck</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/notmgsk/cl-json-schema">homepage</a></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#cl-json-pointer">cl-json-pointer</a></td>
<td class="org-left">Yokata Yuki</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/y2q-actionman/cl-json-pointer">homepage</a></td>
<td class="org-left">cl-json, st-json, yason, <code>jsown</code>, jonathan, json-streams, com.gigamonkeys.json, (1)</td>
<td class="org-left"><a href="https://40ants.com/lisp-project-of-the-day/2020/08/0158-cl-json-pointer.html">40ants comments</a></td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) asd file says BSD, but license included is MIT.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-quick-summary" class="outline-2">
<h2 id="quick-summary">Quick Summary</h2>
<div class="outline-text-2" id="text-quick-summary">
<p>
As can be expected, the libraries do much of the same if you have basic needs. However, differences exist and should be considered in choosing which library is right for any particular project. Many applications are asymmetric in how they will use these libraries, so consider the strengths and weakness given the needs of your case. Library links are to the libraries' individual sections below.
</p>

<ul class="org-ul">
<li><b>Overall:</b> I quite like the newcomers <a href="#shasht">shasht</a> and <a href="#com.inuoe.jzon">com.inuoe.jzon</a>. <a href="#cl-json">cl-json</a> and <a href="#yason">yason</a> are still the work horses if you need fine control, but speed is not their forte.</li>
<li><b>Decoding or Parsing Speed:</b> Speed is not everything, but seems to be important to a lot of readers. If you are parsing compliant data and are just looking for speed, look at <a href="#jsown">jsown</a>, <a href="#com.inuoe.jzon">com.inuoe.jzon</a> or <a href="#shasht">shasht</a>. <a href="#jonathan">Jonathan</a> is faster on tiny strings but starts to slow down with nested objects and eventually, depending on the size of the JSON object, becomes orders of magnitude slower than the other libraries. The effect was seen faster under SBCL but as data file size increased, it was also obvious under CCL and ECL as well. See <a href="#read-times">read-times</a></li>
<li><b>Encoding Speed:</b> If you mostly need to encode lisp data to JSON and are just looking for speed, I would look at <a href="#com.inuoe.jzon">com.inuoe.jzon</a>, <a href="#shasht">shasht</a> or depending on your data, <a href="#jonathan">jonathan</a> or <a href="#st-json">st-json</a>. See <a href="#write-times">write-times</a></li>
<li><b>Safety 0</b> Three libraries (<code>jsown</code>, jonathan and st-json) have optimize set for safety 0 to increase speed. This has bitten some users hard in the past, so you have been warned. If you restrict  safety to 2 or 3 on SBCL, <a href="#jonathan">Jonathan</a> is unable to parse floats. See <a href="https://github.com/rudolph-miller/jonathan/issues/66">https://github.com/rudolph-miller/jonathan/issues/66</a></li>
<li><b>Unicode Handling:</b> Most of the libraries can handle unicode. However, if you have unicode surrogate pairs, you need to choose from <a href="#com.inuoe.jzon">com.inuoe.jzon</a>, <a href="#jonathan">jonathan</a>, <a href="#json-streams">json-streams</a>, <a href="#jsown">jsown</a>, <a href="#shasht">shasht</a>, <a href="#st-json">st-json</a> or <a href="#yason">yason</a>. See <a href="#decode-unicode">Decoding Unicode</a>.</li>
<li><b>Extracting Subsets:</b> If you want to extract a subset of JSON data without paying attention to everything else, <a href="#jsown-filters">jsown</a> is the choice. <a href="#jonathan">Jonathan</a> allows you to get a key:value pair, but I could only use it one level deep. Obviously every library can import all the JSON data into some CL datastructure and then use standard CL functionality to get whatever subset you want.</li>
<li><b>Handling all proper JSON forms:</b> If you remember to set *read-default-float-format* to 'double-float, there is no clear winner. <a href="#boost-json">boost-json</a>, <a href="#cl-json">cl-json</a>, <a href="#com.gigamonkeys.json">com.gigamonkeys.json</a>, <a href="#com.inuoe.jzon">com.inuoe.jzon</a>, <a href="#json-lib">json-lib</a>, <a href="#shasht">shasht</a>, <a href="#st-json">st-json</a> and <a href="#yason">yason</a> all score 95/95 on the JSON standard conformity tests that must be met. If *read-default-float-format* is set to to 'single-float, only <a href="#com.inuoe.jzon">com.inuoe.jzon</a> and <a href="#com.gigamonkeys.json">com.gigamonkeys.json</a> have perfect scores. See <a href="#must-accept">Must Accept</a>.</li>
<li><b>Handling potentially invalid data:</b> See <a href="#standard-conformity">Standard Conformity and Dealing with Malformed Data</a>. I think <a href="#com.inuoe.jzon">com.inuoe.jzon</a> is the winner..</li>
<li><b>Proper Distinction Between NULL/Nil/False:</b> <a href="#com.inuoe.jzon">Com.inuoe.jzon</a>, <a href="#shasht">shasht</a> and <a href="#st-json">st-json</a> get it right out of the box. <a href="#jonathan">jonathan</a> and <a href="#yason">yason</a> provide the ability to get there with setting a simple variable.</li>
<li><b>CLOS Abilities - Decoding:</b> <a href="#trivial-json-codec">Trivial-json-codec</a> can decode objects to standard pre-defined classes. <a href="#boost-json-decoding-to-clos">Boost-json</a> can decode JSON objects to a boost-json:json-object which is a standard object. <a href="#cl-json">Cl-json</a> has the ability to decode JSON objects into a "fluid-class" CLOS object. (Note, this is thread unsafe if you have not already prepped classes for every expected JSON object. If you define your own classes with a lispclass member, this can be avoided so long as every class is defined that way.) Personally I prefer being able to define my own classes. Trivial-json-codec then just dumps the JSON data into your classes. If you use <a href="#yason">yason</a>, I would also use the helper library <a href="#json-mop">json-mop</a>. (<a href="#com.inuoe.jzon">com.inuoe.jzon</a> decodes JSON to hash-tables, so does not have decoding to CLOS abilities out of the box.) See <a href="#decode-to-clos">Decoding to CLOS</a></li>
<li><b>CLOS Abilities - Encoding:</b> On the encoding side, <a href="#cl-json">cl-json</a>, <a href="#com.inuoe.jzon">com.inuoe.jzon</a>, <a href="#shasht">shasht</a> and <a href="#trivial-json-codec">trivial-json-codec</a> are able to encode CLOS objects to JSON out of the box. The rest of the libraries require that you write your own methods for your clos classes - which is not necessarily that difficult, but not something you get out of the box. If you like <a href="#yason">yason</a>, there are two helper libraries: <a href="#json-mop">json-mop</a> or <a href="#herodotus">herodotus</a>. I have a preference for <a href="#json-mop">json-mop</a> with the caveat that, at the moment, you cannot redefine classes. There is also a <a href="#cl-json">cl-json</a> helper library, <a href="#define-json-expander">define-json-expander</a>, which defines classses which can be used by cl-json to help move data back and forth. See <a href="#encoding-objects">Encoding Objects</a></li>
<li><b>Encoding different lisp types:</b> <a href="#shasht">shasht</a> and <a href="#com.inuoe.jzon">com.inuoe.jzon</a> were the best at encoding different lisp data types. For example, they were the only library able to handle structs without the user having to define a new method. There is a trade-off between handling multiple lisp types and symmetry. If you do not have a 1:1 matching but rather have a many:1 matching, there may be complications doing a round trip between JSON and CL and getting exactly the same data type or structure you started with. See <a href="#encoding">Encoding</a> or <a href="#encoding-data-structures">Encoding Data Structures</a>.</li>
<li><b>Incremental Encoding:</b> <a href="#cl-json-incremental">cl-json</a>, <a href="#jzon-incremental">com.inuoe.jzon</a>  <a href="#jonathan-incremental">jonathan</a>, <a href="#json-streams-incremental">json-streams</a>, <a href="#jsown-incremental">jsown</a>, <a href="#shasht-incremental">shasht</a>, <a href="#st-json-incremental">st-json</a> and <a href="#yason-incremental">yason</a> all have the capability to do incremental encoding. You can see small examples in their individual sections at the links in the previous sentence. I found <a href="#shasht-incremental">shasht</a> a little easier. See <a href="#incremental-encoding">Incremental Encoding Discussion</a> for more detail.</li>
<li><b>Security issues:</b> Security issues are always a potential problem if you are getting data from uncontrolled sources. Malware disguised in the data will likely either be properly formed JSON strings that try to overload the system by overloading libraries using keywords as hash symbols or improperly formed JSON strings that exhaust the stack. See the <a href="#security">Security discussion</a> for more information. In cases facing data from uncontrolled sources, I would look first at <a href="#com.inuoe.jzon">com.inuoe.jzon</a> , then maybe at <a href="#shasht">shasht</a>. I would suggest that all libraries put some type of limit on parsing depth of JSON objects or arrays. At this point only <a href="#com.inuoe.jzon">com.inuoe.jzon</a>, <a href="#json-lib">json-lib</a>, <a href="#json-streams">json-streams</a> and <a href="#trivial-json-codec">trivial-json-codec</a> have such limits, all of which are configurable. See <a href="#security">security</a>.</li>
<li><b>Symmetry or "Round Tripping":</b> Symmetric treatment is important to some users. In this area, libraries tend to have issues with NULL/Nil/False as well as whether keys should be symbols or strings. Symmetry is easier going from Jason to CL and back. It is definitely harder if you go from CL to JSON and back to CL and you do not limit your CL data types. (CL has more data types so you do not have a 1:1 match). Your choices are to limit your CL data types or using libraries which allow you to precisely specify the CL datatype you want at that point. Overall, I think the symmetry winner is <a href="#shasht">shasht</a>, but your fact pattern may drive a different answer. See <a href="#symmetry">symmetry discussion</a>.</li>
</ul>

<p>
At the end of the day, your particular data and requirements will determine which library is best for any particular application. Webapps may have tiny bits of JSON going back and forth while other uses will be asymmetric - gigabytes of JSON getting imported and little or occasional amounts getting exported or vice versa. You may have different needs depending on whether the JSON encoded data is strictly controlled or it is coming in from unknown sources. In one test, yason:encode choked on a list which included a keyword :NULL in an unexpected location. Cl-json just encoded it as the string "null" and st-json encoded it as 'null' (not a string). In testing for your use, if you get JSON data from uncontrolled sources, deliberately feed badly formed data and see how the library reacts. Some will throw recoverable conditions (depending on the error) while others may actually lock up a thread.
</p>
</div>
</div>

<div id="outline-container-decoding" class="outline-2">
<h2 id="decoding">Decoding/Reading/Parsing JSON Data to Lisp</h2>
<div class="outline-text-2" id="text-decoding">
<p>
The following table shows the basic decoding function for a library and then specialist functions. Each will have more detail in the section specific to that library.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 3:</span> Basic Decoding Functions</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Base Function</th>
<th scope="col" class="org-left">Specialist Functions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#boost-json-decoding">boost-json</a></td>
<td class="org-left">json-decode</td>
<td class="org-left">json-read</td>
</tr>

<tr>
<td class="org-left"><a href="#cl-json-decoding">cl-json</a></td>
<td class="org-left">decode-json</td>
<td class="org-left">decode-json-from-source, decode-json-from-string, decode-json-strict</td>
</tr>

<tr>
<td class="org-left"><a href="#gigamonkeys-decoding">com.gigamonkeys.json</a></td>
<td class="org-left">parse-json</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#jzon-decoding">com.inuoe.jzon</a></td>
<td class="org-left">parse</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#jonathan-decoding">jonathan</a></td>
<td class="org-left">parse</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#json-lib-decoding">json-lib</a></td>
<td class="org-left">parse</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#json-streams-decoding">json-streams</a></td>
<td class="org-left">json-parse</td>
<td class="org-left">json-read</td>
</tr>

<tr>
<td class="org-left"><a href="#jsown-decoding">jsown</a></td>
<td class="org-left">parse</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#shasht-decoding">shasht</a></td>
<td class="org-left">read-json</td>
<td class="org-left">read-json*</td>
</tr>

<tr>
<td class="org-left"><a href="#st-json-decoding">st-json</a></td>
<td class="org-left">read-json</td>
<td class="org-left">read-json-as-type read-json-from-string</td>
</tr>

<tr>
<td class="org-left"><a href="#trivial-json-codec-decoding">trivial-json-codec</a></td>
<td class="org-left">deserialize-raw</td>
<td class="org-left">deserialize-json</td>
</tr>

<tr>
<td class="org-left"><a href="#yason-decoding">yason</a> (1)</td>
<td class="org-left">parse</td>
<td class="org-left">parse-json-arrays-as-vectors, parse-json-booleans-as-symbols, parse-json-null-as-keyword, parse-object-as, parse-object-as-alist, parse-object-key-fn, symbol-key-encoder</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) yason:parse takes keyword parameters :object-key-fn, :object-as :json-arrays-as-vectors :json-booleans-as-symbols :json-nulls-as-keyword</li>
</ul>
</div>

<div id="outline-container-decoding-streams-or-strings" class="outline-3">
<h3 id="decoding-streams-or-strings">Decoding Streams or Strings</h3>
<div class="outline-text-3" id="text-decoding-streams-or-strings">
<p>
Does the library take both strings and streams as input?
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 4:</span> Strings and Streams As Input</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Strings</th>
<th scope="col" class="org-left">Streams</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">YES</td>
<td class="org-left">YES (1)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">YES</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">YES</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">UTF-8 Encoded Only</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left"><code>jsown</code></td>
<td class="org-left">YES</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">YES</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) Use boost-json:json-read instead of boost-json:json-decode</li>
</ul>
</div>
</div>

<div id="outline-container-mapping-json-cl" class="outline-3">
<h3 id="mapping-json-cl">Mapping Data Types and Structures from JSON to CL</h3>
<div class="outline-text-3" id="text-mapping-json-cl">
<p>
JSON has a limited number of data types. You will get different lisp data-types from the decoding depending on the library.
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 5:</span> Default Mapping JSON to CL</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left"><a href="#true-false-null-mapping">True/False/ Null</a></th>
<th scope="col" class="org-right">Number</th>
<th scope="col" class="org-left">Array</th>
<th scope="col" class="org-left">JSON Object (3)(6)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original JSON</td>
<td class="org-left">"true"/  "false"/  "null"</td>
<td class="org-right">"12.3"</td>
<td class="org-left">"[1,2]"</td>
<td class="org-left">"{\"a\": 2}"</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#boost-json-mapping">boost-json</a></td>
<td class="org-left">T / NIL/ NIL</td>
<td class="org-right">12.3</td>
<td class="org-left">(1 2)</td>
<td class="org-left"><a href="#boost-json-decoding-to-clos">#&lt;JSON-OBJECT {"a":2}&gt;</a></td>
</tr>

<tr>
<td class="org-left"><a href="#cl-json-mapping">cl-json</a>    (1)</td>
<td class="org-left">T /  NIL / NIL</td>
<td class="org-right">12.3</td>
<td class="org-left">(1 2)</td>
<td class="org-left">((A . 2))</td>
</tr>

<tr>
<td class="org-left"><a href="#gigamonkeys-mapping">com.gigamonkeys.json</a></td>
<td class="org-left">TRUE / FALSE /  NULL</td>
<td class="org-right">12.3d0</td>
<td class="org-left">#(1 2)</td>
<td class="org-left">(a 2)</td>
</tr>

<tr>
<td class="org-left"><a href="#jzon-mapping">com.inuoe.jzon</a> (3)</td>
<td class="org-left">T /  NIL/  NULL</td>
<td class="org-right">12.3d0</td>
<td class="org-left">#(1 2)</td>
<td class="org-left">#&lt;HASH-TABLE} :TEST EQUAL :COUNT 1&gt;</td>
</tr>

<tr>
<td class="org-left"><a href="#jonathan-mapping">jonathan</a></td>
<td class="org-left">T / NIL /  NIL</td>
<td class="org-right">12.3</td>
<td class="org-left">(1 2)</td>
<td class="org-left">(a 2)</td>
</tr>

<tr>
<td class="org-left"><a href="#json-lib-mapping">json-lib</a> (3)</td>
<td class="org-left">T /  NIL/  NIL</td>
<td class="org-right">12.3</td>
<td class="org-left">#(1 2)</td>
<td class="org-left">#&lt;HASH-TABLE :TEST EQUAL :COUNT 1&gt;</td>
</tr>

<tr>
<td class="org-left"><a href="#json-streams-mapping">json-streams</a></td>
<td class="org-left">T / NIL/ NULL</td>
<td class="org-right">12.3d0</td>
<td class="org-left">(ARRAY 1 2)</td>
<td class="org-left">(OBJECT (a . 2))</td>
</tr>

<tr>
<td class="org-left"><a href="#jsown-mapping">jsown</a> (5)</td>
<td class="org-left">T /  NIL / NIL</td>
<td class="org-right">123/10  (5)</td>
<td class="org-left">(1 2)</td>
<td class="org-left">(OBJ (a . 2))</td>
</tr>

<tr>
<td class="org-left"><a href="#shasht-mapping">shasht</a> (3)(6)</td>
<td class="org-left">T / NIL /  NULL</td>
<td class="org-right">12.3</td>
<td class="org-left">#(1 2)</td>
<td class="org-left">#&lt;HASH-TABLE :TEST EQUAL :COUNT 1&gt; (6)</td>
</tr>

<tr>
<td class="org-left"><a href="#st-json-mapping">st-json</a></td>
<td class="org-left">TRUE /  FALSE /  NULL</td>
<td class="org-right">12.3</td>
<td class="org-left">(1 2)</td>
<td class="org-left">#S(JSO :ALIST ((a . 2)))</td>
</tr>

<tr>
<td class="org-left"><a href="#trivial-json-codec-mapping">trivial-json-codec</a> (2)</td>
<td class="org-left">"true"/  "false"/  "null"</td>
<td class="org-right">12.3</td>
<td class="org-left">#(1 2)</td>
<td class="org-left">((:A 2))</td>
</tr>

<tr>
<td class="org-left"><a href="#yason-mapping">yason</a> (3)(4)(6)</td>
<td class="org-left">T / NIL/  NIL/:NULL</td>
<td class="org-right">12.3</td>
<td class="org-left">(1 2)/#(1 2)</td>
<td class="org-left">#&lt;HASH-TABLE :TEST EQUAL :COUNT 1&gt; (6)</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) This is cl-json's default mode. Using cl-json:with-decoder-simple-clos-semantics or cl-json:simple-clos-semantics will switch cl-json into a mode where JSON arrays are decoded to cl vectors rather than lists, and JSON objects are decoded to CLOS objects rather than alists.</li>
<li>(2) There is a difference between how it handles the string false and string null and how it handles them when they are in an object and not separated as sub-strings. See <a href="#true-false-null-mapping">true-false-null-mapping</a>.</li>
<li>(3) All four libraries that decode a JSON object to a CL hash use strings as hash keys by default</li>
<li>(4) yason:parse has a keyword parameter <code>:json-nulls-as-keyword</code> and a keyword parameter <code>:json-arrays-as-vectors</code>.</li>
<li><p>
(5) Parsing JSON value strings which are not embedded in a JSON object or array will trigger errors. For example <code>(jsown:parse "12.3")</code> or <code>(jsown:parse "alpha")</code> will trigger a <code>sb-kernal:bounding-indices-bad</code> error in SBCL. Floats in an array or object will be converted to a ratio:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:parse <span class="org-string">"[123e-1, 15.2]"</span>)
(123/10 76/5)
</pre>
</div></li>
<li>(6) While shasht and yason default to parsing JSON objects as hash-tables, they can optionally be parsed as alists or plists.</li>
</ul>

<p>
The following tables set out some additional detail on mapping from JSON data structures to lisp data structures using the normal functions listed above with some comments on the results.
</p>
</div>

<div id="outline-container-decode-unicode" class="outline-4">
<h4 id="decode-unicode">Unicode</h4>
<div class="outline-text-4" id="text-decode-unicode">
<p>
Consider a JSON string with unicode characters. The JSON data string is the first row in each table.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 6:</span> Decoding Basic Unicode</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">["\u004C","明彦","\u2604"]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-decode</td>
<td class="org-left">(L 明彦 ☄)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">json-decode-from-string</td>
<td class="org-left">(L 明彦 ☄)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">parse-json</td>
<td class="org-left">#(L 明彦 ☄)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">parse</td>
<td class="org-left">#(L 明彦 ☄)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">parse</td>
<td class="org-left">#( 明彦 )</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-parse</td>
<td class="org-left">(ARRAY L 明彦 ☄)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">read-json</td>
<td class="org-left">#(L 明彦 ☄)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">read-json-from-string</td>
<td class="org-left">(L 明彦 ☄)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">deserialize-raw</td>
<td class="org-left">#(\u004C 明彦 \u2604)</td>
<td class="org-left">(2)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">parse</td>
<td class="org-left">(L 明彦 ☄)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) Did not handle the unicode char codes</li>
<li>(2) Repeated the unicode char codes</li>
</ul>

<p>
In the following table, we show the results of attempting to decode unicode with surrogate pairs
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 7:</span> Unicode Decoding 2 (surrogate pairs)</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">"\uD83D\uDE02\uD83D\uDE02"</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-decode</td>
<td class="org-left">����</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">json-decode-from-string</td>
<td class="org-left">����</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">parse-json</td>
<td class="org-left">����</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">parse</td>
<td class="org-left">😂😂</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">parse</td>
<td class="org-left">😂😂</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">parse</td>
<td class="org-left">���</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-parse</td>
<td class="org-left">😂😂</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">parse</td>
<td class="org-left">😂😂</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">read-json</td>
<td class="org-left">😂😂</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">read-json-from-string</td>
<td class="org-left">😂😂</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">deserialize-raw</td>
<td class="org-left">\uD83D\uDE02\uD83D\uDE02</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">parse</td>
<td class="org-left">😂😂</td>
</tr>
</tbody>
</table>

<p>
Conclusion: If you may have surrogate pairs in your JSON data, you might want to stick to <a href="#com.inuoe.jzon">com.inuoe.jzon</a>, <a href="#jonathan">jonathan</a>, <a href="#json-streams">json-streams</a>, <a href="#jsown">jsown</a>, <a href="#shasht">shasht</a>, <a href="#st-json">st-json</a> or <a href="#yason">yason</a>.
</p>
</div>
</div>

<div id="outline-container-number-mapping" class="outline-4">
<h4 id="number-mapping">Number Mapping</h4>
<div class="outline-text-4" id="text-number-mapping">
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 8:</span> Number Mapping</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original JSON String</td>
<td class="org-left">"{\"integer\": 32,\"float\": 34.89}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">#&lt;JSON-OBJECT {"integer":32,"float":34.89}&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">((INTEGER . 32) (FLOAT . 34.89))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">(integer 32 float 34.89d0)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">((float . 34.89d0) (integer . 32))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">((float . 34.89) (integer . 32))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">((float . 34.89) (integer . 32))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">(OBJECT (integer . 32) (float . 34.89d0))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">(OBJ (integer . 32) (float . 3489/100))</td>
<td class="org-left">Ratio</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">((float . 34.89) (integer . 32))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">#S(JSO :ALIST ((integer . 32) (float . 34.89)))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">((:INTEGER 32) (:FLOAT 34.89))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">((float . 34.89) (integer . 32))</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-true-false-null-mapping" class="outline-4">
<h4 id="true-false-null-mapping">True, False, Null, Empty Array Mapping</h4>
<div class="outline-text-4" id="text-true-false-null-mapping">
<p>
Contrary to some people's belief systems that boolean logic encompasses everything, there is a meaningful difference between "false" and "unknown". Null ≠ nil. For that matter, I subscribe to the belief that (not true) is not the same as the empty set. JSON's null and empty arrays can track the differences between false, null and empty array. When translating back and forth between CL and JSON, it is important to be able to keep those distinction. Thank you, <a href="#com.gigamonkeys.json">com.gigamonkeys.json</a>, <a href="#com.inuoe.jzon">com.inuoe.jzon</a>, <a href="#shasht">shasht</a> and <a href="#st-json">st-json</a> for getting them correct right out of the box and thank you to <a href="#jonathan">jonathan</a> and <a href="#yason">yason</a> for giving me the ability to get there with setting a variable.
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 9:</span> True, False, Null Mapping with JSON Objects</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original JSON String</td>
<td class="org-left">"{\"1\": true,\"2\": false, \"3\": null}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">#&lt;JSON-OBJECT {"1":true,"2":null,"3":null}&gt;</td>
<td class="org-left">failed false</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">((1 . T) (2) (3))</td>
<td class="org-left">failed null</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">(1 TRUE 2 FALSE 3 NULL)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">((3 . NULL) (2 . nil) (1 . T))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">((:3 . nil) (:2 . nil) (:1 . T))</td>
<td class="org-left">failed null  (but see next row)</td>
</tr>

<tr>
<td class="org-left">jonathan (4)</td>
<td class="org-left">((:3 . :null) (:2 . nil) (:1 . T))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">((3 . nil) (2 . nil) (1 . T))</td>
<td class="org-left">failed null</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">(OBJECT (1 . T) (2) (3 . NULL))</td>
<td class="org-left">failed false (2)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">(OBJ (1 . T) (2) (3))</td>
<td class="org-left">failed null</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">((3 . NULL) (2 . nil) (1 . T))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">#S(JSO :ALIST ((1 . TRUE) (2 . FALSE) (3 . NULL)))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">((:&vert;1&vert; T) (:&vert;2&vert; NIL) (:&vert;3&vert; NIL))</td>
<td class="org-left">failed false and null</td>
</tr>

<tr>
<td class="org-left">yason (3)</td>
<td class="org-left">(("3") ("2") ("1" . T))</td>
<td class="org-left">failed null (but see next row</td>
</tr>

<tr>
<td class="org-left">yason (4)</td>
<td class="org-left">(("3" . :NULL) ("2") ("1" . T))</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) The cl-boost author notes in his <a href="https://github.com/cl-boost/json/blob/main/README.md">README</a> that "it is not possible to distinguish between false, null, or []. And, I have personally never found this to be problematic." Obviously your experience may vary. My experience is that they show meaningful differences between "false" and "unknown". I think his position is stronger if the question is solely between nil and [].</li>
<li>(2) When reading a JSON object with nil and null, json-streams provides no value for the cons cell which represents the JSON value false. I would have expected the cons cell to have a value of nil.</li>
<li>(3) When called with :object-as :plist, the nil is explicit: ("1" T "2" NIL "3" nil)</li>
<li>(4) Jonathan called with jonathan:*null-value* set to :null. Yason called with yason:*parse-json-null-as-keyword* set to t or passing the keyword parameter :json-nulls-as-keyword t to yason:parse</li>
</ul>

<p>
The following table shows how the various libraries try to decode a JSON object with an empty array as the value. Com.gigamonkeys, com.inuoe.jzon, json-lib and shasht are the clearest representation of the original JSON.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 10:</span> Decoding JSON Object with an Empty Array</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original JSON string</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">{"a": []}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-decode</td>
<td class="org-left">#&lt;JSON-OBJECT {"a":null}&gt;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">json-decode-from-string</td>
<td class="org-left">((A))</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">parse-json</td>
<td class="org-left">(a #())</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">parse</td>
<td class="org-left">((a . #()))</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">parse</td>
<td class="org-left">(a NIL)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">parse</td>
<td class="org-left">((a . #()))</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-parse</td>
<td class="org-left">(OBJECT (a ARRAY))</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">parse</td>
<td class="org-left">(OBJ (a))</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">read-json</td>
<td class="org-left">((a . #()))</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">read-json-from-string</td>
<td class="org-left">#S(JSO :ALIST ((a)))</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">deserialize-raw</td>
<td class="org-left">((A NIL))</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">parse</td>
<td class="org-left">((a))</td>
</tr>
</tbody>
</table>

<p>
Now looking at all four types within a JSON array:
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 11:</span> True, False, Null and Empty Array Mapping with JSON Arrays</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">[true,false,null, []]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">(T NIL NIL NIL)</td>
<td class="org-left">failed null</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">(T NIL NIL NIL)</td>
<td class="org-left">failed null</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">#(TRUE FALSE NULL #())</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">#(T NIL NULL #())</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">(T NIL NIL NIL)</td>
<td class="org-left">failed null but see next row</td>
</tr>

<tr>
<td class="org-left">jonathan (1)</td>
<td class="org-left">(T NIL NIL :NULL)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">#(T NIL NIL #())</td>
<td class="org-left">failed null</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">(ARRAY T NIL NULL (ARRAY))</td>
<td class="org-left">correct this time compared to decoding object</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">(T NIL NIL NIL)</td>
<td class="org-left">failed null</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">#(T NIL NULL #())</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">(TRUE FALSE NULL NIL)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">#(T NIL NIL NIL)</td>
<td class="org-left">failed null</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">(T NIL NIL NIL)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason (1)</td>
<td class="org-left">(T NIL NIL :null)</td>
<td class="org-left">failed null but see next row</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) Jonathan called with jonathan:*null-value* set to :null. Yason called with yason:*parse-json-null-as-keyword* set to t or passing the keyword parameter :json-nulls-as-keyword t to yason:parse</li>
</ul>
</div>
</div>

<div id="outline-container-decoding-arrays" class="outline-4">
<h4 id="decoding-arrays">Decoding JSON Arrays</h4>
<div class="outline-text-4" id="text-decoding-arrays">
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 12:</span> Array Mapping</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">["Skoda", "Peugeot", "SEAT"]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">(Skoda Peugeot SEAT)</td>
<td class="org-left">list</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">(Skoda Peugeot SEAT)</td>
<td class="org-left">list</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">#(Skoda Peugeot SEAT)</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">#(Skoda Peugeot SEAT)</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">(Skoda Peugeot SEAT)</td>
<td class="org-left">list</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">#(Skoda Peugeot SEAT)</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">(:ARRAY Skoda Peugeot SEAT)</td>
<td class="org-left">cons</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">(Skoda Peugeot SEAT)</td>
<td class="org-left">list</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">#(Skoda Peugeot SEAT)</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">(Skoda Peugeot SEAT)</td>
<td class="org-left">list</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">#("Skoda" "Peugeot" "SEAT")</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">(Skoda Peugeot SEAT)</td>
<td class="org-left">list</td>
</tr>

<tr>
<td class="org-left">yason (1)</td>
<td class="org-left">#("Skoda" "Peugeot" "SEAT")</td>
<td class="org-left">vector</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) Yason called with additional keyword parameter :json-arrays-as-vectors t</li>
</ul>
</div>
</div>
<div id="outline-container-decoding-objects" class="outline-4">
<h4 id="decoding-objects">Decoding JSON Objects</h4>
<div class="outline-text-4" id="text-decoding-objects">
<p>
For the JSON object examples, we will be using the following simple JSON string:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*address-1*</span> <span class="org-string">"{</span>
<span class="org-string">  \"name\": \"George Washington\",</span>
<span class="org-string">  \"birthday\": \"February 22, 1732\",</span>
<span class="org-string">  \"address\": \"Mount Vernon, Virginia, United States\"</span>
<span class="org-string">}"</span>
</pre>
</div>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 13:</span> Decoding Basic JSON Objects</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">{"name":"George Washington","birthday":"February 22, 1732","address":"Mount Vernon, Virginia, United States"}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">#&lt;JSON-OBJECT {"name":"George Washington","birthday":"February 22, 1732","address":"Mount Vernon, Virginia, United States"}&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">((NAME . George Washington) (BIRTHDAY . February 22, 1732) (ADDRESS . Mount Vernon, Virginia, United States))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">(name George Washington birthday February 22, 1732  address Mount Vernon, Virginia, United States)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">#&lt;HASH-TABLE :TEST EQUAL :COUNT 3 {101F71B1E3}&gt;</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">((address . Mount Vernon, Virginia, United States) (birthday . February 22, 1732) (name . George Washington))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">#&lt;HASH-TABLE :TEST EQUAL :COUNT 3 {101F71CC63}&gt;</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">(OBJECT (name . George Washington) (birthday . February 22, 1732) (address . Mount Vernon, Virginia, United States))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">(OBJ (name . George Washington) (birthday . February 22, 1732) (address . Mount Vernon, Virginia, United States))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">#&lt;HASH-TABLE :TEST EQUAL :COUNT 3 {101F71FA83}&gt;</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">#S(JSO :ALIST ((name . George Washington) (birthday . February 22, 1732) (address . Mount Vernon, Virginia, United States)))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">((NAME George Washington) (BIRTHDAY February 22, 1732) (ADDRESS Mount Vernon, Virginia, United States))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">#&lt;HASH-TABLE :TEST EQUAL :COUNT 3 {101F722863}&gt;</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">yason-alist</td>
<td class="org-left">((address . Mount Vernon, Virginia, United States) (birthday . February 22, 1732) (name . George Washington))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason-plist</td>
<td class="org-left">(name George Washington birthday February 22, 1732 address Mount Vernon, Virginia, United States)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) All four libraries that decode a JSON object to a CL hash use strings as hash keys by default. All four will allow you to optionally use keywords instead. Shasht and yason allow you to decode a JSON object to alists or plists instead of hashes.</li>
</ul>
</div>
</div>

<div id="outline-container-decoding-nested-objects" class="outline-4">
<h4 id="decoding-nested-objects">Decoding Nested JSON Objects</h4>
<div class="outline-text-4" id="text-decoding-nested-objects">
<p>
For nested object examples, we will be using the following simple JSON object:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*nested-address-1*</span> <span class="org-string">"{</span>
<span class="org-string">  \"first_name\": \"George\",</span>
<span class="org-string">  \"last_name\": \"Washington\",</span>
<span class="org-string">  \"birthday\": \"1732-02-22\",</span>
<span class="org-string">  \"address\": {</span>
<span class="org-string">    \"street_address\": \"3200 Mount Vernon Memorial Highway\",</span>
<span class="org-string">    \"city\": \"Mount Vernon\",</span>
<span class="org-string">    \"state\": \"Virginia\",</span>
<span class="org-string">    \"country\": \"United States\"</span>
<span class="org-string">  }</span>
<span class="org-string">}"</span>)
</pre>
</div>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 14:</span> Decoding Nested JSON Objects</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">{  "first_name": "George",  "last_name": "Washington",  "birthday": "1732-02-22",  "address": {    "street_address": "3200 MountVernon Memorial Highway",    "city": "Mount Vernon",    "state": "Virginia",    "country": "United States"  }}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">#&lt;JSON-OBJECT {"first_name":"George","last_name":"Washington", "birthday":"1732-02-22","address":#}&gt;</td>
<td class="org-left">Nested address info is enclosed in a nested json-object. See <a href="#boost-json-decoding-nested-objects-to-clos">boost-json decoding nested objects to clos</a></td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">((FIRST&#x2013;NAME . George) (LAST&#x2013;NAME . Washington) (BIRTHDAY . 1732-02-22) (ADDRESS (STREET&#x2013;ADDRESS . 3200 Mount Vernon Memorial Highway) (CITY . Mount Vernon) (STATE . Virginia) (COUNTRY . United States)))</td>
<td class="org-left">All info provided</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">(first_name George last_name Washington birthday 1732-02-22 address (street_address 3200 Mount Vernon Memorial Highway city Mount Vernon state Virginia country United States))</td>
<td class="org-left">All info but nested plists provided</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">((address . #&lt;HASH-TABLE :TEST EQUAL :COUNT 4 {10092D4753}&gt;) (birthday . 1732-02-22) (last_name . Washington)                (first_name . George))</td>
<td class="org-left">all info available but shows need to recursively apply differnt functions to pull out the nested hashes created by com.inuoe.jzon</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">((address (country . United States) (state . Virginia) (city . Mount Vernon) (street_address . 3200 Mount Vernon Memorial Highway))   (birthday . 1732-02-22) (last_name . Washington) (first_name . George))</td>
<td class="org-left">All info provided</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">((address . #&lt;HASH-TABLE :TEST EQUAL :COUNT 4 {10092DA153}&gt;) (birthday . 1732-02-22) (last_name . Washington) (first_name . George))</td>
<td class="org-left">all info available but shows need to recursively apply differnt functions to pull out the nested hashes created by json-lib</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">(OBJECT (first_name . George) (last_name . Washington) (birthday . 1732-02-22) (address OBJECT (street_address . 3200 Mount Vernon Memorial Highway) (city . Mount Vernon) (state . Virginia) (country . United States)))</td>
<td class="org-left">All info provided</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">(OBJ (first_name . George) (last_name . Washington) (birthday . 1732-02-22) (address OBJ (street_address . 3200 Mount Vernon Memorial Highway) (city . Mount Vernon) (state . Virginia) (country . United States)))</td>
<td class="org-left">All info provided in nested jsown objects</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">((address . #&lt;HASH-TABLE :TEST EQUAL :COUNT 4 {10092E2203}&gt;) (birthday . 1732-02-22) (last_name . Washington) (first_name . George))</td>
<td class="org-left">all info available but shows need to recursively apply differnt functions to pull out the nested hashes created by shasht</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">#S(JSO :ALIST ((first_name . George) (last_name . Washington) (birthday . 1732-02-22) (address . #S(JSO :ALIST ((street_address . 3200 Mount Vernon Memorial Highway) (city . Mount Vernon) (state . Virginia) (country . United States))))))</td>
<td class="org-left">All info provided in nested st-json objects</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">((:FIRST_NAME "George") (:LAST_NAME "Washington") (:BIRTHDAY "1732-02-22") (:ADDRESS  ((:STREET_ADDRESS "3200 Mount VernonMemorial Highway")   (:CITY "Mount Vernon") (:STATE "Virginia") (:COUNTRY "United States"))))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">((address . #&lt;HASH-TABLE :TEST EQUAL :COUNT 4 {10092E6003}&gt;) (birthday . 1732-02-22) (last_name . Washington) (first_name . George))</td>
<td class="org-left">all info available but shows need to recursively apply differnt functions to pull out the nested hashes created by yason.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-decode-to-clos" class="outline-3">
<h3 id="decode-to-clos">Converting JSON data to a CLOS object</h3>
<div class="outline-text-3" id="text-decode-to-clos">
<p>
Which libraries have some built-in ability to convert a JSON object to a CLOS object?
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 15:</span> Decoding JSON Object to a CLOS Object</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-decode</td>
<td class="org-left">YES     (1)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">decode-json-from-string</td>
<td class="org-left">YES     (2)</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO      (3)</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">deserialize-json</td>
<td class="org-left">YES     (4)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">NO    (5)</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) boost-json creates a boost-json:json-object which is a standard-object. Accessing the slots is done with boost-json:json-getf and boost-json:json-setf functions. See <a href="#boost-json-decoding-to-clos">Boost-json decoding to CLOS</a></li>
<li>(2) cl-json can create a cl-json:fluid-class which is a standard-object. Accessing the slots is done with the name of the slot. See <a href="#cl-json-data-to-clos">cl-json-data-to-clos</a>.</li>
<li>(3) The st-json "object" jso is a struct, not a CLOS object.</li>
<li>(4) You need to define your classes first</li>
<li>(5) Possible with helper libraries <a href="#json-mop">json-mop</a>  or <a href="#herodotus">herodotus</a>.</li>
</ul>

<p>
For example, consider two address JSON objects:
</p>
<div class="org-src-container">
<pre class="src src-javascript">  *address-1*
  <span class="org-string">"{</span>
<span class="org-string">    \"name\": \"George Washington\",</span>
<span class="org-string">    \"birthday\": \"February 22, 1732\",</span>
<span class="org-string">    \"address\": \"Mount Vernon, Virginia, United States\"</span>
<span class="org-string">  }"</span>

*nested-address-1*
<span class="org-string">"{</span>
<span class="org-string">  \"first_name\": \"George\",</span>
<span class="org-string">  \"last_name\": \"Washington\",</span>
<span class="org-string">  \"birthday\": \"1732-02-22\",</span>
<span class="org-string">  \"address\": {</span>
<span class="org-string">    \"street_address\": \"3200 Mount Vernon Memorial Highway\",</span>
<span class="org-string">    \"city\": \"Mount Vernon\",</span>
<span class="org-string">    \"state\": \"Virginia\",</span>
<span class="org-string">    \"country\": \"United States\"</span>
<span class="org-string">  }</span>
<span class="org-string">}"</span>
</pre>
</div>

<p>
Obviously you can always write your own function to initialize a specific class from an alist, but we do have two libraries (boost-json and cl-json) that try to do something like this for you automagically. Let's take a look.
</p>
</div>
<div id="outline-container-decode-to-clos-boost-json" class="outline-4">
<h4 id="decode-to-clos-boost-json">Boost-json</h4>
<div class="outline-text-4" id="text-decode-to-clos-boost-json">
<p>
Boost-json will decode the JSON nested object to a CLOS object class called boost-json:json-object.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(boost-json:json-decode *nested-address-1*)
#&lt;BOOST-JSON:JSON-OBJECT
{<span class="org-string">"first_name"</span>:<span class="org-string">"George"</span>,<span class="org-string">"last_name"</span>:<span class="org-string">"Washington"</span>,<span class="org-string">"birthday"</span>:<span class="org-string">"1732-02-22"</span>,<span class="org-string">"address"</span>:#}&gt;
</pre>
</div>
<p>
It appears like you need to call (json-getf obj keyword) in order to act as an accessor. E.g.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((data (boost-json:json-decode *nested-address-1*)))
  (setf (boost-json:json-getf data <span class="org-string">"first_name"</span>) <span class="org-string">"Michael"</span>)
  data)
#&lt;BOOST-JSON:JSON-OBJECT
{<span class="org-string">"first_name"</span>:<span class="org-string">"Michael"</span>,<span class="org-string">"last_name"</span>:<span class="org-string">"Washington"</span>,<span class="org-string">"birthday"</span>:<span class="org-string">"1732-02-22"</span>,<span class="org-string">"address"</span>:#}&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-decode-to-clos-cl-json" class="outline-4">
<h4 id="decode-to-clos-cl-json">Cl-json</h4>
<div class="outline-text-4" id="text-decode-to-clos-cl-json">
<p>
cl-json can decode and convert them to a cl-json:fluid-class CLOS object. You do need to at least temporarily set the change the decoder to use simple-clos-semantics and set the *json-symbols-package* to nil. (Note, this is thread unsafe unless you have pre-created. Per the documentation: "To maintain the mapping between lists of superclass names and fluid classes, the decoder maintains a class registry.  Thus, using fluid objects makes the CLOS decoder essentially thread-unsafe. (If every incoming JSON Object is guaranteed to have a prototype with a "lispClass" member then there are no fluid objects and thread safety is ensured.)  If the user wishes to employ fluid objects in a threaded environment it is advisable to wrap the body of entry-point functions in with-local-class-registry.")
</p>

<p>
First, looking at the simpler version, notice you need to specify the slots in the fluid-class object:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
 (setf cl-json:*json-symbols-package* nil)
 (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *address-1*)))
   (<span class="org-keyword">with-slots</span> (name birthday address) x
     (values x name birthday address)))))
#&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100F765713}&gt; {100FB22513}&gt;
<span class="org-string">"George Washington"</span>
<span class="org-string">"February 22, 1732"</span>
<span class="org-string">"Mount Vernon, Virginia, United States"</span>
</pre>
</div>
<p>
Now looking at the nested version, we need to note that by default cl-json will convert the underscores in the JSON keys to double hyphens in the slot names.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
 (setf cl-json:*json-symbols-package* nil)
 (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *nested-address-1*)))
   (<span class="org-keyword">with-slots</span> (first--name last--name birthday address) x
     (values x first--name last--name birthday address)))))
#&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100F765713}&gt; {10107CF9E3}&gt;
<span class="org-string">"George"</span>
<span class="org-string">"Washington"</span>
<span class="org-string">"1732-02-22"</span>
#&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100F765713}&gt; {10107CF6F3}&gt;
</pre>
</div>
<p>
Because we have a nested class, we would need drill down and specify the slots for the sub-object as well:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
 (setf cl-json:*json-symbols-package* nil)
 (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *nested-address-1*)))
   (<span class="org-keyword">with-slots</span> (first--name last--name birthday address) x
     (<span class="org-keyword">with-slots</span> (street--address city state country) address
       (values x first--name last--name birthday address city))))))
#&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100F765713}&gt; {1010E69B93}&gt;
<span class="org-string">"George"</span>
<span class="org-string">"Washington"</span>
<span class="org-string">"1732-02-22"</span>
#&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100F765713}&gt; {1010E698A3}&gt;
<span class="org-string">"Mount Vernon"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-decode-to-clos-trivial-json-codec" class="outline-4">
<h4 id="decode-to-clos-trivial-json-codec">Trivial-json-codec</h4>
<div class="outline-text-4" id="text-decode-to-clos-trivial-json-codec">
<p>
If you have defined your classes, trivial-json-codec does make it easy to decode JSON data directly to a vector of your classes. Suppose we have a simple person class:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defclass</span> <span class="org-type">person</span> ()
  ((name
    <span class="org-builtin">:initarg</span> <span class="org-builtin">:name</span> <span class="org-builtin">:initform</span> <span class="org-string">"Sabra"</span>
    <span class="org-builtin">:accessor</span> name)
   (eye-colour <span class="org-builtin">:initarg</span> <span class="org-builtin">:eye-colour</span>
    <span class="org-builtin">:initform</span> <span class="org-string">"brown"</span>
    <span class="org-builtin">:accessor</span> eye-colour)))
</pre>
</div>
<p>
If we have a vector of JSON objects which are all data for a person class, we can automatically build a vector of persons by specifying the class we want to use:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((data
        (trivial-json-codec:deserialize-json
         <span class="org-string">"[{\"name\":\"Claudia\",\"eye-colour\":\"blue\"},</span>
<span class="org-string">           {\"name\":\"Johann\",\"eye-colour\":\"brown\"}]"</span>
         <span class="org-builtin">:class</span> (find-class 'person))))
  (name (aref data 1)))
<span class="org-string">"Johann"</span>
</pre>
</div>
<p>
There is no magic if the JSON array has objects of different types.
</p>
</div>
</div>
</div>
<div id="outline-container-extracting-subset" class="outline-3">
<h3 id="extracting-subset">Extracting a Subset of a JSON object</h3>
<div class="outline-text-3" id="text-extracting-subset">
<p>
Suppose you just want a subset of data from a JSON file. Obviously every library allows you to parse the entire JSON file and then use standard lisp functions to pull out the subset you want. Only a few libraries will extract the desired subset directly.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 16:</span> Extracting a Data Subset from JSON Object</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">NO</td>
<td class="org-left">But see <a href="#cl-json-helper">cl-json-helper</a>'s json-key-value function</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left"><a href="#jonathan-filters">YES</a></td>
<td class="org-left">First level of data only. Also remember jonathan only reads strings, not streams</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left"><a href="#jsown-filters">YES</a></td>
<td class="org-left">But remember jsown only reads strings, not streams</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">NO</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-determining-object-keywords" class="outline-3">
<h3 id="determining-object-keywords">Determining Object Keywords</h3>
<div class="outline-text-3" id="text-determining-object-keywords">
<p>
Jsown has the ability, once a JSON object has been parsed into a jsown object, to get the keywords of the object. The following only gets the first level keywords.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:keywords (jsown:parse  *nested-address-1* ))

(<span class="org-string">"first_name"</span> <span class="org-string">"last_name"</span> <span class="org-string">"birthday"</span> <span class="org-string">"address"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-decoding-nil" class="outline-3">
<h3 id="decoding-nil">Handling NIL</h3>
<div class="outline-text-3" id="text-decoding-nil">
<p>
This is a test of how the library function for reading from a string handles nil. Errors are not surprising.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 17:</span> Reading NIL</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-decode</td>
<td class="org-left">Error</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">json-decode-from-string</td>
<td class="org-left">Error</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">parse-json</td>
<td class="org-left">NIL</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">parse</td>
<td class="org-left">Error</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">parse</td>
<td class="org-left">Error</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">parse</td>
<td class="org-left">""</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-parse</td>
<td class="org-left">Error</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">parse</td>
<td class="org-left">NIL</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">read-json</td>
<td class="org-left">Error</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">deserialize-raw</td>
<td class="org-left">Error</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">parse</td>
<td class="org-left">Error</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-encoding" class="outline-2">
<h2 id="encoding">Encoding Lisp Data to JSON</h2>
<div class="outline-text-2" id="text-encoding">
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 18:</span> Basic Encoding Functions for Each Library</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Base Function</th>
<th scope="col" class="org-left">Specialist Functions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">encode-json-to-string, encode-json-alist encode-json-alist-to-string, encode-json-plist, encode-json-plist-to-string, encode-object-member, encode-array-member</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">to-json, write-json</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">to-json*</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">write-json-string, write-json*</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">write-json-to-string, write-json-element</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec (1)</td>
<td class="org-left">serialize</td>
<td class="org-left">serialize-json</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">encode-alist, encode-plist, encode-object, encode-slots, encode-object-element, encode-array-element, encode-array-elements</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) As previously noted, trivial-json-codec is really intended as a parser (one way) from JSON to CL, not really serializing to JSON.</li>
</ul>
</div>

<div id="outline-container-encoding-streams-or-strings" class="outline-3">
<h3 id="encoding-streams-or-strings">Encoding to Streams or Strings</h3>
<div class="outline-text-3" id="text-encoding-streams-or-strings">
<p>
Does the library take both strings and streams as output?
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 19:</span> Strings and Streams As Output</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">String Function</th>
<th scope="col" class="org-left">Stream Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">json-encode</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">encode-json-to-string</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">to-json</td>
<td class="org-left">write-json</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">stringify</td>
</tr>

<tr>
<td class="org-left"><a href="#jonathan-unicode">jonathan</a></td>
<td class="org-left">to-json</td>
<td class="org-left">with-output &#x2026;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">with-json-output</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">write-json</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json-to-string</td>
<td class="org-left">write-json</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize or serialize-json</td>
<td class="org-left">serialize</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">encode</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-encoding-symbols" class="outline-3">
<h3 id="encoding-symbols">Encoding Symbols, Chars, T, nil and :null</h3>
<div class="outline-text-3" id="text-encoding-symbols">
<p>
Several libraries have an issue encoding symbols. Typically these can be resolved if you write a method for handling symbols. Of course, if you have symbols in your lisp data, you might want to look at libraries which handle them without any additional effort on your part.
</p>

<p>
As mentioned when discussing mapping from JSON to CL, there is a problem with null in that it represents "unknown", not false. CL does not have that as a data type, which is unfortunate. You cannot determine, absent other additional data, whether CL's NIL = [] or NIL = False or "unknown". As a result, you really have to pay attention serializing to and from JSON as to what you want nil to represent and whether it is unacceptably overloaded.
</p>

<p>
The following table uses 'a as the symbol input and #\C as a character input. :null was used as a proxy for null.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 20:</span> Quick Summary - Encoding Functionality 1</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Symbol</th>
<th scope="col" class="org-left">Char</th>
<th scope="col" class="org-left">T</th>
<th scope="col" class="org-left">Nil/:NULL</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">"\"A\""</td>
<td class="org-left">Error (3)</td>
<td class="org-left">"true"</td>
<td class="org-left">"null"/"NULL"</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">"a"</td>
<td class="org-left">"C"</td>
<td class="org-left">true</td>
<td class="org-left">null/"null" (4)</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">Error (1)</td>
<td class="org-left">Hangs (3)</td>
<td class="org-left">true</td>
<td class="org-left">{}/null</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">"\"A\""</td>
<td class="org-left">[] (3)</td>
<td class="org-left">"true"</td>
<td class="org-left">"false"/"NULL"</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">"\"A\""</td>
<td class="org-left">Error (3)</td>
<td class="org-left">"true"</td>
<td class="org-left">"[]"/"null"</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">"null" (2)</td>
<td class="org-left">"null" (3)</td>
<td class="org-left">"true"</td>
<td class="org-left">"null"/"null"</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Error (3)</td>
<td class="org-left">Error (3)</td>
<td class="org-left">"true"</td>
<td class="org-left">"false"/"null"</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">"\"A\""</td>
<td class="org-left">Error (3)</td>
<td class="org-left">"true"</td>
<td class="org-left">"[]"/"null"</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">"A"</td>
<td class="org-left">"C"</td>
<td class="org-left">"true"</td>
<td class="org-left">false/null</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">Error (3)</td>
<td class="org-left">Error (3)</td>
<td class="org-left">"true"</td>
<td class="org-left">[]/null</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">"A"</td>
<td class="org-left">Error (3)</td>
<td class="org-left">"true"</td>
<td class="org-left">"null"/":NULL"</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">Error (5)</td>
<td class="org-left">Error (3)</td>
<td class="org-left">true</td>
<td class="org-left">null/null</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) Keywords Only</li>
<li>(2) returns "null"</li>
<li>(3) You could write a method to handle this type. For jonathan, see <a href="#jonathan-encoding">jonathan-encoding</a>. For st-json see <a href="#st-json-encoding">st-json-encoding</a>.</li>
<li>(4) You can use the helper library <a href="https://github.com/stablecross/cl-json-helper">cl-json-helper</a> to encode nil as "false".</li>
<li>(5) Using yason to encode a symbol would require the use of yason:encode-symbol-as-lowercase rather than just the simple yason:encode</li>
</ul>
</div>
</div>

<div id="outline-container-encoding-numbers" class="outline-3">
<h3 id="encoding-numbers">Encoding Numbers</h3>
<div class="outline-text-3" id="text-encoding-numbers">
<p>
There are no surprises in encoding integers. Floats are generally fine depending on your view of rounding and the use of exponents. Ratios get slightly more interesting. Json-streams and trivial-json-codec were the only libraries to refuse to encode a ratio number. Json-lib wrote it as the string "null". The rest converted it to some form of digital number. The following table uses 9/4 as the sample data.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 21:</span> Encoding Encoding Float</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-right">Float</th>
<th scope="col" class="org-left">Ratios</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original Numbers</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">3.675</td>
<td class="org-left">9/4</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-right">3.675</td>
<td class="org-left">"2.25"</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-right">3.675</td>
<td class="org-left">2.25</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-right">3.674999952316284</td>
<td class="org-left">2.25</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-right">3.675</td>
<td class="org-left">"2.25"</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-right">3.675</td>
<td class="org-left">"2.25"</td>
</tr>

<tr>
<td class="org-left">json-lib (1)</td>
<td class="org-left">stringify</td>
<td class="org-right">3.675</td>
<td class="org-left">"null"</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-right">3.675</td>
<td class="org-left">Error (2)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-right">3.675</td>
<td class="org-left">"2.25"</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-right">3.675e+0</td>
<td class="org-left">2.25e+0</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-right">0.3675e+1</td>
<td class="org-left">0.2373e+2</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-right">3.675</td>
<td class="org-left">Error (2)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-right">3.674999952316284</td>
<td class="org-left">2.25</td>
</tr>
</tbody>
</table>
<p>
(1) As of the time of writing, json-lib only handles integers and floats, not ratios.
(2) Error: JSON write error: Number must be integer or float, got 9/4.
</p>
</div>
</div>
<div id="outline-container-encoding-pathnames" class="outline-3">
<h3 id="encoding-pathnames">Encoding Pathnames</h3>
<div class="outline-text-3" id="text-encoding-pathnames">
<p>
Just to see what the libraries did with pathnames, using #P"/home/sabra" as sample data. Out of the box, only boost-json and shasht turned it into a string. cl-json, jonathan, jsown, st-json, trivial-json-codec and yason indicate that you could write a method to handle the path datatype.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 22:</span> Encoding Pathnames</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">"/home/sabra"</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">Not of a type which can be encoded by encode-json</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">hangs</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">"/home/sabra"</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">No applicable method</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Fell through etypecase expression</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">No applicable method</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">"home/sabra"</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">Cannot write object of type Pathname to json</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">No applicable method</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">No applicable method</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-encoding-timestamps" class="outline-3">
<h3 id="encoding-timestamps">Encoding Local-Time Timestamps</h3>
<div class="outline-text-3" id="text-encoding-timestamps">
<p>
Again, just to see what the libraries did with timestamps, using (local-time:now) as sample data. This is actually just a preview of what happens with CLOS objects. We did have more libraries handling the timestamp and returning a JSON object, but none returned a JSON data object. As you can see, cl-json, com.inuoe.json, shasht and trivial-json-codec returned an object. Boost-json, jonathan, jsown, st-json and yason all indicate you could write a method to handle the timestamp.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 23:</span> Encoding Encoding Timestamps</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">There is no applicable method for the generic function</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">{"day":7990,"sec":48161,"nsec":580943000}</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">hangs</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">{"day":7990,"sec":48161,"nsec":580943000}</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">There is no applicable method for the generic function</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">@2022-01-15T08:22:41.580943-05:00 fell through ETYPECASE expression.</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">There is no applicable method for the generic function</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">{ "DAY": 7990,  "SEC": 48161,  "NSEC": 580943000}</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">Can not write object of type TIMESTAMP as JSON.</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">{ "DAY" : 7990,  "SEC" : 48161,  "NSEC" : 580943000}</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">There is no applicable method for the generic function</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-encoding-data-structures" class="outline-3">
<h3 id="encoding-data-structures">Encoding Data Structures to JSON (Summary)</h3>
<div class="outline-text-3" id="text-encoding-data-structures">
<p>
The following table is just a quick summary of library functionality for arrays, hashtables, CLOS objects and structs. More detail is provided in specific section for each of those categories of data structures.
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 24:</span> Quick Summary - Encoding Functionality Array/Hashtable/CLOS</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left"><a href="#encoding-arrays">Vectors</a></th>
<th scope="col" class="org-left"><a href="#encoding-hash-tables">Hash-table</a></th>
<th scope="col" class="org-left"><a href="#encoding-objects">Object</a></th>
<th scope="col" class="org-left"><a href="#encoding-structs">Struct</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">(6)</td>
<td class="org-left">(1)</td>
<td class="org-left">(4)</td>
<td class="org-left">(4)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json-to-string</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
<td class="org-left">(4)</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">YES</td>
<td class="org-left">(2)</td>
<td class="org-left">hangs</td>
<td class="org-left">hangs</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
<td class="org-left">YES (5)</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json  (8)</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
<td class="org-left">(4)</td>
<td class="org-left">(4)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
<td class="org-left">"null"</td>
<td class="org-left">NO</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">(3)</td>
<td class="org-left">(3)</td>
<td class="org-left">(3)</td>
<td class="org-left">(3)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">YES (10)</td>
<td class="org-left">YES</td>
<td class="org-left">(4)</td>
<td class="org-left">(4)</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">YES (10)</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">(7)</td>
<td class="org-left">(1)</td>
<td class="org-left">(4)</td>
<td class="org-left">(4)</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">YES</td>
<td class="org-left">(4)</td>
<td class="org-left">YES</td>
<td class="org-left">(4)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode-* (9)</td>
<td class="org-left">YES</td>
<td class="org-left">(1) (4)</td>
<td class="org-left">(4)</td>
<td class="org-left">(4)</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) Succeeds if the hash-table keys are strings, fails if they are symbols</li>
<li>(2) Invalid results if given a list inside the hash-table or errors if the hash-table keys are symbols</li>
<li>(3) The basic json-stringify function does not handle data structures, so you need to resort to more complex calls. See <a href="#json-streams-encoding-hash-tables">json-streams-encoding-hash-tables</a> or <a href="#json-streams-encoding-arrays">json-streams-encoding-arrays</a> for examples.</li>
<li>(4) May be able to resolve if you write a specialized method.</li>
<li>(5) Automatically handles standard CLOS objects and also allows you to specialize</li>
<li>(6) Invalid results Sample output on a simple nested array looked like: [,"Cork","Limerick"][,[,"Frankfurt","Munich"]]</li>
<li>(7) You need to write your own st-json::write-json-element function for arrays.</li>
</ul>
<p>
See <a href="#st-json-encoding">st-json-encoding</a>.
</p>
<ul class="org-ul">
<li>(8) Typically for these objects jonathan requires extra keyword parameters like :from :alist</li>
<li>(9) May require using one of the more specialized functions such as encode-alist etc.</li>
<li>(10) jsown and shasht are the only libraries which can handle multi-dimensional arrays.</li>
</ul>
</div>
</div>

<div id="outline-container-encoding-lists" class="outline-3">
<h3 id="encoding-lists">Encoding Lists (Summary)</h3>
<div class="outline-text-3" id="text-encoding-lists">
<p>
By default, all libraries except json-streams:json-stringify (which does not accept lists) and trivial-json-codec (which generates invalid JSON) will return a JSON array when provided a plain CL list. Some libraries will not accept non-keyword symbols in a list (or will need an additional parameter). If you need to keep the key-value connections of a plist, you may need to convert the plist to another form or use a more specific function. More detail can be found <a href="#encoding-lists">below</a> <a href="#encoding-plain-lists">plain-lists</a>, <a href="#encoding-alists">encoding alists</a>, <a href="#encoding-plists">encoding plists</a>.
</p>

<p>
In general, plain lists and plists are returned as JSON arrays unless some other keyword parameter is provided. If the library handles alists, they may be returned as JSON objects enclosing arrays, arrays enclosing arrays, or other variations. See <a href="#encoding-alists">encoding-alists</a> for more detail. Please set the footnotes to see if libraries have issues with symbols (including keyword symbols).
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 25:</span> Quick Summary - Encoding Functionality Lists</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left"><a href="#encoding-lists">lists</a></th>
<th scope="col" class="org-left"><a href="#encoding-alists">alists</a></th>
<th scope="col" class="org-left"><a href="#encoding-plists">plists</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">YES</td>
<td class="org-left">(7)</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
<td class="org-left">(8)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json-alist</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
<td class="org-left">(11)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json-plist</td>
<td class="org-left">YES</td>
<td class="org-left">(9)</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">(2)(12)</td>
<td class="org-left">(1)</td>
<td class="org-left">(2)</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">YES</td>
<td class="org-left">YES (13)</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">(4)</td>
<td class="org-left">(1)</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">(6)</td>
<td class="org-left">(6)</td>
<td class="org-left">(6)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">YES</td>
<td class="org-left">(1) (10)</td>
<td class="org-left">(3)</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">YES</td>
<td class="org-left">YES (10)</td>
<td class="org-left">(3)</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">(14)</td>
<td class="org-left">(14)</td>
<td class="org-left">(14)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">(5)</td>
<td class="org-left">(5)</td>
<td class="org-left">(5)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode-plist</td>
<td class="org-left">(12)</td>
<td class="org-left">YES</td>
<td class="org-left">YES</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode-alist</td>
<td class="org-left">(5)</td>
<td class="org-left">YES</td>
<td class="org-left">(3)</td>
</tr>
</tbody>
</table>


<ul class="org-ul">
<li>(1)  com.gigamonkeys.json, json-lib cannot deal with alists directly. Consider using alexandria:alist-hash-table to convert the alist to a hash table.</li>
<li>(2) Symbols are allowed only if they are keyword symbols, otherwise com.gigamonkeys.json will error.</li>
<li>(3) Plists are treated the same as plain lists and will lose their key-value connections. Convert to a hash table first.</li>
<li>(4) Symbols are allowed only if they are keyword symbols. Json-lib will convert a non-keyword symbol to null.</li>
<li>(5) If it is a plain list or plist, yason:encode and yason:encode-alist will not accept symbols in the list. If it is an alist which has symbols, it will accept them as keys if you run (setf yason:*symbol-key-encoder* 'yason:ENCODE-SYMBOL-AS-LOWERCASE) first. Otherwise it errors.</li>
<li>(6) Json-streams:json-stringify does not accept lists as input. You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
<li>(7) Fail - the JSON arrays are invalid. They have ',.' or ',' rather than ':' depending on whether they are dotted cons cells or not.</li>
<li>(8) As you might expect, plists are treated the same as plain lists and will lose their key-value connections. If you want to keep the key-value connections, you can either convert the list to an alist or hash-table or use the cl-json:encode-json-plist function.</li>
<li>(9) This function is plist specific and will error if provided an alist.</li>
<li>(10) If the alist has dotted cons cells, jsown and st-json triggered unhandled memory faults with SBCL 2.1.11-x86-64-linux, CCL version 1.12.1 LinuxX8664 and ecl-version 21.2.1. This appears to be because jsown and st-json have optimized the code and assumed that all lists will be proper lists. The assumption obviously fails in the context of dotted cons cells.</li>
<li>(11) The *-alist functions require an alist. Shocking, I know.</li>
<li>(12) com.gigamonkeys.json will assume a plain list is a plist, returning a JSON object with key-value pairs. If the length of the list is odd, the final value in the list will be treated as a key and an empty set will be inserted as the value.</li>
<li>(13) For jonathan to properly handle alists, you need to add the additional keyword parameters :from :alist</li>
<li>(14) Trivial-json-codec is going to give us invalid JSON from now on with respect to tests involving lists - e.g. '(a b c)) becomes "&lt;A,B,C&gt;", so we will drop it from the rest of the encoding tests involving lists.</li>
</ul>
</div>
</div>

<div id="outline-container-encoding-plain-lists" class="outline-3">
<h3 id="encoding-plain-lists">Encoding Plain Lists</h3>
<div class="outline-text-3" id="text-encoding-plain-lists">
<p>
As noted above, if you had symbols in a list, libraries like json-streams and st-json are going to error out because they need additional methods, while com.gigamonkeys.json accepts only keyword symbols. In the below table, I included trivial-json-codec's results without the error that it generates on ratio numbers. Notice that gigamonkeys is interpreting the list as a plist and trying to create key:value pairs.
</p>

<p>
Using '("A" "b" 4 3.2 9/4) as the sample data
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 26:</span> Encoding Lists without Symbols</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">'("A" "b" 4 3.2 9/4)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">["A","b",4,3.2,2.25]</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">["A","b",4,3.2,2.25]</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">{"A":"b","4":3.200000047683716,"2.25":{}}</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">["A","b",4,3.2,2.25]</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">"[\"A\",\"b\",4,3.2,2.25]"</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">"[\"A\", \"b\", 4, 3.2, 9/4]"</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Fail on list,  (1)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">"[\"A\",\"b\",4,3.2,2.25]"</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">["A","b",4,3.2e+0,2.25e+0]</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">["A","b",4,0.32e+1,0.225e+1]</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec (2)</td>
<td class="org-left">serialize-json</td>
<td class="org-left">"&lt;\"A\",\"b\",4,3.2&gt;"</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">["A","b",4,3.200000047683716,2.25]</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
<li>(2) I have no idea why trivial-json-codec wants to generate angle brackets.</li>
</ul>
</div>
</div>

<div id="outline-container-encoding-alists" class="outline-3">
<h3 id="encoding-alists">Encoding Alists</h3>
<div class="outline-text-3" id="text-encoding-alists">
<p>
I discovered that many libraries have problems if the alist components are dotted pairs (improper lists). So we break alists down between alists with dotted pairs and alists without dotted pairs. We will keep symbols out of the sample data because we already know from <a href="#encoding-symbols">encoding-symbols</a> that some libraries will have issues with alists containing symbols as keys. Of note:
</p>

<ul class="org-ul">
<li>cl-json provides a function to encode the alist properly as key:value,</li>
<li>com.inuoe.jzon correctly guesses this is a alist which should be encoded as key:value,</li>
<li>shasht:*write-alist-as-object* provides the ability to write an undotted alist as a JSON object rather than an array.</li>
<li>yason provides a specific function to encode the alist properly as key:value,</li>
<li>If the alist has dotted cons cells, jsown and st-json triggered unhandled memory faults with SBCL 2.1.11-x86-64-linux, CCL version 1.12.1 LinuxX8664 and ecl-version 21.2.1. This appears to be because jsown and st-json have optimized the code and assumed that all lists will be proper lists. The assumption obviously fails in the context of dotted cons cells.</li>
</ul>
</div>
<div id="outline-container-encoding-alists-dotted-cons-cells" class="outline-5">
<h5 id="encoding-alists-dotted-cons-cells">Dotted cons cells (dotted pairs)</h5>
<div class="outline-text-5" id="text-encoding-alists-dotted-cons-cells">
<p>
Using '(("A" . 1) ("B" . 2) ("C" . 3)) as the sample data
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 27:</span> Encoding Dotted Alists Without Symbols</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">'(("A" . 1) ("B" . 2) ("C" . 3))</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json (1)</td>
<td class="org-left">json-encode</td>
<td class="org-left">[["A",. 1],["B",. 2],["C",. 3]]</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">{"A":1,"B":2,"C":3}</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json-alist</td>
<td class="org-left">{"A":1,"B":2,"C":3}</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">Error:Can't stringify (A . 1)</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">"{\"A\":1,\"B\":2,\"C\":3}"</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">Error: value 1 is not of type list</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json XXX :from :alist</td>
<td class="org-left">"{\"A\":1,\"B\":2,\"C\":3}"</td>
</tr>

<tr>
<td class="org-left">json-lib  (2)</td>
<td class="org-left">stringify</td>
<td class="org-left">Error value 1 is not of type list</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Error (5)</td>
</tr>

<tr>
<td class="org-left">jsown  (4)</td>
<td class="org-left">to-json</td>
<td class="org-left">Unhandled memory fault</td>
</tr>

<tr>
<td class="org-left">shasht (3)</td>
<td class="org-left">write-json</td>
<td class="org-left">{ "A": 1, "B": 2, "C": 3}</td>
</tr>

<tr>
<td class="org-left">st-json (4)</td>
<td class="org-left">write-json</td>
<td class="org-left">Unhandled memory fault</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode-alist</td>
<td class="org-left">{"A":1,"B":2,"C":3}</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) Fail - the JSON arrays are invalid. They have ',.' rather than ','</li>
<li>(2) You may be able to write a new method to handle dotted.</li>
<li>(3) Only if (setf shasht:*write-alist-as-object* t), which is not the default. Otherwise it generates an error.</li>
<li>(4) If the alist has dotted cons cells, jsown and st-json triggered unhandled memory faults with SBCL 2.1.11-x86-64-linux, CCL version 1.12.1 LinuxX8664 and ecl-version 21.2.1. This appears to be because jsown and st-json have optimized the code and assumed that all lists will be proper lists. The assumption obviously fails in the context of dotted cons cells.</li>
<li>(5) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
</ul>

<p>
Now we change the data slightly, still using dotted pairs, but with a nested list as the value in one pair: Using '(("foo" . "bar") ("baz" . ((1 2 3) (4 5 6)))) as the sample data.
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 28:</span> Encoding Dotted Alists without symbols with more complex values</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">'(("foo" . "bar") ("baz" . ((1 2 3) (4 5 6))))</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json (1)</td>
<td class="org-left">json-encode</td>
<td class="org-left">[["foo",. "bar"],["baz",[1,2,3],[4,5,6]]]</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">{"foo":"bar","baz":[[1,2,3],[4,5,6]]}</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json-alist</td>
<td class="org-left">{"foo":"bar","baz":[[1,2,3],[4,5,6]]}</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">Error:Can't stringify (foo . bar)</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">{"foo":"bar","baz":[[1,2,3],[4,5,6]]}</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">Error: value 1 is not of type list</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json XXX :from :alist</td>
<td class="org-left">{"foo":"bar","baz":{"1":[2,3],"4":[5,6]}}</td>
</tr>

<tr>
<td class="org-left">json-lib  (2)</td>
<td class="org-left">stringify</td>
<td class="org-left">Error value "bar" is not of type list</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Error (5)</td>
</tr>

<tr>
<td class="org-left">jsown  (4)</td>
<td class="org-left">to-json</td>
<td class="org-left">Unhandled memory fault</td>
</tr>

<tr>
<td class="org-left">shasht (3)</td>
<td class="org-left">write-json</td>
<td class="org-left">Error: The value "bar" is not of type LIST</td>
</tr>

<tr>
<td class="org-left">shasht (3a)</td>
<td class="org-left">write-json</td>
<td class="org-left">{"foo":"bar","baz":{1:[2,3],4:[5,6]}}</td>
</tr>

<tr>
<td class="org-left">st-json (4)</td>
<td class="org-left">write-json</td>
<td class="org-left">Unhandled memory fault</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">Error: "bar" is not of type list</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode-alist</td>
<td class="org-left">{"foo":"bar","baz":[[1,2,3],[4,5,6]]}</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) Fail - the JSON arrays are invalid. They have ',.' rather than ','</li>
<li>(2) You may be able to write a new method to handle dotted.</li>
<li>(3) This error is generated if shasht:*write-alist-as-object* is nil (the default).</li>
<li>(3a) If shasht:*write-alist-as-object* is t (not the default).</li>
<li>(4) If the alist has dotted cons cells, jsown and st-json triggered unhandled memory faults with SBCL 2.1.11-x86-64-linux, CCL version 1.12.1 LinuxX8664 and ecl-version 21.2.1. This appears to be because jsown and st-json have optimized the code and assumed that all lists will be proper lists. The assumption obviously fails in the context of dotted cons cells.</li>
<li>(5) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
</ul>

<p>
Notice the difference in the successful results. cl-json and yason's result of {"foo":"bar","baz":[[1,2,3],[4,5,6]]} is what I would have expected. jonathan tried to force a key value pair into the second alist value. {"foo":"bar","baz":{"1":[2,3],"4":[5,6]}}.
</p>

<p>
com.inuoe.jzon is a special case here. It uses heuristics to predict what data structure it is using and this particular sample works because it does not try to make an integer into a key. if the sample data had been something like
</p>
<div class="org-src-container">
<pre class="src src-lisp">'((<span class="org-string">"foo"</span> . <span class="org-string">"bar"</span>) (<span class="org-string">"baz"</span> . ((<span class="org-string">"A"</span> 2 3) (<span class="org-string">"B"</span> 5 6))))
</pre>
</div>
<p>
it would have predicated that the "A" and "B" should be keys and would have returned
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span class="org-string">"{\"foo\":\"bar\",\"baz\":{\"A\":[2,3],\"B\":[5,6]}}"</span>
</pre>
</div>
<p>
which may or may not have been what you wanted.
</p>
</div>
</div>

<div id="outline-container-encoding-alists-undotted-cons-cells" class="outline-5">
<h5 id="encoding-alists-undotted-cons-cells">Without dotted cons cells</h5>
<div class="outline-text-5" id="text-encoding-alists-undotted-cons-cells">
<p>
Using '(("A" 1) ("B"  2) ("C" 3)) as the sample data.
</p>

<p>
Note difference in results. Some libraries return arrays, others return objects. Some libraries return key:[value] pairs, others return two member arrays.
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 29:</span> Encoding Undotted Alists with simple values</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">'(("A" 1) ("B"  2) ("C" 3))</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">boost-json-write-to-string</td>
<td class="org-left">[["A",1],["B",2],["C",3]]</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">[["A",1],["B",2],["C",3]]</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json-alist</td>
<td class="org-left">{"A":[1],"B":[2],"C":[3]}</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">gigamonkeys-write-to-string</td>
<td class="org-left">Can't stringify (A 1)</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">{"A":[1],"B":[2],"C":[3]}</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">jonathan-to-json-alist</td>
<td class="org-left">{"A":[1],"B":[2],"C":[3]}</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">[["A",1],["B",2],["C",3]]</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Error (1)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">[["A",1],["B",2],["C",3]]</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">[["A",1],["B",2],["C",3]]</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json-to-string</td>
<td class="org-left">[["A",1],["B",2],["C",3]]</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">[["A",1],["B",2],["C",3]]</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode-alist</td>
<td class="org-left">{"A":[1],"B":[2],"C":[3]}</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) Using json-stringify caused the alist used as data to fall through etypecase expression demanding a json-streams:json-array. That means that you have to fall back to more complicated calls. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
</ul>

<p>
Let's make the value portion of the alist another alist. Now using '(("foo" "bar") ("baz" ((1 2 3) (4 5 6)))) as the sample data. The results may or may not be what you want, so look at them carefully.
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 30:</span> Encoding Undotted Alists with more complex values (1)</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">'(("foo" "bar") ("baz" ((1 2 3) (4 5 6))))</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">[["foo","bar"],["baz",[[1,2,3],[4,5,6]]]]</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">[["foo","bar"],["baz",[[1,2,3],[4,5,6]]]]</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json-alist</td>
<td class="org-left">[["foo","bar"],["baz",[[1,2,3],[4,5,6]]]]</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">Can't stringify (foo bar)</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">{"foo":["bar"],"baz":[[[1,2,3],[4,5,6]]]}</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json XX :from :alist</td>
<td class="org-left">{"foo":["bar"],"baz":[{"1":[2,3],"4":[5,6]}]}</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">[["foo", "bar"], ["baz",[[1,2,3],[4,5,6]]]]</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Error (1)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">[["foo","bar"],["baz",[[1,2,3],[4,5,6]]]]</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">[["foo","bar"],["baz",[[1,2,3],[4,5,6]]]]</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">[["foo","bar"],["baz",[[1,2,3],[4,5,6]]]]</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">[["foo","bar"],["baz",[[1,2,3],[4,5,6]]]]</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode-alist</td>
<td class="org-left">{"foo":["bar"],"baz":[[[1,2,3],[4,5,6]]]}</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
</ul>

<p>
Yason:encode-alist, com.inuoe.jzon and jonathan return JSON objects with key pairs; the rest try to return arrays. jonathan seem to be trying to force a key value pair into the baz values when I do not think this is probably what you want. Yason and com.inuoe.jzon's heuristics return the same result. Let's change the data slightly and just look at these two libraries again.
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 31:</span> Encoding Undotted Alists with more complex values (2)</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">New data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">'(("foo" "bar") ("baz" ((1 2 3) ("A" 5 6))))</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">{"foo":["bar"],"baz":[[[1,2,3],["A",5,6]]]}</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">[["foo","bar"],["baz",[[1,2,3],["A",5,6]]]]</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode-alist</td>
<td class="org-left">{"foo":["bar"],"baz":[[[1,2,3],["A",5,6]]]}</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">New data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">'(("foo" "bar") ("baz" (("B" 2 3) ("A" 5 6))))</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">{"foo":["bar"],"baz":[{"B":[2,3],"A":[5,6]}]}</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">[["foo","bar"],["baz",[["B",2,3],["A",5,6]]]]</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode-alist</td>
<td class="org-left">{"foo":["bar"],"baz":[[["B",2,3],["A",5,6]]]}</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-encoding-plists" class="outline-3">
<h3 id="encoding-plists">Encoding Plists</h3>
<div class="outline-text-3" id="text-encoding-plists">
<ul class="org-ul">
<li>cl-json:encode-json (returns array) and cl-json:encode-json-plist (returns object). cl-json provides a specialized function to encode the plist properly as key:value</li>
<li>com.inuoe.jzon correctly guesses this is a plist which should be encoded as key:value</li>
<li>With keyword symbols, jonathan returns an object, but otherwise returns an array.</li>
<li>yason provides a function to encode the plist properly as key:value</li>
</ul>

<p>
Using '("a" 1 "b" 2 "c" 3) as the sample data
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 32:</span> Encoding Plists</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">'("a" 1 "b" 2 "c" 3)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">["a",1,"b",2,"c",3]</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">["a",1,"b",2,"c",3]</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json-plist</td>
<td class="org-left">{"a":1,"b":2,"c":3}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">{"a":1,"b":2,"c":3}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">"{\"a\":1,\"b\":2,\"c\":3}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">"[\"a\",1,\"b\",2,\"c\",3]"</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">"[\"a\", 1, \"b\", 2, \"c\", 3]"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Fail: (2)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">"[\"a\",1,\"b\",2,\"c\",3]"</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">["a",1,"b",2,"c",3]</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">"[\"a\",1,\"b\",2,\"c\",3]"</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">["a",1,"b",2,"c",3]</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode-plist</td>
<td class="org-left">{"a":1,"b":2,"c":3}</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) Encoding to array but loses the obvious key-value connection.</li>
<li>(2) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-encoding-arrays" class="outline-3">
<h3 id="encoding-arrays">Encoding Arrays</h3>
<div class="outline-text-3" id="text-encoding-arrays">
</div>

<div id="outline-container-encoding-vectors" class="outline-4">
<h4 id="encoding-vectors">Encoding Single Dimensional Vector</h4>
<div class="outline-text-4" id="text-encoding-vectors">
<p>
Boost-json loses the first value in the vector. Json-streams and st-json do not handle the vector. All the other libraries pass, although some get excited about the floating point number.
</p>

<p>
Using #("A" 1 2.3) as sample data.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 33:</span> Encoding Encoding Vectors</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">#("A" 1 2.3)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">[,1,2.3]</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">["A",1,2.3]</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">["A",1,2.299999952316284]</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">["A",1,2.3]</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">["A",1,2.3]</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">["A", 1, 2.3]</td>
</tr>

<tr>
<td class="org-left">json-streams (1)</td>
<td class="org-left">json-stringify</td>
<td class="org-left">#("A" 1 2.3) fell through ETYPECASE expression.</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">["A",1,2.3]</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">["A",1,2.2999999e+0]</td>
</tr>

<tr>
<td class="org-left">st-json (2)</td>
<td class="org-left">write-json</td>
<td class="org-left">Cannot write object of type (SIMPLE-VECTOR 3) as JSON.</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">"[\"A\",1,2.3]"</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">["A",1,2.299999952316284]</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
<li>(2) You need to write your own st-json::write-json-element function for arrays. Possibly something like:</li>
</ul>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmethod</span> <span class="org-function-name">write-json-element</span> ((element vector) stream)
  (<span class="org-keyword">declare</span> #.*optimize*)
  (write-char #\[ stream)
  (<span class="org-keyword">loop</span> <span class="org-builtin">:for</span> val <span class="org-builtin">:across</span> element
          <span class="org-builtin">:for</span> first <span class="org-builtin">:=</span> t <span class="org-builtin">:then</span> nil
          <span class="org-builtin">:unless</span> first <span class="org-builtin">:do</span> (write-char #\, stream)
          <span class="org-builtin">:do</span> (write-json-element val stream))
  (write-char #\] stream))
</pre>
</div>
<p>
See <a href="#st-json-encoding">st-json-encoding</a>.
</p>
</div>
</div>

<div id="outline-container-encoding-bit-vectors" class="outline-4">
<h4 id="encoding-bit-vectors">Encoding Simple Bit Vector</h4>
<div class="outline-text-4" id="text-encoding-bit-vectors">
<p>
Again boost-json, json-streams and st-json fail. The rest pass.
</p>

<p>
Using #*10110 as the sample data.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 34:</span> Encoding Bit Vectors</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Exported Function</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">#*10110</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">Fail [,0,1,1,0]</td>
<td class="org-left">Lost first item</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">[1,0,1,1,0]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">[1,0,1,1,0]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">[1,0,1,1,0]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">"[1,0,1,1,0]"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">"[1, 0, 1, 1, 0]"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Fail</td>
<td class="org-left">Default fails (1)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">"[1,0,1,1,0]"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">[1,0,1,1,0]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">Fail</td>
<td class="org-left">Default fails (2)</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">"[1,0,1,1,0]"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">[1,0,1,1,0]</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
<li>(2) Error: Can not write object of type (SIMPLE-BIT-VECTOR 5) as JSON. You can resolve this by writing your own method for handling symbols. See <a href="#st-json-encoding">st-json-encoding</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-encoding-nested-arrays" class="outline-4">
<h4 id="encoding-nested-arrays">Encoding Nested Arrays</h4>
<div class="outline-text-4" id="text-encoding-nested-arrays">
<p>
The following example uses a very simple nested array:
</p>
<div class="org-src-container">
<pre class="src src-lisp">#(#(<span class="org-string">"Dublin"</span> <span class="org-string">"Cork"</span> <span class="org-string">"Limerick"</span>) #(<span class="org-string">"Berlin"</span> <span class="org-string">"Frankfurt"</span> <span class="org-string">"Munich"</span>))
</pre>
</div>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 35:</span> Encoding Nested Array</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original data</td>
<td class="org-left">#(#("Dublin" "Cork" "Limerick") #("Berlin" "Frankfurt" "Munich"))</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">[,"Cork","Limerick"][,[,"Frankfurt","Munich"]]</td>
<td class="org-left">Fail</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">[["Dublin","Cork","Limerick"],["Berlin","Frankfurt","Munich"]]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">gigamonkeys</td>
<td class="org-left">[["Dublin","Cork","Limerick"],["Berlin","Frankfurt","Munich"]]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jzon</td>
<td class="org-left">[["Dublin","Cork","Limerick"],["Berlin","Frankfurt","Munich"]]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">[["Dublin","Cork","Limerick"],["Berlin","Frankfurt","Munich"]]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">[["Dublin", "Cork", "Limerick"], ["Berlin", "Frankfurt", "Munich"]]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#json-streams">json-streams</a></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">[["Dublin","Cork","Limerick"],["Berlin","Frankfurt","Munich"]]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">[["Dublin","Cork","Limerick"], ["Berlin","Frankfurt","Munich"]]</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left"><a href="#st-json">st-json</a></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">(2)</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">"[[\"Dublin\",\"Cork\",\"Limerick\"],[\"Berlin\",\"Frankfurt\",\"Munich\"]]"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">[["Dublin","Cork","Limerick"],["Berlin","Frankfurt","Munich"]]</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
<li>(2) Error: Can not write object of type (SIMPLE-BIT-VECTOR 5) as JSON. You can resolve this by writing your own method for handling symbols. See <a href="#st-json-encoding">st-json-encoding</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-encoding-2d-array" class="outline-4">
<h4 id="encoding-2d-array">Encoding 2 Dimensional Array Version</h4>
<div class="outline-text-4" id="text-encoding-2d-array">
<p>
Just to see what happens if we give the libraries a two dimensional array, let's use #2A((1.0 1.0) (1.0 1.0) (1.0 1.0)) as the sample data.
</p>

<p>
Jsown and shasht are the only libraries to handle a two dimensional array without the user having to write additional methods.
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 36:</span> Encoding 2D Array</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original data</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">#2A((1.0 1.0) (1.0 1.0) (1.0 1.0))</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">Error: No applicable method</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">Error: Unencodable value</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">Method emit-json hangs</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">{}</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">Error: No applicable method</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">"null"</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Error: (1)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">Passed "[[1.0,1.0],[1.0,1.0],[1.0,1.0]]"</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">Passed "[[1.0e+0,1.0e+0],[1.0e+0,1.0e+0],[1.0e+0,1.0e+0]]"</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">Error: Cannot write object as json</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">Error: value is not of type sequence</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">Error: No applicable method</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
<li>(2) You can resolve this by writing your own method for handling symbols. See <a href="#st-json-encoding">st-json-encoding</a>.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-encoding-hash-tables" class="outline-3">
<h3 id="encoding-hash-tables">Encoding hash-tables</h3>
<div class="outline-text-3" id="text-encoding-hash-tables">
</div>

<div id="outline-container-using-string-as-a-key" class="outline-4">
<h4 id="using-string-as-a-key">Using string as key</h4>
<div class="outline-text-4" id="text-using-string-as-a-key">
<p>
Using (alexandria:plist-hash-table '("foo" 1 "bar" (7 8 9)) :test #'equal) as the sample data:
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 37:</span> Encoding Hash Tables without Symbols</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">{"foo":1,"bar":[7,8,9]}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">{"foo":1,"bar":[7,8,9]}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">{"foo":1,"bar":{"7":8,"9":{}}}</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">"{\"foo\":1,\"bar\":[7,8,9]}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">"{\"foo\":1,\"bar\":[7,8,9]}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">"{\"foo\": 1, \"bar\": [7, 8, 9]}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Error</td>
<td class="org-left">(2)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">"{\"foo\":1,\"bar\":[7,8,9]}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">{ "foo": 1, "bar": [7,8,9]}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">{"foo":1,"bar":[7,8,9]}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">Error</td>
<td class="org-left">(3)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">{"foo":1,"bar":[7,8,9]}</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) The hash table encoding is fine. In this example com.gigamonkeys.json is treating the list which is a hash table value as a plist and trying to create key:value pairs.</li>
<li>(2) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
<li>(3) May be able to resolve this with writing your own method.</li>
</ul>
</div>
</div>
<div id="outline-container-using-symbol-as-a-key" class="outline-4">
<h4 id="using-symbol-as-a-key">Using symbol as key</h4>
<div class="outline-text-4" id="text-using-symbol-as-a-key">
<p>
Using (alexandria:plist-hash-table '(:foo 1 :bar (7 8 9)) :test #'eq) as the sample data:
Again, see what gigamonkeys is doing with respect to trying to treat the list as key:value pairs.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 38:</span> Encoding Hash Tables With Symbols as Key</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">FAIL: {}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">{"foo":1,"bar":[7,8,9]}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">{"foo":1,"bar":{"7":8,"9":{}}}</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">{"foo":1,"bar":[7,8,9]}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">{"FOO":1,"BAR":[7,8,9]}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">"{\"foo\": 1, \"bar\": [7,8,9]}"</td>
<td class="org-left">(2)</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Error</td>
<td class="org-left">(3)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">"{\"FOO\":1,\"BAR\":[7,8,9]}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">{"FOO": 1,"BAR": [7,8,9]}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">Error</td>
<td class="org-left">(4)</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">Error</td>
<td class="org-left">(5)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">Error</td>
<td class="org-left">(6)</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) The symbol must be a keyword symbol or com.gigamonkeys.json will error out. As noted above, it is also trying to treat the embedded list as key:value pairs rather than an array.</li>
<li>(2) If the symbols were not keywords, json-lib would return "{null: 1, null: [7, 8, 9]}"</li>
<li>(3) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
<li>(4) You will need to write your own method to handle symbols in this situation</li>
<li>(5) May be able to resolve this with writing your own method.</li>
<li>(6) There is no applicable method for the generic function when called with arguments :symbol</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-encoding-objects" class="outline-3">
<h3 id="encoding-objects">Encoding CLOS objects</h3>
<div class="outline-text-3" id="text-encoding-objects">
<p>
cl-json, com.inuoe.jzon and shasht all are able to encode CLOS objects by default. Boost-json, jonathan, jsown, st-json and yason require that you write methods for each class. With the other libraries you would either have to convert the clos object into another type (hash-table or alist etc.) or write a specific function for that particular class of object. We are using a very simple CLOS object here, just to test the water.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defclass</span> <span class="org-type">person</span> ()
  ((name
    <span class="org-builtin">:initarg</span> <span class="org-builtin">:name</span> <span class="org-builtin">:initform</span> <span class="org-string">"Sabra"</span>
    <span class="org-builtin">:accessor</span> name)
   (eye-colour <span class="org-builtin">:initarg</span> <span class="org-builtin">:eye-colour</span>
    <span class="org-builtin">:initform</span> <span class="org-string">"brown"</span>
    <span class="org-builtin">:accessor</span> eye-colour)))
</pre>
</div>
<p>
As you can see from the table below, at least in this simple example, cl-json, com.inuoe.jzon and shasht all are able to encode CLOS objects by default. Boost-json, jonathan, jsown, and yason require that you write methods for each class.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 39:</span> Encoding CLOS Objects</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">{"name":"Sabra","eyeColour":"brown"}</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">hangs</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">"{\"name\":\"Sabra\",\"eye-colour\":\"brown\"}" (4)</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">"null"</td>
</tr>

<tr>
<td class="org-left"><a href="#json-streams">json-streams</a></td>
<td class="org-left">json-stringify</td>
<td class="org-left">Error (2)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">{ "NAME": "Sabra", "EYE-COLOUR": "brown"}</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize-json</td>
<td class="org-left">"{\"NAME\":\"Sabra\",\"EYE-COLOUR\":\"brown\"}"</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">(1)</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) You need to write a method for each CLOS object.  See  <a href="#boost-json-encoding-clos">boost-json-encoding-clos</a>, <a href="#jonathan-encoding-clos">jonathan-encoding-clos</a>,,<a href="#jsown-encoding-clos">jsown-encoding-clos</a>, <a href="#st-json-encoding-clos">st-json-encoding-clos</a> or <a href="#yason-encoding-clos">yason-encoding-clos</a>.</li>
<li>(2) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-encoding-structs" class="outline-3">
<h3 id="encoding-structs">Encoding Structs</h3>
<div class="outline-text-3" id="text-encoding-structs">
<p>
Only com.inuoe.jzon and shasht were able to encode a struct without having to define a special method.
</p>

<p>
The sample data for the following table is:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*book1*</span> (make-book <span class="org-builtin">:title</span> <span class="org-string">"C Programming"</span>
                               <span class="org-builtin">:author</span> <span class="org-string">"Nuha Ali"</span>
                               <span class="org-builtin">:subject</span> <span class="org-string">"C-Programming Tutorial"</span>
                               <span class="org-builtin">:book-id</span> <span class="org-string">"478"</span>))
</pre>
</div>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 40:</span> Encoding Structs</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">json-encode</td>
<td class="org-left">Error (1)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">encode-json</td>
<td class="org-left">Error (2)</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">write-json</td>
<td class="org-left">hangs</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">stringify</td>
<td class="org-left">{"title":"C Programming","author":"Nuha Ali","subject":"C-Programming Tutorial","book-id":"478"}</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">to-json</td>
<td class="org-left">Error (1)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">stringify</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-stringify</td>
<td class="org-left">Error (3)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">to-json</td>
<td class="org-left">Error (1)</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">write-json</td>
<td class="org-left">{"TITLE":"C Programming","AUTHOR":"Nuha Ali","SUBJECT":"C-Programming Tutorial","BOOK-ID":"478"}</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">write-json</td>
<td class="org-left">Error (4)</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">serialize</td>
<td class="org-left">Error (1)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">encode</td>
<td class="org-left">Error (1)</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) No applicable method</li>
<li>(2) Not a type which can be encoded by encode-json</li>
<li>(3) You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
<li>(4) Can not write object of type BOOK as JSON.</li>
</ul>
</div>
</div>

<div id="outline-container-incremental-encoding" class="outline-3">
<h3 id="incremental-encoding">Incremental Encoding</h3>
<div class="outline-text-3" id="text-incremental-encoding">
<p>
Suppose you do not yet have a specific lisp data structure with all the data you want to encode to a single JSON object or array. A simple example would be intermediate function results during a loop. How would you go about writing it? Obviously you could collect all the results into a list or other CL data structure, or you could build a JSON object or array incrementally or write them to stream incrementally. Examples can be found in the library details section below using the appropriate links in the following table.
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 41:</span> Incremental Encoding</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Ability?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left"><a href="#cl-json-incremental">Yes</a></td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left"><a href="#jzon-incremental">Yes</a></td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left"><a href="#jonathan-incremental">Yes</a></td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left"><a href="#json-streams">json-streams</a></td>
<td class="org-left"><a href="#json-streams-incremental">Yes</a></td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left"><a href="#jsown-incremental">Yes</a></td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left"><a href="#shasht-incremental">Yes</a></td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left"><a href="#st-json-incremental">Yes</a></td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">No</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left"><a href="#yason-incremental">Yes</a></td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) being actively worked on</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-symmetry" class="outline-2">
<h2 id="symmetry">Symmetry</h2>
<div class="outline-text-2" id="text-symmetry">
<p>
Are the libraries symmetrical in the sense that (a) going from JSON to cl and back to JSON gets you the exact same JSON and (b) going from cl to JSON and back to cl gets you the exact same cl data and data structure? (This is sometimes called round-tripping.) This is critical to some users, not critical to others. If there was a 1:1 matching of cl and JSON data structures, this would be easy, but there isn't. JSON has a null that cl does not have and cl has many data structures that JSON does not have.
</p>

<p>
Consider starting from JSON and trying to get back to JSON. To quote Steve Losh: "For me, the most important quality I need in a JSON library is an unambiguous, one-to-one mapping of types. For example: some libraries will deserialize JSON arrays as Lisp lists, and JSON true/false as t/nil. But this means [] and false both deserialize to nil, so you can't reliably round trip anything!"
</p>

<p>
Now consider starting from cl and trying to get back to cl. A cl library that handles both lists and arrays might encode both as JSON arrays. But now when you decode the JSON array, are you decoding to a cl list or a cl array? If round-tripping is important to you, this will drive your choice of cl data structures so that you know what you are decoding back to. Similarly, what do you do with symbols?
</p>
</div>

<div id="outline-container-symmetry-json-cl-json" class="outline-3">
<h3 id="symmetry-json-cl-json">JSON -&gt; CL -&gt; JSON</h3>
<div class="outline-text-3" id="text-symmetry-json-cl-json">
</div>
<div id="outline-container-symmetry-json-cl-json1" class="outline-4">
<h4 id="symmetry-json-cl-json1">First test (Easy)</h4>
<div class="outline-text-4" id="text-symmetry-json-cl-json1">
<p>
In the first easy test, the only surprises were jonathan reversing the order of the elements in the JSON object and I do not know what trivial-json-codec is doing with the angle brackets in the JSON object test.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 42:</span> Symmetry Test 1 (Easy) JSON Object</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Pass/Fail</th>
<th scope="col" class="org-left">Resulting String</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">"{\"a\":1,\"b\":\"sales\",\"c\":true}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"a\":1,\"b\":\"sales\",\"c\":true}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"a\":1,\"b\":\"sales\",\"c\":true}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">PASS</td>
<td class="org-left">{"a":1,"b":"sales","c":true}</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"a\":1,\"b\":\"sales\",\"c\":true}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">FAIL</td>
<td class="org-left">"{\"c\":true,\"b\":\"sales\",\"a\":1}"</td>
<td class="org-left">Reversed order (2)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"a\":1,\"b\":\"sales\",\"c\":true}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"a\":1,\"b\":\"sales\",\"c\":true}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"a\":1,\"b\":\"sales\",\"c\":true}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"a\":1,\"b\":\"sales\",\"c\":true}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"a\":1,\"b\":\"sales\",\"c\":true}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">FAIL</td>
<td class="org-left">"&lt;&lt;\":A\",1&gt;,&lt;\":B\",\"sales\"&gt;,&lt;\":C\",true&gt;&gt;"</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"a\":1,\"b\":\"sales\",\"c\":true}"</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) trivial-json-codec is really intended as a parser (one way) from JSON to CL, not really serializing to JSON.</li>
<li>(2) Ignoring the reversed order issue, consider the following from jonathan. We decode a JSON object as an alist. Jonathan returns an alist with dotted pairs. E.g.</li>
</ul>
<div class="org-src-container">
<pre class="src src-lisp">(jonathan:parse <span class="org-string">"{\"a\":1,\"b\":2}"</span> <span class="org-builtin">:as</span> <span class="org-builtin">:alist</span>)
((<span class="org-string">"b"</span> . 2) (<span class="org-string">"a"</span> . 1))
</pre>
</div>
<p>
If we then pass that to jonathan:to-json, it throws an error because jonathan does not handle alists with dotted pairs. I am only calling this out because jonathan expressly provides you with the ability to return a JSON object as a dotted pair alist, but then cannot handle it going back the other direction.
</p>

<p>
Everyone passes when dealing with the easy array with no nulls involved.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 43:</span> Symmetry Test 1 (Easy) JSON Array</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Pass/Fail</th>
<th scope="col" class="org-left">Resulting String</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">PASS</td>
<td class="org-left">[1,"sales",true]</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1, \"sales\", true]"</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">PASS</td>
<td class="org-left">"[1,\"sales\",true]"</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-symmetry-json-cl-json2" class="outline-4">
<h4 id="symmetry-json-cl-json2">Second Test (Array Inside a JSON Object)</h4>
<div class="outline-text-4" id="text-symmetry-json-cl-json2">
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 44:</span> Symmetry Test 2 JSON Array Within a JSON Object</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Pass/Fail</th>
<th scope="col" class="org-left">Resulting String</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">"{\"items\": [1,2,3]}"</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"items\":[1,2,3]}"</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">FAIL (1)</td>
<td class="org-left">"[​[\"items\",1,2,3]]"</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">PASS</td>
<td class="org-left">{"items":[1,2,3]}</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"items\":[1,2,3]}"</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"items\":[1,2,3]}"</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"items\": [1, 2, 3]}"</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"items\":[1,2,3]}"</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"items\":[1,2,3]}"</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"items\":[1,2,3]}"</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"items\":[1,2,3]}"</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">FAIL</td>
<td class="org-left">"&lt;​&lt;\":ITEMS\",[1,2,3]&gt;&gt;"</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"items\":[1,2,3]}"</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) I was surprised that cl-json failed here by returning a JSON array instead of a JSON object. This is flagged on the homepage as <a href="https://github.com/hankhero/cl-json/issues/22">issue 22</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-symmetry-json-cl-json3" class="outline-4">
<h4 id="symmetry-json-cl-json3">Third test (Trickier Data Types)</h4>
<div class="outline-text-4" id="text-symmetry-json-cl-json3">
<p>
Now we make it a bit trickier with the following JSON string, decoded and then encoded it to see if we got back the original. This has trickier bits because of the unicode, exponent and false and null. The results are pretty much what you would expect.
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="org-string">"{\"key1\":\"value\\n\",\"key2\":1,\"key3\":[\"Hello \\u2604\",1.2e-34 ,true,false,null]}"</span>
</pre>
</div>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 45:</span> Symmetry Test 3</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Pass/Fail</th>
<th scope="col" class="org-left">Resulting String</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">"{\"key1\":\"value\\n\",\"key2\":1, \"key3\":[\"Hello \\u2604\",1.2e-34 ,true,false,null]}"</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">FAIL (3)</td>
<td class="org-left">"{\"key1\":\"value\\n\",\"key2\":1, \"key3\":[\"Hello \\u2604\", 0.00000000000000000000000000000000012000001, true,null,null]}"</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">FAIL (3)</td>
<td class="org-left">"{\"key1\":\"value\\n\",\"key2\":1, \"key3\":[\"Hello \\u2604\",0.00000000000000000000000000000000012000001, true,null,null]}"</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">PASS</td>
<td class="org-left">{"key1":"value\n","key2":1, "key3":["Hello ☄",1.2e-34,true,false,null]}</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">FAIL (3)</td>
<td class="org-left">"{\"key1\":\"value\\n\",\"key2\":1, \"key3\":[\"Hello ☄\", 0.00000000000000000000000000000000012, true,false,null]}"</td>
</tr>

<tr>
<td class="org-left">jonathan (1)</td>
<td class="org-left">FAIL (3)(5)</td>
<td class="org-left">"{\"key3\":[\"Hello ☄\", 0.00000000000000000000000000000000012000001, true,[],[]],\"key2\":1, \"key1\":\"value\\n\"}"</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">FAIL</td>
<td class="org-left">"{\"key1\": \"value\\n\", \"key2\": 1, \"key3\": [\"Hello \", 1.2000001e-34, true, null, null]}"</td>
</tr>

<tr>
<td class="org-left">json-streams (1)</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"key1\":\"value\\n\",\"key2\":1, \"key3\":[\"Hello ☄\",1.2E-34,true,false,null]}"</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">FAIL (3)(5)</td>
<td class="org-left">"{\"key1\":\"value\\n\",\"key2\":1, \"key3\":[\"Hello \\u2604\", 0.00000000000000000000000000000000012, true,[],[]]}"</td>
</tr>

<tr>
<td class="org-left">shasht (1)</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"key1\":\"value\\n\",\"key2\":1, \"key3\":[\"Hello ☄\",1.2e-34,true,false,null]}"</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">PASS</td>
<td class="org-left">"{\"key1\":\"value\\n\",\"key2\":1, \"key3\":[\"Hello \\u2604\",0.12e-33,true,false,null]}"</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">FAIL (4)</td>
<td class="org-left">"&lt;&lt;\":KEY1\",\"value\\n\"&gt;,&lt;\":KEY2\",1&gt;, &lt;\":KEY3\",[\"Hello \\u2604\",1.2000001e-34,true,null,null]&gt;&gt;"</td>
</tr>

<tr>
<td class="org-left">yason (1) (2)</td>
<td class="org-left">PASS? (3)</td>
<td class="org-left">"{\"key1\":\"value\\n\",\"key2\":1, \"key3\":[\"Hello ☄\", 0.00000000000000000000000000000000011999999642058263, true,false,null]}"</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) unicode expanded to the appropriate character which I will treat as a success</li>
<li>(2) You need to pass :json-booleans-as-symbols t to the yason parse function as a keyword argument in order to get false and it will come out as a YASON:FALSE symbol</li>
<li>(3) Exponent expanded to a decimal which I could argue is a success. Your call.</li>
<li>(4) trivial-json-codec is really intended as a parser (one way) from JSON to CL, not really serializing to JSON.</li>
<li>(5) both false and null are converted to [], but they are different concepts.</li>
</ul>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 46:</span> Symmetry Test 3 Points of Failure</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Point(s) of Failure</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">exponent (1), false</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">exponent (1), false</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">exponent (1)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">backwards, exponent (1), false, null</td>
<td class="org-left">unicode expanded to the appropriate character</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">unicode, false</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">unicode expanded to the appropriate character</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">exponent (1), false, null</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">unicode expanded to the appropriate character</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">exponent (1)</td>
<td class="org-left">0.12e-33 v. 1.2e-34 should count as pass</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">exponent (1)</td>
<td class="org-left">unicode expanded to the appropriate character</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) Up to you whether you want to treat the exponent expanded to a decimal as a pass or fail</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-symmetry-cl-json-cl" class="outline-3">
<h3 id="symmetry-cl-json-cl">CL -&gt; JSON -&gt; CL</h3>
<div class="outline-text-3" id="text-symmetry-cl-json-cl">
<p>
We did this testing with a simple alist with undotted pairs. Since this is an alist, cl-json and json use specialized functions :encode-json-alist-to-string to successfully write JSON, then read back a result that is symmetrical to the original alist.
</p>
<div class="org-src-container">
<pre class="src src-lisp">'((<span class="org-builtin">:NAME</span> <span class="org-string">"George Washington"</span>)
  (<span class="org-builtin">:BIRTHDAY</span> <span class="org-string">"February 22, 1732"</span>)
  (<span class="org-builtin">:ADDRESS</span> <span class="org-string">"Mount Vernon, Virginia, United States"</span>))
</pre>
</div>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 47:</span> Symmetry CL -&gt; JSON -&gt; CL Test 1 starting with undotted alist</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Pass/Fail</th>
<th scope="col" class="org-left">Resulting String</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">((:NAME "George Washington") (:BIRTHDAY "February 22, 1732") (:ADDRESS "Mount Vernon, Virginia, United States"))</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">FAIL</td>
<td class="org-left">Error: Unexpected #\N</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">PASS</td>
<td class="org-left">((:NAME "George Washington") (:BIRTHDAY "February 22, 1732") (:ADDRESS "Mount Vernon, Virginia, United States"))</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">FAIL</td>
<td class="org-left">(("address" . #("Mount Vernon, Virginia, United States")) ("birthday" . #("February 22, 1732")) ("name" . #("George Washington")))</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">PASS (3)</td>
<td class="org-left">((:NAME "George Washington") (:BIRTHDAY "February 22, 1732") (:ADDRESS "Mount Vernon, Virginia, United States"))</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">FAIL</td>
<td class="org-left">#(#("name" "George Washington") #("birthday" "February 22, 1732")  #("address" "Mount Vernon, Virginia, United States"))</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">FAIL</td>
<td class="org-left">(4)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">FAIL</td>
<td class="org-left">(("NAME" "George Washington") ("BIRTHDAY" "February 22, 1732") ("ADDRESS" "Mount Vernon, Virginia, United States"))</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">FAIL</td>
<td class="org-left">#(#("NAME" "George Washington") #("BIRTHDAY" "February 22, 1732")  #("ADDRESS" "Mount Vernon, Virginia, United States"))</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">FAIL</td>
<td class="org-left">Depends on how you write a method for handling symbols. See <a href="#st-json-encoding">st-json-encoding</a></td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">PASS</td>
<td class="org-left">((:NAME "George Washington") (:BIRTHDAY "February 22, 1732") (:ADDRESS "Mount Vernon, Virginia, United States"))</td>
</tr>

<tr>
<td class="org-left">yason (2)</td>
<td class="org-left">FAIL</td>
<td class="org-left">(("address" "Mount Vernon, Virginia, United States") ("birthday" "February 22, 1732") ("name" "George Washington"))</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) com.inuoe.jzon and yason return hashtables, so alexandria:hash-tables-alist was used to get an alist back.</li>
<li>(2) (yason:parse (with-output-to-string (s) (yason:encode-alist data s)) :object-as  :alist)</li>
<li>(3) Caveat here if we tried to do this with respect to alists having dotted pairs. In that case jonathan would also fail.</li>
<li>(4) You could write your own methods to wrap lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</li>
</ul>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 48:</span> Symmetry CL -&gt; JSON -&gt; CL Test 1 Points of Failure</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Point(s) of Failure</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">Unexpected #\N</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">???</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">keys are strings, not keywords, values are embedded in vectors</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">result is vectors in vectors with the keys being strings, not keywords</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">You would need to use lower level components of json-streams. See <a href="#json-streams-encoding">json-streams-encoding</a>.</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">keys are strings, not keywords</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">result is vectors in vectors with the keys being strings, not keywords</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">You need to write your own method for handling symbols.</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">keys are strings, not keywords</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) As noted when going from JSON -&gt; CL -&gt; JSON, jonathan is not symmetric if the alists have dotted pairs.</li>
</ul>

<p>
Now let's try starting from an array which also contains a :NULL keyword symbol as a substitute for cl not having a proper null value.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 49:</span> Symmetry CL -&gt; JSON -&gt; CL Test 2 Starting with array</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Pass/Fail</th>
<th scope="col" class="org-left">Resulting String</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Original</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">#("a" 1 4.2 NIL :NULL)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">boost-json</td>
<td class="org-left">FAIL</td>
<td class="org-left">[,1,4.2,null,"NULL"]</td>
</tr>

<tr>
<td class="org-left">cl-json DEFAULT</td>
<td class="org-left">FAIL</td>
<td class="org-left">( "a" 1 4.2 NIL "null")</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">PASS (1)(2)</td>
<td class="org-left">#("a" 1 4.2 NIL "null")</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">FAIL</td>
<td class="org-left">["a",1,4.199999809265137,{},null]</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">PASS (2)</td>
<td class="org-left">#("a" 1 4.2d0 NIL "NULL")</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">FAIL</td>
<td class="org-left">(a 1 4.2 NIL NIL)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">PASS (2)</td>
<td class="org-left">#(a 1 4.2 NIL "null")</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">FAIL</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">FAIL</td>
<td class="org-left">(a 1 21/5 NIL NIL)</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">PASS (3)</td>
<td class="org-left">#("a" 1 4.2000003 NIL :NULL)</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">FAIL</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">PASS</td>
<td class="org-left">#(a 1 4.2 NIL NULL)</td>
</tr>

<tr>
<td class="org-left">yason  (4)</td>
<td class="org-left">FAIL</td>
<td class="org-left">#("a" 1 4.2 NIL NIL)</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) Needs to use cl-json:with-decoder-simple-clos-semantics or cl-json:simple-clos-semantics</li>
<li>(2) Pass assuming you deal with the "NULL" or 'null" string somehow to get back to :NULL</li>
<li>(3) Pass assuming the float result is acceptable to you</li>
<li>(4) Assumes yason:parse has keyword parameter :json-arrays-as-vectors set to t</li>
</ul>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 50:</span> Symmetry CL -&gt; JSON -&gt; CL Test 2 Points of Failure</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Point(s) of Failure</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">lost the first value, nil came back as null</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">need to parse the result and convert "null" to :NULL</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">{} braces instead of () or nil</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">need to parse the result and convert "NULL" to :NULL</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">result is a list and it converts :NULL to nil</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">need to parse the result and convert "null" to :NULL</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">You would need to write your own method wrapping components of json-streams to handle a vector</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">returns list instead of array and :NULL is converted to nil. Interesting that the float is converted to a ratio.</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">You need to write your own method for handling vectors</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">Null converted to nil</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-security" class="outline-2">
<h2 id="security">Security</h2>
<div class="outline-text-2" id="text-security">
<p>
Getting JSON objects from another source is just as insecure as any other data you receive from another source. You are still responsible for ensuring that you have properly sanitized, validated or other checked the security of the data.
</p>

<p>
Redditor lokedhs has pointed out that "I'd be careful about using any JSON library that uses keywords for hash keys (like CL-JSON). The reason is that if you are using it to parse unchecked input, it can be used to cause a denial of service attack by sending maps that contain random keys. Every key will be interned into the keyword package, which are never garbage collected, causing an out of memory condition after a while." Cl-json flags the issue and provides the function safe-json-intern - which will throw an error if the keyword to be interned does not already exist in the *json-symbols-package*. - so at least you are warned and provided with an alternative. The following code will throw an error if alpha-omega is not already interned in the *json-symbols-package*.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf cl-json::*identifier-name-to-key* #'cl-json::safe-json-intern)
(cl-json:decode-json-from-string <span class="org-string">"{\"alpha-omega\": 1}"</span>)
</pre>
</div>

<p>
Boost-json and Jonathan also seem to have this as a potential issue. Boost-json decodes JSON objects to a CLOS object with slot-value names interned in the boost-json package.
</p>

<p>
com.gigamonkeys.json, com.inuoe.jzon, json, json-lib, json-streams, jsown, shasht and st-json do not intern the keywords. Yason doesn't intern the keywords in the library but the test files do, giving you the impression that it assumes that will be normal practice.
</p>

<p>
You will see in the next section when it talks about malformed data that certain strings can also hang the system or exhaust the stack (typically by opening thousands of JSON arrays or objects and never closing them). Com.inuoe.jzon, json-lib, json-streams and shasht have maximum level limits that can be used to prevent this type of overloading from happening.
</p>
</div>
</div>

<div id="outline-container-standard-conformity" class="outline-2">
<h2 id="standard-conformity">Standard Conformity and Dealing with Malformed Data</h2>
<div class="outline-text-2" id="text-standard-conformity">
<p>
To check standard conformity and test for malformed data, we will take advantage of some of the test suites that have come out for JSON. Some can be found at, specifically <a href="https://github.com/nst/JSONTestSuite">https://github.com/nst/JSONTestSuite</a>. You may also find interesting reading at <a href="https://yitzchak.github.io/shasht/parsing.html#17">https://yitzchak.github.io/shasht/parsing.html#17</a>
and <a href="http://www.seriot.ch/parsing_json.php">http://www.seriot.ch/parsing_json.php</a>.
</p>

<p>
One thing to take into consideration, bearing in mind your own fact pattern is whether you agree or disagree with Jon Postel's robustness principle:
</p>
<blockquote>
<p>
"Be strict when sending and tolerant when receiving. Implementations must follow specifications precisely when sending to the network, and tolerate faulty input from the network.  When in doubt, discard faulty input silently, without returning an error message unless this is required by the specification."
</p>
</blockquote>
<p>
If you follow this logic, your encoding function should be perfectly compliant and your decoding function may want to accept invalid JSON (subject to security concerns). According to <a href="https://datatracker.ietf.org/doc/html/draft-thomson-postel-was-wrong-03">https://datatracker.ietf.org/doc/html/draft-thomson-postel-was-wrong-03</a>,the robustness principle should be read in the context of dealing with imperfect protocols, not everything under the sun including implementation bugs.
</p>
</div>

<div id="outline-container-conformity-testing" class="outline-3">
<h3 id="conformity-testing">Conformity Testing</h3>
<div class="outline-text-3" id="text-conformity-testing">
<p>
While JSON has a standard, it is arguably under-specified. Using the tests from <a href="https://github.com/nst/JSONTestSuite">https://github.com/nst/JSONTestSuite</a>, I intended to focus on whether the libraries correctly parsed JSON strings that must be accepted and whether they throw errors on JSON strings that must be rejected. However, as you will see, how the libraries handle the "must reject" strings and "under-specified" strings also implicate security and stability. Some libraries' attempts to handle intentionally malformed JSON strings actually hung SBCL or triggered stack exhaustion. These are not the libraries you want facing uncontrolled input.
</p>
</div>

<div id="outline-container-must-accept" class="outline-4">
<h4 id="must-accept">Must Accept</h4>
<div class="outline-text-4" id="text-must-accept">
<p>
This batch of JSON strings whould be accepted by all libraries. The only libraries to meet that standard are com.inuoe.jzon and com.gigamonkeys.json. Almost all the rest came "reasonably" close.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 51:</span> Conformity Testing - Must Accept</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Correct</th>
<th scope="col" class="org-right">Incorrect</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">95/(92)</td>
<td class="org-right">0</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">95/(92)</td>
<td class="org-right">0</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">gigamonkeys</td>
<td class="org-left">95</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">95</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">94</td>
<td class="org-right">1</td>
<td class="org-left">(2)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">95/(92)</td>
<td class="org-right">0</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">93</td>
<td class="org-right">2</td>
<td class="org-left">(3)</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">93</td>
<td class="org-right">2</td>
<td class="org-left">(4)</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">95/(92)</td>
<td class="org-right">0</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">95/(92)</td>
<td class="org-right">0</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-left">90/(87)</td>
<td class="org-right">5</td>
<td class="org-left">(1)(5)</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">95/(92)</td>
<td class="org-right">0</td>
<td class="org-left">(1)</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) If *read-default-float-format* is set to 'single-float, there will be decoding failures on [123e65], [123e45], [123.456e78],</li>
<li>(2) Failed on [123.456e78] even with *read-default-float-format* is set to 'double-float</li>
<li>(3) rejected files with duplicate keys. This can be resolved by passing the keyword parameter :duplicate-key-check nil</li>
<li>(4) Failed on lonely numbers (an integer or negative real not within a JSON array or JSON object)</li>
<li>(5) Failed on [[]   ], [0e+1], [1E+2], [1e+2], { "min": -1.0e+28, "max": 1.0e+28 }</li>
</ul>
</div>
</div>

<div id="outline-container-can-accept" class="outline-4">
<h4 id="can-accept">Can Accept or Reject</h4>
<div class="outline-text-4" id="text-can-accept">
<p>
This batch of JSON strings were designed to find the under-specified holes in the JSON specification. As such, libraries could accept or reject the strings without being out of compliance with the standard. For purposes of the following table, I only tested files that could be read as encoded in utf-8.
</p>

<p>
What I found troubling was that jonathan and jsown all hung on one or more of these strings.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 52:</span> Conformity Testing - Can Accept or Reject</caption>

<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-right">Accepted</th>
<th scope="col" class="org-right">Rejected</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-right">13</td>
<td class="org-right">4</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-right">13</td>
<td class="org-right">4</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">gigamonkeys</td>
<td class="org-right">14</td>
<td class="org-right">3</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-right">7</td>
<td class="org-right">10</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-right">9</td>
<td class="org-right">7</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-right">12</td>
<td class="org-right">5</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-right">1</td>
<td class="org-right">16</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-right">11</td>
<td class="org-right">5</td>
<td class="org-left">(1)</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-right">9</td>
<td class="org-right">8</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-right">8</td>
<td class="org-right">9</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-right">13</td>
<td class="org-right">4</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-right">8</td>
<td class="org-right">9</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) hang on i_number_real_underflow [123e-10000000]</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-malformed-data" class="outline-3">
<h3 id="malformed-data">Malformed Data</h3>
<div class="outline-text-3" id="text-malformed-data">
</div>
<div id="outline-container-malformed-data-must-reject" class="outline-5">
<h5 id="malformed-data-must-reject">Must Reject</h5>
<div class="outline-text-5" id="text-malformed-data-must-reject">
<p>
Only three libraries did not hang or trigger stack exhaustion on strings designed to open thousands of beginning nested arrays or objects. Those are com.inuoe.jzon, json-lib and json-streams. All three have a limit and refused to exceed the limit.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 53:</span> Malformed Data Testing - Must Reject</caption>

<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-right">Correct</th>
<th scope="col" class="org-right">Incorrect</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-right">145</td>
<td class="org-right">28</td>
<td class="org-left">stack exhausted (1)</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-right">153</td>
<td class="org-right">20</td>
<td class="org-left">stack exhausted (1)</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-right">0</td>
<td class="org-right">173</td>
<td class="org-left">stack exhausted (1)</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-right">173</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-right">128</td>
<td class="org-right">45</td>
<td class="org-left">stack exhausted (1)</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-right">110</td>
<td class="org-right">63</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-right">173</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-right">102</td>
<td class="org-right">71</td>
<td class="org-left">stack exhausted (1)</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-right">159</td>
<td class="org-right">18</td>
<td class="org-left">recoverable error (2)</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-right">140</td>
<td class="org-right">33</td>
<td class="org-left">stack exhausted (1)</td>
</tr>

<tr>
<td class="org-left">trivial-json-codec</td>
<td class="org-right">101</td>
<td class="org-right">72</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-right">119</td>
<td class="org-right">54</td>
<td class="org-left">stack exhausted (1)</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>(1) n_structure_open_array_object.json, n_structure_100000_opening_arrays.json</li>
<li>(2) n_structure_open_array_object.json</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-benchmarking" class="outline-2">
<h2 id="benchmarking">Benchmarking</h2>
<div class="outline-text-2" id="text-benchmarking">
</div>
<div id="outline-container-read-times" class="outline-3">
<h3 id="read-times">Read Times</h3>
<div class="outline-text-3" id="text-read-times">
<p>
Ok. We are going to show read benchmarking results using SBCL, CCL and ECL because the changes in the results for jonathan were so different. Some other libraries also showed some interesting differences with shasht actually taking the speed lead on larger files when using ECL.
</p>

<p>
Jsown maintains its crown as the fastest parser <b>on SBCL</b> (assuming no errors in the file). It is beaten slightly by jonathan on tiny strings, but jonathan shows a slow-down with certain nested JSON objects that gets progressively worse as string sizes increase. This effect is more immediate under SBCL where it starts slowing down &lt; 12.7k data. The effect is obvious even under CCL and ECL by the time you get to 227k JSON data objects and by the time you get over 1MB JSON data objects, jonathan is orders of magnitude slower than all other libraries, not just jsown.
</p>

<p>
If we take a quick look at benchmarking with <b>tiny</b> JSON strings, we get read time chart comparisons that look like the following. The numbers come from applying the cost-of-nothing benchmark function against the libraries parsing the JSON string immediately below and using cl-spark's vspark function.
</p>

<p>
yason-alist and yason-plist are shorthand for (yason:parse data :object-as :alist) and (yason:parse data :object-as :plist)
</p>
<div class="org-src-container">
<pre class="src src-javascript">(defparameter +json-string+ <span class="org-string">"{\"key1\": \"value\\n\",</span>
<span class="org-string">\"key2\":1,\"key3\":[\"Hello \\u2604\",  1.2e-34 ,true,</span>
<span class="org-string">  false,null]}"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ascii">                                  JSON Read Times (SBCL 2.3.2 tiny JSON object)
                     0                 5.8130204e-6                 1.1626041e-5
                     ˫----------------------------+----------------------------˧
          boost-json ████████████████████████▎
             cl-json ████████████████████████████████▊
com.gigamonkeys.json ███████████████████████▋
            jonathan ███████▍
      com.inuoe.jzon ███████▌
            json-lib ███████████████████████████████▍
        json-streams ███████████████████████████████████████████████████████████
               jsown ███████▉
              shasht ███████████▉
             st-json ██████████████████████████████▊
               yason █████████████████████████████████████▋


                                JSON Read Times (CCL 1.12.1 tiny JSON object)
                       0                 3.1699197E-5                 6.3398395E-5
                     ˫----------------------------+----------------------------˧
          boost-json ███████████████▏
             cl-json ██████████████████▎
com.gigamonkeys.json █████████████████▍
            jonathan ███▏
      com.inuoe.jzon ██████▊
            json-lib ██████████████████████████████████████████████████████████
        json-streams ██████████████████████████████████████████▎
               jsown █████▎
              shasht ██████████▎
             st-json ████████████████▌
               yason ██████████████████▌

                                JSON Read Times (ECL 21.2.1 tiny JSON object)
                     0                 1.7382258e-4                 3.4764517e-4
                     ˫----------------------------+----------------------------˧
          boost-json █████████████▎
             cl-json ████████▎
com.gigamonkeys.json ████▊
            jonathan ████▏
      com.inuoe.jzon ██████▍
            json-lib ██████████████████████▎
        json-streams ███████████████████████████████████▊
               jsown ███████████████████████████████████████████████████████████
              shasht █████▌
             st-json ████▉
               yason ███████▍


</pre>
</div>
<p>
The read times start to look different with respect to nested JSON objects as the file sizes increase. The next chart is a 2.7k JSON nested object. With SBCL, jonathan is slightly behind JSON, but still looking good compared to the rest of the libraries. The JSON dataset for charts between 2.7k and 221k are all from a Nobel prize dataset which can be found at <a href="http://api.nobelprize.org/v1/prize.json">http://api.nobelprize.org/v1/prize.json</a>. The 2.7k data is just 2021. The 12.9k data is 2017-2021 and the 221k data are all years. We are dropping trivial-json-codec out at this point because it claims the data is invalid.
</p>
<div class="org-src-container">
<pre class="src src-ascii">                                  JSON Read Times (SBCL 2.3.2 2.7k JSON object)
                     0                 1.2616655e-4                  2.523331e-4
                     ˫----------------------------+----------------------------˧
          boost-json ███████████▍
             cl-json █████████████████████████████▋
com.gigamonkeys.json █████████████████▎
            jonathan █████▌
      com.inuoe.jzon █████████▌
            json-lib ████████████████████████████████████▋
        json-streams ███████████████████████████████████████████████████████████
               jsown ███▌
              shasht █████████████▍
             st-json ████████████▍
               yason ███████████████████████████████████████████▋



                                JSON Read Times (CCL 1.12.1 2.7k JSON object)
                     0                 4.6838302E-4                 9.3676604E-4
                     ˫----------------------------+----------------------------˧
          boost-json █████████████▋
             cl-json ████████████████████████████▏
com.gigamonkeys.json █████████████████▍
            jonathan ███▍
      com.inuoe.jzon █████████▊
            json-lib █████████████████████████████████████████████████████████▌
        json-streams ███████████████████████████████████████████████████████████
               jsown ███████▍
              shasht ███████▉
             st-json ████████████▋
               yason ███████████████████████████▎



                                JSON Read Times (ECL 21.2.1 2.7k JSON object)
                     0                  0.010292258                  0.020584516
                     ˫----------------------------+----------------------------˧
          boost-json █▌
             cl-json ███▌
com.gigamonkeys.json ███▉
            jonathan █▎
      com.inuoe.jzon █▉
            json-lib █████▋
        json-streams ███████████████████████████████████████████████████████████
               jsown ██▊
              shasht █▎
             st-json ████████▋
               yason ███████████▊


</pre>
</div>
<p>
Now we increase the size to a 12.9k JSON nested object. Using SBCL, jsown is by itself and jonathan has fallen behind four other libraries. On the other hand, jonathan is still faster with CCL and ECL.
</p>
<div class="org-src-container">
<pre class="src src-ascii">                                JSON Read Times (SBCL 2.3.2 12.9k JSON object)
                     0                 6.1594247e-4                 0.0012318849
                     ˫----------------------------+----------------------------˧
          boost-json ███████████▍
             cl-json █████████████████████████████▊
com.gigamonkeys.json ████████████████▉
            jonathan █████████████████▉
      com.inuoe.jzon █████████▍
            json-lib ███████████████████████████████████▉
        json-streams ███████████████████████████████████████████████████████████
               jsown ███▌
              shasht █████████████▏
             st-json ████████████▏
               yason ██████████████████████████████████████████▋



                                JSON Read Times (CCL 1.12.1  12.9k JSON object)
                     0                  0.0022662715                 0.004532543
                     ˫----------------------------+----------------------------˧
          boost-json █████████████▋
             cl-json ████████████████████████████▍
com.gigamonkeys.json ████████████████▉
            jonathan ██████▌
      com.inuoe.jzon █████████▋
            json-lib █████████████████████████████████████████████████████████▉
        json-streams ███████████████████████████████████████████████████████████
               jsown ███████▏
              shasht ████████▎
             st-json ████████████▉
               yason ███████████████████████████▌



                                JSON Read Times (ECL 21.2.1 12.9k JSON object)
                     0                  0.018946955                   0.03789391
                     ˫----------------------------+----------------------------˧
          boost-json █████▎
             cl-json ████████████▍
com.gigamonkeys.json █████▋
            jonathan █████▍
      com.inuoe.jzon █████▋
            json-lib ████████████████████████▊
        json-streams ███████████████████████████████████████████████████████████
               jsown ███████▊
              shasht ████████▏
             st-json █████▎
               yason ████████▍

</pre>
</div>
<p>
Now we jump up to the 221k JSON object and jonathan is really falling behind with SBCL and suddenly starts struggling under CCL and ECL for unknown reasons.
</p>
<div class="org-src-container">
<pre class="src src-ascii">                                JSON Read Times (SBCL 2.3.2 221k JSON object)
                     0                  0.030821392                  0.061642785
                     ˫----------------------------+----------------------------˧
          boost-json ███▊
             cl-json █████████▊
com.gigamonkeys.json █████▉
            jonathan ██████████████████████████████████████████████████████████
      com.inuoe.jzon ███▎
            json-lib ████████████▍
        json-streams ███████████████████▋
               jsown █▎
              shasht ████▌
             st-json ████▏
               yason ██████████████▋


                               JSON Read Times (CCL 1.12.1  221k JSON object)
                     0                     0.0410785                    0.082157
                     ˫----------------------------+----------------------------˧
          boost-json ████████████▉
             cl-json ██████████████████████████▏
com.gigamonkeys.json ██████████████████████▎
            jonathan █████████████████████████████████████████████████████▉
      com.inuoe.jzon ██████████████▊
            json-lib ███████████████████████████████████████████████████████████
        json-streams █████████████████████████████████████████████████████▋
               jsown ███████▍
              shasht ███████████████████████▉
             st-json ████████████▏
               yason ████████████████████████████████▉



                               JSON Read Times ECL 21.2.1 221k JSON object
                     0                   0.17499994                   0.34999987
                     ˫----------------------------+----------------------------˧
          boost-json ██████████▎
             cl-json █████████████▎
com.gigamonkeys.json █████████▉
            jonathan ██████████████████████████████████████████▏
      com.inuoe.jzon █████████▎
            json-lib ███████████████████▊
        json-streams ███████████████████████████████████████████████████████████
               jsown ██████████████████████████▏
              shasht ████▉
             st-json █████▉
               yason ███████████████████████████▌

</pre>
</div>
<p>
Switching to trivial-benchmarking numbers and just taking the cumulative timing and consing for 20 runs of these three JSON strings and just comparing jonathan v. com.inuoe.jzon. Obviously the first thing that jumps out is the garbage collection while jonathan parses the 221k JSON string. Look at the relative increase. The largest string is 8162% larger than the smallest, but jonathan's run time increases by 100000% and the bytes consed increases by 576000%. At the same time com.inuoe.jzon's increases slightly less than the increase in string size.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 54:</span> Jonathan Parsing (SBCL)</caption>

<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">Relative Increase</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">File Size (Bytes)</td>
<td class="org-right">2715</td>
<td class="org-right">12961</td>
<td class="org-right">221618</td>
<td class="org-right">8162%</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">Total (sec)</td>
<td class="org-right">Total (sec)</td>
<td class="org-right">Total (sec)</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">RUN-TIME</td>
<td class="org-right">0.000993</td>
<td class="org-right">0.008474</td>
<td class="org-right">1.261165</td>
<td class="org-right">127005%</td>
</tr>

<tr>
<td class="org-left">USER-RUN-TIME</td>
<td class="org-right">0.000970</td>
<td class="org-right">0.008460</td>
<td class="org-right">1.184836</td>
<td class="org-right">122251%</td>
</tr>

<tr>
<td class="org-left">SYSTEM-RUN-TIME</td>
<td class="org-right">0.000004</td>
<td class="org-right">0.000023</td>
<td class="org-right">0.076502</td>
<td class="org-right">1912550%</td>
</tr>

<tr>
<td class="org-left">GC-RUN-TIME</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">155.651</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">BYTES-CONSED</td>
<td class="org-right">1811312</td>
<td class="org-right">37779888</td>
<td class="org-right">10098760112</td>
<td class="org-right">557538%</td>
</tr>
</tbody>
</table>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 55:</span> Com.inuoe.jzon Parsing (SBCL)</caption>

<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">Relative Increase</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">File Size (Bytes)</td>
<td class="org-right">2715</td>
<td class="org-right">12961</td>
<td class="org-right">221618</td>
<td class="org-right">8162%</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">Total (sec)</td>
<td class="org-right">Total (sec)</td>
<td class="org-right">Total (sec)</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">RUN-TIME</td>
<td class="org-right">0.001822</td>
<td class="org-right">0.004031</td>
<td class="org-right">0.071345</td>
<td class="org-right">3915%</td>
</tr>

<tr>
<td class="org-left">USER-RUN-TIME</td>
<td class="org-right">0.001822</td>
<td class="org-right">0.004031</td>
<td class="org-right">0.071326</td>
<td class="org-right">3915%</td>
</tr>

<tr>
<td class="org-left">SYSTEM-RUN-TIME</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">GC-RUN-TIME</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">BYTES-CONSED</td>
<td class="org-right">426640</td>
<td class="org-right">1839472</td>
<td class="org-right">30431056</td>
<td class="org-right">4311%</td>
</tr>
</tbody>
</table>

<p>
Now looking at parsing a 1.2 MB JSON string with nested objects, jonathan is orders of magnitude slower than all the other libraries regardless of which compiler is used. The JSON dataset can be found at <a href="https://github.com/mledoze/countries/blob/master/countries.json">https://github.com/mledoze/countries/blob/master/countries.json</a>.
</p>
<div class="org-src-container">
<pre class="src src-ascii">                                JSON Read Times (SBCL 2.3.2 1.2MB JSON object)
                     0                    1.0532565                     2.106513
                     ˫----------------------------+----------------------------˧
          boost-json ▌
             cl-json █▏
com.gigamonkeys.json ▊
            jonathan ██████████████████████████████████████████████████████████
      com.inuoe.jzon ▍
            json-lib █▋
        json-streams ██▌
               jsown ▍
              shasht ▋
             st-json ▊
               yason █▌

CCL results not included since CCL had an issue with some of the unicode in the file.

                                JSON Read Times (ECL ECL 21.2.1  1.2MB JSON object)
                     0                          3.5                          7.0
                     ˫----------------------------+----------------------------˧
          boost-json █▍
             cl-json █▉
com.gigamonkeys.json █▉
            jonathan ███████████████████████████████████████████████████████████
      com.inuoe.jzon █████▏
            json-lib ████▎
        json-streams ████████▍
               jsown █▉
              shasht █▌
             st-json █▍
               yason █▉


</pre>
</div>
<p>
If we drop jonathan and look at the remaining libraries, it looks like this:
</p>
<div class="org-src-container">
<pre class="src src-ascii">                                JSON Read Times
                     0                  0.045177087                  0.090354174
                     ˫----------------------------+----------------------------˧
          boost-json ██████████▎
             cl-json ███████████████████████████▍
com.gigamonkeys.json ██████████████████▍
      com.inuoe.jzon ████████▌
            json-lib █████████████████████████████████████▌
        json-streams ███████████████████████████████████████████████████████████
               jsown ███████▍
              shasht █████████████▍
             st-json █████████████████▎
               yason ███████████████████████████████████▎

                                JSON Read Times (ECL 21.2.1  1.2MB JSON object)
                       0                   0.49999994                    0.9999999
                     ˫----------------------------+----------------------------˧
          boost-json ██████████▋
             cl-json ████████████████████▋
com.gigamonkeys.json ████████████████▊
      com.inuoe.jzon ████████████████████████████████▌
            json-lib ███████████████████████▋
        json-streams ███████████████████████████████████████████████████████████
               jsown ███████████████████▋
              shasht █████████▋
             st-json █████████▏
               yason █████████████▎


</pre>
</div>
<p>
Moving up to a 9.8 MB file (still on the small side) downloaded from <a href="https://www.vizgr.org/historical-events/search.php?format=json&amp;begin_date=-3000000&amp;end_date=20151231&amp;lang=en">https://www.vizgr.org/historical-events/search.php?format=json&amp;begin_date=-3000000&amp;end_date=20151231&amp;lang=en</a>,  Yason's standard parsing into a hash complained that there was a duplicate key in the data, so we are using yason's parsing into an alist instead.
</p>

<p>
<b>With Jonathan</b>
</p>
<div class="org-src-container">
<pre class="src src-ascii">                                  JSON Read Times (SBCL 2.3.2 9.8 MB JSON object)
                     0                    8.069131                     16.138262
                     ˫----------------------------+----------------------------˧
          boost-json ▋
             cl-json █▋
com.gigamonkeys.json █▎
            jonathan ███████████████████████████████████████████████████████████
      com.inuoe.jzon ▍
            json-lib ██▎
        json-streams ███▏
               jsown ▎
              shasht ▋
             st-json ▋
         yason-alist ██▌


                                JSON Read Times (CCL 1.12.1 9.8 MB Json Object)
                     0                     10.630925                    21.26185
                     ˫----------------------------+----------------------------˧
          boost-json ██▎
             cl-json ███▊
com.gigamonkeys.json ███▍
            jonathan ███████████████████████████████████████████████████████████
      com.inuoe.jzon ▉
            json-lib ███████████▎
        json-streams ████████▏
               jsown █▍
              shasht █▏
             st-json ██▏



                                JSON Read Times (ECL 21.2.1 9.8 MB Json Object)
                     0                         19.5                         39.0
                     ˫----------------------------+----------------------------˧
          boost-json █▌
             cl-json ███▏
com.gigamonkeys.json ██▎
            jonathan ███████████████████████████████████████████████████████████
      com.inuoe.jzon █▌
            json-lib ██████▏
        json-streams ████████████▏
               jsown ███▏
              shasht █▌
             st-json █▌
         yason-alist ███▏

</pre>
</div>
<p>
<b>Without Jonathan</b>
</p>
<div class="org-src-container">
<pre class="src src-ascii">                                JSON Read Times (SBCL 2.3.2 9.8 MB JSON object)
                     0                    0.4027305                     0.805461
                     ˫----------------------------+----------------------------˧
          boost-json ████████████▋
             cl-json ████████████████████████████████▍
com.gigamonkeys.json ███████████████████████▎
      com.inuoe.jzon █████▉
            json-lib ████████████████████████████████████████████▊
        json-streams ███████████████████████████████████████████████████████████
               jsown ████▍
              shasht █████████████▏
             st-json ████████████▊
         yason-alist ███████████████████████████████████████████████████▋


                                JSON Read Times (CCL 9.8MB JSON object)
                     0                     2.043566                     4.087132
                     ˫----------------------------+----------------------------˧
          boost-json ███████████▊
             cl-json ███████████████████▉
com.gigamonkeys.json ████████████████▉
      com.inuoe.jzon █████▏
            json-lib ███████████████████████████████████████████████████████████
        json-streams ██████████████████████████████████████████▉
               jsown ██████▉
              shasht █████▍
             st-json ██████████▉
         yason-alist █████████████████████████▋


                                JSON Read Times (ECL 9.8 MB JSON object)
                     0                          4.5                          9.0
                     ˫----------------------------+----------------------------˧
          boost-json ██████▌
             cl-json █████████████▏
com.gigamonkeys.json █████████████▏
      com.inuoe.jzon ██████▌
            json-lib ███████████████████▋
        json-streams ███████████████████████████████████████████████████████████
               jsown █████████████▏
              shasht █████▊
             st-json ██████▌
         yason-alist █████████████▏


</pre>
</div>
</div>

<div id="outline-container-benchmarking-read-stream" class="outline-4">
<h4 id="benchmarking-read-stream">Read Times From Stream (SBCL)</h4>
<div class="outline-text-4" id="text-benchmarking-read-stream">
<p>
The following charts are reading from stream rather than from string (so a slightly smaller list of libraries) and jonathan choked on both files being read into the stream, so it is excluded as well. We see the same comparative results when reading from stream as when we read from strings.
</p>
</div>
<div id="outline-container-benchmarking-read-stream-countries" class="outline-5">
<h5 id="benchmarking-read-stream-countries">Countries File</h5>
<div class="outline-text-5" id="text-benchmarking-read-stream-countries">
<div class="org-src-container">
<pre class="src src-ascii">
                                JSON Read Times (SBCL) 1.2 MB Countries File
               0                      0.04425004                      0.08850008
               ˫-------------------------------+-------------------------------˧
    boost-json ██████████▋
       cl-json ████████████████████████████▌
com.inuoe.jzon ████████████████▉
  json-streams █████████████████████████████████████████████████████████████████
        shasht █████████████▋
       st-json ████████████████▎
         yason ████████████████████████████████▏
   yason-alist ██████████████████████████████
   yason-plist ███████████████████████████████▏

</pre>
</div>
</div>
</div>

<div id="outline-container-benchmarking-read-stream-historical-events" class="outline-5">
<h5 id="benchmarking-read-stream-historical-events">Historical Events File</h5>
<div class="outline-text-5" id="text-benchmarking-read-stream-historical-events">
<div class="org-src-container">
<pre class="src src-ascii">                      JSON Read Times (SBCL) 9.8 MB Historical Events File
               0                      0.39376867                      0.78753734
               ˫-------------------------------+-------------------------------˧
    boost-json ████████████▋
       cl-json ██████████████████████████████████▌
com.inuoe.jzon █████████████████▉
  json-streams █████████████████████████████████████████████████████████████████
        shasht █████████████▏
       st-json █████████████▎
   yason-alist ██████████████████████████████████████████▏

</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-write-times" class="outline-3">
<h3 id="write-times">Write Times</h3>
<div class="outline-text-3" id="text-write-times">
<p>
Unlike the read times with Jonathan, writing times did not show any surprising differences between tiny bits of data and longer nested data. First writing tiny bits of data. We are skipping trivial-json-codec because of its inability to deliver valid JSON from lists and gigamonkeys had some difficulties with some of the data as well, so it was dropped. The data used is the same data as the reading benchmarks, but encoded by yason. Due to time constraints, I did not run the write times benchmarks for CCL and ECL.
</p>
<div class="org-src-container">
<pre class="src src-ascii">                             JSON Write Times (SBCL trivial sized list)
               0                    5.3087347e-6                    1.0617469e-5
               ˫-------------------------------+-------------------------------˧
    boost-json █████████████████████████████████████████████████████████████████
       cl-json ███████████████████████████████████████▍
com.inuoe.jzon ████████████▊
      json-lib ████████████████████████████████████████████████▊
      jonathan ██████████████████████████████████████████████████████▌
         jsown ███████████████████████████████████████████████▏
        shasht █████████████████▌
       st-json █████████████████████████████▍
         yason ██████████████████████████████████████▊

</pre>
</div>
<p>
Now the lisp data equivalent to the JSON 2.7k data string:
</p>
<div class="org-src-container">
<pre class="src src-ascii">                                JSON Write Times 2.7k data (SBCL)
               0                    1.1911893e-4                    2.3823786e-4
               ˫-------------------------------+-------------------------------˧
    boost-json █████████████████████████████████████████████████████████████████
       cl-json ███████████████████▍
com.inuoe.jzon ██████████▌
      json-lib ███████████████████████████████████▉
      jonathan ██████████▌
         jsown ████████████████████████████▌
        shasht ███████████▎
       st-json ████████▉
         yason ██████████████████████▏

</pre>
</div>
<p>
Now the lisp data equivalent to the JSON 12.9k data string
</p>
<div class="org-src-container">
<pre class="src src-ascii">                                JSON Write Times 12.9k data (SBCL)
               0                    5.9223245e-4                    0.0011844649
               ˫-------------------------------+-------------------------------˧
    boost-json █████████████████████████████████████████████████████████████████
       cl-json ██████████████████▉
com.inuoe.jzon ██████████▎
      json-lib ██████████████████████████████████▊
      jonathan ██████████▌
         jsown ███████████████████████████▍
        shasht ██████████▊
       st-json ████████▌
         yason █████████████████████▏

</pre>
</div>
<p>
Now the lisp data equivalent to a JSON 221.6k data string
</p>
<div class="org-src-container">
<pre class="src src-ascii">                          JSON Write Times 221.6k data (SBCL)
               0                     0.014435494                     0.028870989
               ˫-------------------------------+-------------------------------˧
    boost-json █████████████████████████████████████████████████████████████████
       cl-json ████████████▌
com.inuoe.jzon ██████▉
      json-lib ████████████████████████▎
      jonathan ██████▊
         jsown ███████████████████▌
        shasht ███████▎
       st-json █████▋
         yason ██████████████▋

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-json-libraries-specific-comments" class="outline-2">
<h2 id="json-libraries-specific-comments">JSON Libraries Specific Comments</h2>
<div class="outline-text-2" id="text-json-libraries-specific-comments">
</div>
<div id="outline-container-boost-json" class="outline-3">
<h3 id="boost-json">boost-json</h3>
<div class="outline-text-3" id="text-boost-json">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#boost-json">boost-json</a></td>
<td class="org-left">Jeffrey Massung</td>
<td class="org-left">Apache v.2</td>
<td class="org-left"><a href="https://github.com/cl-boost/json">https://github.com/cl-boost/json</a></td>
<td class="org-left">Not in Quicklisp</td>
</tr>
</tbody>
</table>

<p>
Boost-json is one of the faster decoders. The author notes that he personally uses it to parse extremely large, genomics JSON-list files (several GB in size). The author and I have different opinions on nil/false/null/[] and whether they actually have meaningful differences. He does not think so; I disagree. It does have issues on the encoding side, sometimes losing values when encoding vectors and is generally one of the slowest writers. I think it has value in the right use cases, but you do need to make sure it meets your particular needs.
</p>
</div>

<div id="outline-container-boost-json-mapping" class="outline-4">
<h4 id="boost-json-mapping">Default Mapping</h4>
<div class="outline-text-4" id="text-boost-json-mapping">
<p>
Please note the direction of the arrows in the following table.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lisp</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">integer</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with no frac or exp parts</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">rational</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">ratio</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">true</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-</td>
<td class="org-left">false</td>
</tr>

<tr>
<td class="org-left">other symbol</td>
<td class="org-left">-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">character</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">list (except alists)</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">alist (dotted pairs)</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Invalid JSON array</td>
</tr>

<tr>
<td class="org-left">alist (undotted pairs)</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">nested array</td>
</tr>

<tr>
<td class="org-left">hash-table</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">CLOS object</td>
<td class="org-left">&lt;-</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">standard object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">need to write a method</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-boost-json-decoding" class="outline-4">
<h4 id="boost-json-decoding">Decoding</h4>
<div class="outline-text-4" id="text-boost-json-decoding">
<p>
Boost-json has different functions for decoding from strings (json-decode) or streams (json-read). JSON arrays are decoded to CL lists and JSON objects are decoded to a CLOS object with slot-value names interned in the boost-json package.
</p>

<p>
I find its handling of nil and false a bit confusing. Consider the following examples:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(boost-json:json-decode <span class="org-string">"[false]"</span>)
(NIL)

(boost-json:json-decode <span class="org-string">"{\"A\":false}"</span>)
#&lt;BOOST-JSON:JSON-OBJECT {<span class="org-string">"A"</span><span class="org-builtin">:null}&gt;</span>
</pre>
</div>
<p>
Within an array, JSON's 'false' is converted to CL nil, but within a JSON object, JSON's 'false' is convert to CL :null. Why?
</p>

<p>
We also have a symmetry problem with respect to JSON's 'false'. See the following:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(boost-json:json-encode
 (boost-json:json-decode <span class="org-string">"{\"A\":false}"</span>))
{<span class="org-string">"A"</span><span class="org-builtin">:null}</span>
</pre>
</div>
<p>
The starting point with 'false' got converted to null.
</p>

<p>
Boost-json does not handle unicode surrogate pairs if you care about that sort of thing.
</p>
</div>

<div id="outline-container-boost-json-decoding-to-clos" class="outline-5">
<h5 id="boost-json-decoding-to-clos">Decoding to CLOS object</h5>
<div class="outline-text-5" id="text-boost-json-decoding-to-clos">
<p>
Now let's talk about boost-json's automagic decoding JSON objects to a json-object which is a standard CLOS object. Let's start with a simple version before we go to nested objects.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(boost-json:json-decode <span class="org-string">"{ \"weights\" : [ 0.5, 0.5 ] }"</span>)
#&lt;BOOST-JSON:JSON-OBJECT {<span class="org-string">"weights"</span>:#}&gt;

(describe (boost-json:json-decode <span class="org-string">"{ \"weights\" : [ 0.5, 0.5 ] }"</span>))
#&lt;BOOST-JSON:JSON-OBJECT {<span class="org-string">"weights"</span>:#}&gt;
  [standard-object]

Slots with <span class="org-builtin">:INSTANCE</span> allocation:
  MEMBERS                        = ((<span class="org-string">"weights"</span> (0.5 0.5)))
</pre>
</div>
<p>
It appears that you need to call (boost-json:json-getf obj keyword) in order to act as an accessor to the automagically built CLOS object:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(boost-json:json-getf
 (boost-json:json-decode <span class="org-string">"{ \"weights\" : [ 0.5, 0.5 ] }"</span>)
 <span class="org-string">"weights"</span>)
(0.5 0.5)
</pre>
</div>
<p>
or, of course, you can use slot-value, just remember that the slot-value name will be interned in the boost-json package..
</p>
</div>
</div>
<div id="outline-container-boost-json-decoding-nested-objects-to-clos" class="outline-5">
<h5 id="boost-json-decoding-nested-objects-to-clos">Nested Objects</h5>
<div class="outline-text-5" id="text-boost-json-decoding-nested-objects-to-clos">
<p>
Now let's look at a nested object. As a reminder, we will use the following parameter:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*nested-address-1*</span> <span class="org-string">"{</span>
<span class="org-string">  \"first_name\": \"George\",</span>
<span class="org-string">  \"last_name\": \"Washington\",</span>
<span class="org-string">  \"birthday\": \"1732-02-22\",</span>
<span class="org-string">  \"address\": {</span>
<span class="org-string">    \"street_address\": \"3200 Mount Vernon Memorial Highway\",</span>
<span class="org-string">    \"city\": \"Mount Vernon\",</span>
<span class="org-string">    \"state\": \"Virginia\",</span>
<span class="org-string">    \"country\": \"United States\"</span>
<span class="org-string">  }</span>
<span class="org-string">}"</span>)
</pre>
</div>
<p>
If we want to get the city from the CLOS object that boost-json created, it might look something like this:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(boost-json:json-getf
 (boost-json:json-getf
  (boost-json:json-decode *nested-address-1*)
  <span class="org-string">"address"</span>)
 <span class="org-string">"city"</span>)
<span class="org-string">"Mount Vernon"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-boost-json-encoding" class="outline-4">
<h4 id="boost-json-encoding">Encoding</h4>
<div class="outline-text-4" id="text-boost-json-encoding">
<p>
On the plus side, boost-json was one of two libraries which could encode a pathname.
</p>

<p>
On the neutral side, data types like char, local-time:timestamps and structs would require you to write an encoding method to handle them if you have them.
</p>

<p>
On the "choose your data structures carefully side",
</p>
<ul class="org-ul">
<li>Encoding hash-tables succeeds if the hash-table keys are strings, fails if they are symbols</li>
<li>Encoding vectors results in invalid results, generally losing the first value in the array. Sample output on a simple nested array looked like: [,"Cork","Limerick"][,[,"Frankfurt","Munich"]]</li>
<li><p>
Boost-json will try to encode alists as JSON arrays of array. It will generate invalid JSON if the alisp has dotted pairs.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(boost-json:json-encode '((<span class="org-string">"A"</span> . 1) (<span class="org-string">"B"</span> . 2) (<span class="org-string">"C"</span> . 3)))
[[<span class="org-string">"A"</span>,. 1],[<span class="org-string">"B"</span>,. 2],[<span class="org-string">"C"</span>,. 3]]
</pre>
</div>
<p>
If the array is not dotted pairs, boost-json will give you arrays of arrays.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(boost-json:json-encode '((<span class="org-string">"A"</span>  1) (<span class="org-string">"B"</span>  2) (<span class="org-string">"C"</span>  3)))
[[<span class="org-string">"A"</span>,1],[<span class="org-string">"B"</span>,2],[<span class="org-string">"C"</span>,3]]
</pre>
</div></li>
</ul>
</div>

<div id="outline-container-boost-json-encoding-clos" class="outline-5">
<h5 id="boost-json-encoding-clos">Encoding CLOS class instances</h5>
<div class="outline-text-5" id="text-boost-json-encoding-clos">
<p>
For boost-json to encode a CLOS class instance, you need to provide a new json-write method for that class unless it is a json-object class. In the decoding examples, we saw a JSON object "{\"weights\" : [ 0.5, 0.5 ] }" get decoded to a boost-json:json-object:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(boost-json:json-encode
 (boost-json:json-decode <span class="org-string">"{ \"weights\" : [ 0.5, 0.5 ] }"</span>))
{<span class="org-string">"weights"</span><span class="org-builtin">:[0.5</span>,0.5]}
</pre>
</div>
<p>
If we tried that with our simple person class which is not a boost-json:json-object,
</p>
<div class="org-src-container">
<pre class="src src-lisp">(boost-json:json-encode (make-instance 'person))
<span class="org-comment-delimiter">; </span><span class="org-comment">Evaluation aborted on #&lt;SB-PCL::NO-APPLICABLE-METHOD-ERROR {1005573E93}&gt;.</span>
</pre>
</div>
<p>
You could use the existing methods in <a href="https://github.com/cl-boost/json/blob/main/encode.lisp">https://github.com/cl-boost/json/blob/main/encode.lisp</a> or, for our very simple person class, something like the following could work:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmethod</span> <span class="org-function-name">boost-json:json-write</span> ((person person) <span class="org-type">&amp;optional</span> stream)
  (<span class="org-keyword">let</span> ((accessors '((<span class="org-string">"name"</span> name) (<span class="org-string">"eye_colour"</span> eye-colour))))
    (write-char  #\{ stream)
    (<span class="org-keyword">loop</span> <span class="org-builtin">:for</span> (key val) <span class="org-builtin">:in</span> accessors
          <span class="org-builtin">:for</span> first <span class="org-builtin">:=</span> t <span class="org-builtin">:then</span> nil
          <span class="org-builtin">:unless</span> first <span class="org-builtin">:do</span> (write-char #\, stream)
          do
          (boost-json::json-write key stream)
          (write-char #\: stream)
          (boost-json::json-write (funcall val person) stream))
    (write-char  #\} stream)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-boost-json-symmetry" class="outline-4">
<h4 id="boost-json-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-boost-json-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON it only fails on dealing with 'false'.
</p>

<p>
It had more problems going from CL-&gt;JSON-&gt;CL. In some tests it triggered an error with an expected #\N, in others nil came back as nul and it could lose the first value in vectors.
</p>
</div>
</div>
<div id="outline-container-boost-json-security" class="outline-4">
<h4 id="boost-json-security">Security</h4>
<div class="outline-text-4" id="text-boost-json-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data.
</p>

<p>
Boost-json did not exhibit the first issue in the same way that e.g. cl-json does. However, it does decode JSON objects to a CLOS object with slot-value names interned in the boost-json package.
</p>

<p>
With respect to the second issue, boost-json properly rejected 145 malformed test cases but accepted 28. Some of those malformed test cases which were accepted actually triggered stack exhaustion by opening too many levels of JSON open arrays and not closing them or similar types of issues.
</p>
</div>
</div>
<div id="outline-container-boost-json-conformity" class="outline-4">
<h4 id="boost-json-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-boost-json-conformity">
<p>
Boost-json accepted 95 of the 95 test cases that are considered "must accept".  If *read-default-float-format* is set to 'single-float, it would refuse to accept:  [123e65], [123e45] and [123.456e78].
</p>

<p>
It accepted 13 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>

<div id="outline-container-boost-json-benchmarkiing" class="outline-4">
<h4 id="boost-json-benchmarkiing">Benchmarking</h4>
<div class="outline-text-4" id="text-boost-json-benchmarkiing">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>
<div id="outline-container-boost-json-exported-symbols" class="outline-4">
<h4 id="boost-json-exported-symbols">boost-json exported symbols</h4>
<div class="outline-text-4" id="text-boost-json-exported-symbols">
<ul class="org-ul">
<li><b>json-decode</b> - Convert a JSON string into a Lisp object.</li>
<li><b>json-encode</b> - Encodes a Lisp value into a stream.</li>
<li><b>json-read</b> - decode from a stream</li>
<li><b>json-enable-reader-macro</b> - enable json-object-reader macro</li>
<li><b>json-object</b></li>
<li><b>json-object-members</b></li>
<li><b>json-getf</b> - Find an member's value in a JSON object.</li>
<li><b>json-setf</b> - Assign a value to a key in a JSON object.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-cl-json" class="outline-3">
<h3 id="cl-json">cl-json</h3>
<div class="outline-text-3" id="text-cl-json">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#cl-json">cl-json</a></td>
<td class="org-left">Henrik Hjelte, Boris Smilga, Robert Goldman</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/hankhero/cl-json">https://github.com/hankhero/cl-json</a></td>
</tr>
</tbody>
</table>

<p>
cl-json is an old workhorse in area, however, it has not been updated in the last seven years and is fairly slow as you can tell from the <a href="#benchmarking">benchmarks</a>. It does not handle unicode surrogate pairs, JSON's null and is not as likely to be symmetric as some of the other libraries. Like most of the other libraries (except jsown and shasht), cl-json does not encode multi-dimensional arrays. As noted in the <a href="#security">security</a> section, cl-json interns keys into the keyword package which can open you up to the equivalent of a DOS attack. cl-json does provide a mitigation function which will throw an error if the keyword to be interned does not already exist in the *json-symbols-package*.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(setf cl-json::*identifier-name-to-key* #'cl-json::safe-json-intern)
(cl-json:decode-json-from-string <span class="org-string">"{\"alpha-omega\": 1}"</span>)
</pre>
</div>

<p>
On the plus side, cl-json does probably have the best support for converting JSON data to clos objects and vice versa, but surprisingly does not handle structs. Local-time:timestamps are returned as JSON objects {"day":7990,"sec":0,"nsec":0} but not as javascript date objects. Unlike many of the other libraries, it does handle symbols without you having to write a new method. It allows you to handle incremental encoding.
</p>

<p>
With respect to conformity testing, cl-json was 95/95 for the JSON strings it must accept. It did not do so well rejecting malformed strings and, like most of the other libraries could exhaust the stack when facing certain types of <a href="#malformed-data">malformed strings</a>.
</p>

<p>
When you are looking at plists and alists, cl-json provides specific functions for dealing with those structures rather than attempting to guess how they should be translated into JSON.
</p>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 56:</span> Cl-json Outstanding Issues</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Issue</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Symmetry violations <a href="https://github.com/hankhero/cl-json/issues/22">issue 22</a>, <a href="https://github.com/hankhero/cl-json/issues/4">issue 4</a></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Decoding JSON with duplicate keys get returned rather than flagged <a href="https://github.com/hankhero/cl-json/issues/16">issue 16</a></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Does not handle unicode surrogate pairs <a href="https://github.com/hankhero/cl-json/issues/11">issue 11</a></td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Does not handle null properly</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-cl-json-mapping" class="outline-4">
<h4 id="cl-json-mapping">Default Mapping</h4>
<div class="outline-text-4" id="text-cl-json-mapping">
<p>
Please note the direction of the arrows in the following table.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lisp</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">integer</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with no frac or exp parts</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">rational</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">ratio</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">true</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-</td>
<td class="org-left">false</td>
</tr>

<tr>
<td class="org-left">other symbol</td>
<td class="org-left">-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">character</td>
<td class="org-left">-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">list (except alists)</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">array  (1)</td>
</tr>

<tr>
<td class="org-left">other sequences</td>
<td class="org-left">-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">alist with dotted pairs</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">object (1)</td>
</tr>

<tr>
<td class="org-left">hash-table</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">standard object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) This is cl-json's default mode. Using cl-json:with-decoder-simple-clos-semantics or cl-json:simple-clos-semantics will switch cl-json into a mode where JSON arrays are decoded to cl vectors rather than lists, and JSON objects are decoded to CLOS objects rather than alists.</li>
</ul>
</div>
</div>
<div id="outline-container-cl-json-decoding" class="outline-4">
<h4 id="cl-json-decoding">Decoding</h4>
<div class="outline-text-4" id="text-cl-json-decoding">
<p>
Cl-json uses different functions to decode from a string (decode-json-from-string x) v. decoding from a stream (decode-json x).
</p>

<p>
It converts JSON's 'null' to NIL, which I disagree with. It also fails to deal with unicode surrogate pairs if you care about those.
</p>

<p>
JSON objects are converted to alists with dotted pairs which is unusual for the rest of the libraries.
</p>
</div>

<div id="outline-container-cl-json-data-to-clos" class="outline-5">
<h5 id="cl-json-data-to-clos">JSON data to CLOS Object</h5>
<div class="outline-text-5" id="text-cl-json-data-to-clos">
<p>
While cl-json normally returns JSON objects as arrays, you could tell it to return the JSON object as an cl-json:fluid-class CLOS object. You do need to at least temporarily set the change the decoder to use simple-clos-semantics and set the *json-symbols-package* to nil. (It should be noted that since the decoder maintains a class registry, this is thread unsafe. According to the docs, if every incoming JSON Object is guaranteed to have a prototype with a "lispClass" member then there are no fluid objects and thread safety is ensured. If the user wishes to employ fluid objects in a threaded environment it is advisable to wrap the body of entry-point functions in with-local-class-registry.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(cl-json:set-decoder-simple-clos-semantics)
</pre>
</div>

<p>
You can reset the decoder back to lists with the function:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(set-decoder-simple-list-semantics)
</pre>
</div>
<p>
This example temporarily changes the cl-json decoder semantics so that it creates a cl-json:fluid class, then we can get the birthday slot value of that class.
</p>

<p>
For example purposes, consider two JSON objects, *address-1* and *nested-address-1*:
</p>
<div class="org-src-container">
<pre class="src src-javascript">  *address-1*
  <span class="org-string">"{</span>
<span class="org-string">    \"name\": \"George Washington\",</span>
<span class="org-string">    \"birthday\": \"February 22, 1732\",</span>
<span class="org-string">    \"address\": \"Mount Vernon, Virginia, United States\"</span>
<span class="org-string">  }"</span>

*nested-address-1*
<span class="org-string">"{</span>
<span class="org-string">  \"first_name\": \"George\",</span>
<span class="org-string">  \"last_name\": \"Washington\",</span>
<span class="org-string">  \"birthday\": \"1732-02-22\",</span>
<span class="org-string">  \"address\": {</span>
<span class="org-string">    \"street_address\": \"3200 Mount Vernon Memorial Highway\",</span>
<span class="org-string">    \"city\": \"Mount Vernon\",</span>
<span class="org-string">    \"state\": \"Virginia\",</span>
<span class="org-string">    \"country\": \"United States\"</span>
<span class="org-string">  }</span>
<span class="org-string">}"</span>
</pre>
</div>
<p>
First, looking at the simpler version, notice you need to specify the slots in the fluid-class object:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
    (setf cl-json:*json-symbols-package* nil)
  (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *address-1*)))
    (<span class="org-keyword">with-slots</span> (name birthday address) x
      birthday)))
<span class="org-string">"1732-02-22"</span>
</pre>
</div>
<p>
Just to check something, lets describe that instance of the fluid-class:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
 (setf cl-json:*json-symbols-package* nil)
 (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *address-1*)))
   (describe x)))

&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100319AEA3}&gt; {1003358763}&gt;
[standard-object]

Slots with <span class="org-builtin">:INSTANCE</span> allocation:
NAME                           = <span class="org-string">"George Washington"</span>
BIRTHDAY                       = <span class="org-string">"February 22, 1732"</span>
ADDRESS                        = <span class="org-string">"Mount Vernon, Virginia, United States"</span>
</pre>
</div>
<p>
Now looking at the nested version, we need to note that by default cl-json will convert the underscores in the JSON keys to double hyphens in the slot names.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
    (setf cl-json:*json-symbols-package* nil)
  (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *nested-address-1*)))
    (<span class="org-keyword">with-slots</span> (first--name last--name birthday address) x
      (values x first--name last--name birthday address))))
#&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100F765713}&gt; {10107CF9E3}&gt;
<span class="org-string">"George"</span>
<span class="org-string">"Washington"</span>
<span class="org-string">"1732-02-22"</span>
#&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100F765713}&gt; {10107CF6F3}&gt;
</pre>
</div>
<p>
Because we have a nested class, we would need drill down and specify the slots for the sub-object as well:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
    (setf cl-json:*json-symbols-package* nil)
  (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *nested-address-1*)))
    (<span class="org-keyword">with-slots</span> (first--name last--name birthday address) x
      (<span class="org-keyword">with-slots</span> (street--address city state country) address
        (values x first--name last--name birthday address city)))))
#&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100F765713}&gt; {1010E69B93}&gt;
<span class="org-string">"George"</span>
<span class="org-string">"Washington"</span>
<span class="org-string">"1732-02-22"</span>
#&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100F765713}&gt; {1010E698A3}&gt;
<span class="org-string">"Mount Vernon"</span>
</pre>
</div>
<p>
We can also use slot values to get the info, but before we do that, let's use the nested-address sample data and just describe the object instance.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
    (setf cl-json:*json-symbols-package* nil)
  (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *nested-address-1*)))
    (describe x)))

#&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100319AEA3}&gt; {10039F9CC3}&gt;
[standard-object]

Slots with <span class="org-builtin">:INSTANCE</span> allocation:
NAME                           = #&lt;unbound slot&gt;
BIRTHDAY                       = <span class="org-string">"1732-02-22"</span>
ADDRESS                        = #&lt;#&lt;JSON:FLUID-CLASS COMMON-LISP:NIL {100319AEA3}&gt; {100388FC13}&gt;
STREET--ADDRESS                = #&lt;unbound slot&gt;
CITY                           = #&lt;unbound slot&gt;
STATE                          = #&lt;unbound slot&gt;
COUNTRY                        = #&lt;unbound slot&gt;
FIRST--NAME                    = <span class="org-string">"George"</span>
LAST--NAME                     = <span class="org-string">"Washington"</span>
</pre>
</div>
<p>
Ok, this surprised me. The fluid-class is showing all the slots it created from *address-1* as well as the slots it created from *nested-address-1*. We also see that the keys "first-name", "last-name" and "street-address" have double hyphens when they are slot names and the fluid class created slots for embedded address object.
</p>

<p>
So just to demonstrate using slot value to get the data from a fluid object:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
    (setf cl-json:*json-symbols-package* nil)
  (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *nested-address-1*)))
    (slot-value x 'first--name)))
<span class="org-string">"George"</span>
</pre>
</div>
<p>
Now suppose we want to go into the nested address and get just the city. For that we need to descend down, creating another cl-json:fluid object and then access its city slot value:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
    (setf cl-json:*json-symbols-package* nil)
  (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *nested-address-1*)))
    (<span class="org-keyword">with-slots</span> (first--name last--name birthday address) x
      (<span class="org-keyword">with-slots</span> (street--address city state country) address
        city))))
<span class="org-string">"Mount Vernon"</span>
</pre>
</div>
<p>
Or, using the slot-value approach:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-decoder-simple-clos-semantics</span>
    (setf cl-json:*json-symbols-package* nil)
  (<span class="org-keyword">let</span> ((x (cl-json:decode-json-from-string *nested-address-1*)))
    (slot-value (slot-value x 'address)
                'city)))
<span class="org-string">"Mount Vernon"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-cl-json-encoding" class="outline-4">
<h4 id="cl-json-encoding">Encoding</h4>
<div class="outline-text-4" id="text-cl-json-encoding">
<p>
Basic encoding functionality is provided by the generic function encode-json. This can be customised with an entire series of macros as listed in the documentation. cl-json's basic encoding function returns an object when handed an alist and returns an array when handed a plist. When handed a list of plists or list of alists, encode-json will return an array but the list of plists returned an array of arrays and the list of alists returned an array of objects.
</p>

<p>
cl-json provides a function to encode the alist properly as key:value, but my samples do not show any difference between cl-json:encode-json and cl-json:encode-json-alist. It will encode a dotted alist as a JSON object with key:value pairs. It will encode a proper list alist as an array of arrays.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(cl-json:encode-json '((<span class="org-string">"A"</span> . 1) (<span class="org-string">"B"</span> . 2) (<span class="org-string">"C"</span> . 3)))
{<span class="org-string">"A"</span><span class="org-builtin">:1</span>,<span class="org-string">"B"</span><span class="org-builtin">:2</span>,<span class="org-string">"C"</span><span class="org-builtin">:3}</span>

(cl-json:encode-json '((<span class="org-string">"A"</span> 1) (<span class="org-string">"B"</span> 2) (<span class="org-string">"C"</span> 3)))
[[<span class="org-string">"A"</span>,1],[<span class="org-string">"B"</span>,2],[<span class="org-string">"C"</span>,3]]
</pre>
</div>

<p>
On the plus side,
</p>
<ul class="org-ul">
<li>cl-json was the only library to handle encoding char out of the box.</li>
</ul>

<p>
On the "be care side:
</p>
<ul class="org-ul">
<li>As you might expect, plists are treated the same as plain lists and will lose their key-value connections. If you want to keep the key-value connections, you can either convert the list to an alist or hash-table or use the cl-json:encode-json-plist function.</li>
</ul>

<p>
On the "slightly additional work" side:
</p>
<ul class="org-ul">
<li>Encoding structures, pathnames and timestamps would require writing a specialized method</li>
</ul>
<p>
On the not-so-plus side:
</p>
<ul class="org-ul">
<li>It encodes nil as null. You can use the helper library cl-json-helper to encode nil as "false".</li>
</ul>
</div>
<div id="outline-container-cl-json-incremental" class="outline-5">
<h5 id="cl-json-incremental">Incremental Encoding</h5>
<div class="outline-text-5" id="text-cl-json-incremental">
<p>
The following examples use two exercises. First, incrementally build a JSON array. Second, incrementally build a JSON object which also contains an incrementally built JSON array.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-array</span> ()
  (<span class="org-keyword">dotimes</span> (i 3)
    (cl-json:encode-array-member i)))
[0,1,2]
</pre>
</div>
<p>
Now the second:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">cl-json:with-object</span> ()
  (cl-json:encode-object-member <span class="org-string">"hello"</span> <span class="org-string">"hu hu"</span>)
  (cl-json:as-object-member (<span class="org-string">"harr"</span>)
  (<span class="org-keyword">cl-json:with-array</span> ()
    (<span class="org-keyword">dotimes</span> (i 3)
      (cl-json:encode-array-member i)))))
{<span class="org-string">"hello"</span>:<span class="org-string">"hu hu"</span>,<span class="org-string">"harr"</span><span class="org-builtin">:[0</span>,1,2]}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-cl-json-symmetry" class="outline-4">
<h4 id="cl-json-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-cl-json-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, it only fails on dealing with false.
</p>

<p>
Similarly, going from CL-&gt;JSON-&gt;CL, you would need to deal with the fact that :NULL got converted to "null".
</p>
</div>
</div>
<div id="outline-container-cl-json-security" class="outline-4">
<h4 id="cl-json-security">Security</h4>
<div class="outline-text-4" id="text-cl-json-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data.
</p>

<p>
With respect to the first issue, Cl-json flags the issue and provides the function safe-json-intern - which will throw an error if the keyword to be interned does not already exist in the *json-symbols-package*. - so at least you are warned and provided with an alternative.
</p>

<p>
With respect to the second issue, cl-json properly rejected 153 malformed test cases but accepted 20. Some of those malformed test cases which were accepted actually triggered stack exhaustion by opening too many levels of JSON open arrays and not closing them or similar types of issues.
</p>
</div>
</div>
<div id="outline-container-cl-json-conformity" class="outline-4">
<h4 id="cl-json-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-cl-json-conformity">
<p>
cl-json accepted 95 of the 95 test cases that are considered "must accept". If *read-default-float-format* is set to 'single-float, it would refuse to accept:  [123e65], [123e45] and [123.456e78].
</p>

<p>
It accepted 13 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>
<div id="outline-container-cl-json-benchmarking" class="outline-4">
<h4 id="cl-json-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-cl-json-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>

<div id="outline-container-cl-json-other-information" class="outline-4">
<h4 id="cl-json-other-information">Miscellaneous Information</h4>
<div class="outline-text-4" id="text-cl-json-other-information">
<ol class="org-ol">
<li>Error Conditions
Cl-json has several error conditions, some of them recoverable and some of them not recoverable. These include "unrecoverable-value-error", "json-syntax-error", "no-char-for-code", "cell-error" "type-error", errors for calling functions in the wrong environment and others. Please read the user-manual for more details.</li>
<li>Cl-json has a converter from camel case to "lisp" (i.e., kebab case) and back again.</li>
<li>Cl-json has a lot of other capabilities. The documentation is excellent and you should seriously consider the security considerations section of the user manual if you are going to be decoding uncontrolled JSON objects.</li>
</ol>
</div>
</div>

<div id="outline-container-cl-json-exported-symbols" class="outline-4">
<h4 id="cl-json-exported-symbols">cl-json exported symbols</h4>
<div class="outline-text-4" id="text-cl-json-exported-symbols">
<ul class="org-ul">
<li><b>*aggregate-scope-variables*</b></li>
<li><b>*array-member-handler*</b></li>
<li><b>*array-scope-variables*</b></li>
<li><b>*beginning-of-array-handler*</b></li>
<li><b>*beginning-of-object-handler*</b></li>
<li><b>*beginning-of-string-handler*</b></li>
<li><b>*boolean-handler*</b></li>
<li><b>*end-of-array-handler*</b></li>
<li><b>*end-of-object-handler*</b></li>
<li><b>*end-of-string-handler*</b></li>
<li><b>*identifier-name-to-key*</b> - Designator for a function which, during decoding, maps the *json-identifier-name-to-lisp* -transformed key to the value it will have in the result object.</li>
<li><b>*integer-handler*</b></li>
<li><b>*internal-decoder*</b></li>
<li><b>*json-array-type*</b></li>
<li><b>*json-identifier-name-to-lisp*</b> - Designator for a function which maps string (a JSON Object key) to string (name of a Lisp symbol).</li>
<li><b>*json-input*</b> - The default input stream for decoding operations.</li>
<li><b>*json-output*</b> - The default output stream for encoding operations.</li>
<li><b>*json-symbols-package*</b> - The package where JSON Object keys etc. are interned. Default keyword, nil = use current <b>package</b>.</li>
<li><b>*lisp-identifier-name-to-json*</b> - Designator for a function which maps string (name of a Lisp symbol) to string (e. g. JSON Object key).</li>
<li><b>*object-key-handler*</b></li>
<li><b>*object-scope-variables*</b></li>
<li><b>*object-value-handler*</b></li>
<li><b>*prototype-name*</b></li>
<li><b>*real-handler*</b></li>
<li><b>*string-char-handler*</b></li>
<li><b>*string-scope-variables*</b></li>
<li><b>*use-strict-json-rules*</b> - If non-nil, signal error on unrecognized escape sequences in JSON Strings.  If nil, translate any such sequence to the char after slash.</li>
<li><b>as-array-member</b> - BODY should be a program which encodes exactly one JSON datum to STREAM.  AS-ARRAY-MEMBER ensures that the datum is properly formatted as a Member of an Array, i. e. separated by comma from any preceding or following Member.</li>
<li><b>as-object-member</b> - BODY should be a program which writes exactly one JSON datum to STREAM.  AS-OBJECT-MEMBER ensures that the datum is properly formatted as a Member of an Object, i. e. preceded by the (encoded) KEY and colon, and separated by comma from any preceding or following Member.</li>
<li><b>bignumber-string</b></li>
<li><b>bind-custom-vars</b></li>
<li><b>camel-case-to-lisp</b> - Take a camel-case string and convert it into a string with Lisp-style hyphenation.</li>
<li><b>clear-class-registry</b> - Reset the *CLASS-REGISTRY* to NIL.</li>
<li><b>current-decoder</b> - Capture current values of custom variables and return a custom decoder which restores these values in its dynamic environment.</li>
<li><b>custom-decoder</b> - Return a function which is like DECODE-JSON called in a dynamic environment with the given CUSTOMIZATIONS.</li>
<li><b>decode-json</b> - Read a JSON Value from STREAM and return the corresponding Lisp value.</li>
<li><b>decode-json-from-source</b> - Decode a JSON Value from source using the value of decoder (default 'decode-json) as decoder function. If the source is a string, the input is from this string; if it is a pathname, the input is from the file that it names; otherwise, a stream is expected as source.</li>
<li><b>decode-json-from-string</b> - Read a JSON Value from json-string and return the corresponding Lisp value.</li>
<li><b>decode-json-strict</b> - Same as decode-json, but allow only Objects or Arrays on the top level, no junk afterwards.</li>
<li><b>encode-array-member</b> - Encode OBJECT as the next Member of the innermost JSON Array opened with WITH-ARRAY in the dynamic context.  OBJECT is encoded using the ENCODE-JSON generic function, so it must be of a type for which an ENCODE-JSON method is defined.</li>
<li><b>encode-json</b> - Write a JSON representation of OBJECT to STREAM and return NIL.</li>
<li><b>encode-json-alist</b> - Write the JSON representation (Object) of alist to stream (or to <b>json-output</b>). Return nil.</li>
<li><b>encode-json-alist-to-string</b> - Return the JSON representation (Object) of alist as a string</li>
<li><b>encode-json-plist</b> - Write the JSON representation (Object) of plist to stream (or to <b>json-output</b>). Return nil.</li>
<li><b>encode-json-plist-to-string</b> -  Return the JSON representation (Object) of plist as a string.</li>
<li><b>encode-json-to-string</b> - Return the JSON representation of object as a string.</li>
<li><b>encode-object-member</b> - Encode KEY and VALUE as a Member pair of the innermost JSON Object opened with WITH-OBJECT in the dynamic context.  KEY and VALUE are encoded using the ENCODE-JSON generic function, so they both must be of a type for which an ENCODE-JSON method is defined.  If KEY does not encode to a String, its JSON representation (as a string) is encoded over again.</li>
<li><b>fluid-class</b> - A class to whose instances arbitrary new slots may be added on the fly.</li>
<li><b>fluid-object</b></li>
<li><b>json-bind</b></li>
<li><b>json-bool</b> - Intended for the JSON-EXPLICT-ENCODER. Converts a non-nil value to a value (:true) that creates a JSON true value when used in the  explict encoder. Or (:false).</li>
<li><b>json-decode</b></li>
<li><b>json-enable-reader-macro</b></li>
<li><b>json-encode</b></li>
<li><b>json-getf</b></li>
<li><b>json-intern</b> - Intern STRING in the current *JSON-SYMBOLS-PACKAGE*.</li>
<li><b>json-object</b></li>
<li><b>json-object-members</b></li>
<li><b>json-or-null</b> - Intended for the JSON-EXPLICT-ENCODER. Returns a non-nil value as itself, or a nil value as a JSON null-value</li>
<li><b>json-read</b></li>
<li><b>json-setf</b></li>
<li><b>json-syntax-error</b> - Signal a JSON-SYNTAX-ERROR condition</li>
<li><b>lisp-to-camel-case</b> - Take a string with Lisp-style hyphentation and convert it to camel case.  This is an inverse of CAMEL-CASE-TO-LISP.</li>
<li><b>make-object</b> - If CLASS is not NIL, create an instance of that class.  Otherwise, create a fluid object whose class has the given SUPERCLASSES (null list by default).  In either case, populate the resulting object using BINDINGS (an alist of slot names and values).</li>
<li><b>make-object-prototype</b> - Return a PROTOTYPE describing the OBJECT's class or superclasses, and the package into which the names of the class / superclasses and of the OBJECT's slots are to be interned.</li>
<li><b>no-char-for-code</b></li>
<li><b>pass-code</b></li>
<li><b>placeholder</b></li>
<li><b>prototype</b> - A PROTOTYPE contains metadata for an object's class in a format easily serializable to JSON: either the name of the class as a string or (if it is anonymous) the names of the superclasses as a list of strings; and the name of the Lisp package into which the names of the class's slots and the name of the class / superclasses are to be interned.</li>
<li><b>rational-approximation</b></li>
<li><b>safe-json-intern</b> - The default json-intern is not safe. Interns of many unique symbols could potentially use a lot of memory. An attack could exploit this by submitting something that is passed through cl-json that has many very large, unique symbols. This version is safe in that respect because it only allows symbols that already exists.</li>
<li><b>set-custom-vars</b></li>
<li><b>set-decoder-simple-clos-semantics</b> - Set the decoder semantics to the following:
<ul class="org-ul">
<li>Strings and Numbers are decoded naturally, reals becoming floats.</li>
<li>The literal name true is decoded to T, false and null to NIL.</li>
<li>Arrays are decoded to sequences of the type *JSON-ARRAY-TYPE*.</li>
<li>Objects are decoded to CLOS objects.  Object keys are converted by the function *JSON-IDENTIFIER-NAME-TO-LISP*.  If a JSON Object has a field whose key matches *PROTOTYPE-NAME*, the class of the CLOS object and the package wherein to intern slot names are inferred from the corresponding value which must be a valid prototype.  Otherwise, a FLUID-OBJECT is constructed whose slot names are interned in *JSON-SYMBOLS-PACKAGE*</li>
</ul></li>
<li><b>set-decoder-simple-list-semantics</b> - Set the decoder semantics to the following:
<ul class="org-ul">
<li>Strings and Numbers are decoded naturally, reals becoming floats.</li>
<li>The literal name true is decoded to T, false and null to NIL.</li>
<li>Arrays are decoded to sequences of the type *JSON-ARRAY-TYPE*.</li>
<li>Objects are decoded to alists.  Object keys are converted by the function *JSON-IDENTIFIER-NAME-TO-LISP* and then interned in the package *JSON-SYMBOLS-PACKAGE*.</li>
</ul></li>
<li><b>simplified-camel-case-to-lisp</b> - Insert - between lowercase and uppercase chars. Ignore _ + * and several consecutive uppercase.</li>
<li><b>stream-array-member-encoder</b> - Return a function which takes an argument and encodes it to STREAM as a Member of an Array.  The encoding function is taken from the value of ENCODER (default is #'ENCODE-JSON).</li>
<li><b>stream-object-member-encoder</b> - Return a function which takes two arguments and encodes them to STREAM as a Member of an Object (String : Value pair)</li>
<li><b>substitute-char</b></li>
<li><b>substitute-printed-representation</b></li>
<li><b>unencodable-value-error</b> - Signal an UNENCODABLE-VALUE-ERROR</li>
<li><b>unknown-symbol-error</b></li>
<li><b>use-explicit-encoder</b></li>
<li><b>use-guessing-encoder</b></li>
<li><b>with-array</b> - Open a JSON Array, run BODY, then close the Array.  Inside the BODY, AS-ARRAY-MEMBER or ENCODE-ARRAY-MEMBER should be called to encode Members of the Array.</li>
<li><b>with-custom-decoder-level</b> - Execute BODY in a dynamic environment such that, when nested structures are decoded, the outermost level is decoded with the given custom handlers (CUSTOMIZATIONS) whereas inner levels are decoded in the usual way</li>
<li><b>with-decoder-simple-clos-semantics</b> - Execute BODY in a dynamic environement where the decoder semantics is such as set by SET-DECODER-SIMPLE-CLOS-SEMANTICS.</li>
<li><b>with-decoder-simple-list-semantics</b> - Execute BODY in a dynamic environement where the decoder semantics is such as set by SET-DECODER-SIMPLE-LIST-SEMANTICS.</li>
<li><b>with-explicit-encoder</b></li>
<li><b>with-guessing-encoder</b></li>
<li><b>with-local-class-registry</b> - Run BODY in a dynamic environment where *CLASS-REGISTRY* is a temporary local list.  If :INHERIT is non-null, the local registry shall initially have the same content as the exterior *CLASS-REGISTRY*, otherwise it shall be NIL.</li>
<li><b>with-object</b> - Open a JSON Object, run BODY, then close the Object.  Inside the BODY, AS-OBJECT-MEMBER or ENCODE-OBJECT-MEMBER should be called to encode Members of the Object.</li>
<li><b>with-shadowed-custom-vars</b></li>
<li><b>with-substitute-printed-representation-restart</b> - Establish a SUBSTITUTE-PRINTED-REPRESENTATION restart for OBJECT and execute BODY.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-com.gigamonkeys.json" class="outline-3">
<h3 id="com.gigamonkeys.json">com.gigamonkeys.json</h3>
<div class="outline-text-3" id="text-com.gigamonkeys.json">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#com.gigamonkeys.json">com.gigamonkeys.json</a></td>
<td class="org-left">Peter Seibel</td>
<td class="org-left">BSD-3</td>
<td class="org-left"><a href="https://github.com/gigamonkey/monkeylib-json">https://github.com/gigamonkey/monkeylib-json</a></td>
</tr>
</tbody>
</table>

<p>
Com.gigamonkeys.json is one of the oldest libraries. In fact the author commented that he had forgotten he had written a JSON library. It is included for completeness, but I think the newer libraries have passed it by.
</p>
</div>

<div id="outline-container-gigamonkeys-mapping" class="outline-4">
<h4 id="gigamonkeys-mapping">Default Mapping</h4>
<div class="outline-text-4" id="text-gigamonkeys-mapping">
<p>
Please note the direction of the arrows.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lisp</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">integer</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with no frac or exp parts</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">rational</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">ratio</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">true</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">{}</td>
</tr>

<tr>
<td class="org-left">:FALSE</td>
<td class="org-left">&lt;-</td>
<td class="org-left">false</td>
</tr>

<tr>
<td class="org-left">:NULL</td>
<td class="org-left">&lt;-</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">other symbol</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Only keywords allowed. string</td>
</tr>

<tr>
<td class="org-left">character</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Hangs</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">list (except alists)</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">object (will force plist key:values)</td>
</tr>

<tr>
<td class="org-left">vector</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">alist</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">hash-table</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">standard object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-gigamonkeys-decoding" class="outline-4">
<h4 id="gigamonkeys-decoding">Decoding</h4>
<div class="outline-text-4" id="text-gigamonkeys-decoding">
<p>
Com.gigamonkeys.json only takes strings as inputs. It does not handle unicode surrogate pairs. On the plus side, it handles NULL issues correctly.
</p>

<p>
As noted in the mapping table above, JSON objects will be decoded as plists (or nested plists). Consider the following example of decoding a nested JSON object:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(com.gigamonkeys.json:parse-json <span class="org-string">"{</span>
<span class="org-string">  \"first_name\": \"George\",</span>
<span class="org-string">  \"last_name\": \"Washington\",</span>
<span class="org-string">  \"birthday\": \"1732-02-22\",</span>
<span class="org-string">  \"address\": {</span>
<span class="org-string">    \"street_address\": \"3200 Mount Vernon Memorial Highway\",</span>
<span class="org-string">    \"city\": \"Mount Vernon\",</span>
<span class="org-string">    \"state\": \"Virginia\",</span>
<span class="org-string">    \"country\": \"United States\"</span>
<span class="org-string">  }</span>
<span class="org-string">}"</span>)

(<span class="org-string">"first_name"</span> <span class="org-string">"George"</span> <span class="org-string">"last_name"</span> <span class="org-string">"Washington"</span> <span class="org-string">"birthday"</span> <span class="org-string">"1732-02-22"</span>
 <span class="org-string">"address"</span>
 (<span class="org-string">"street_address"</span> <span class="org-string">"3200 Mount Vernon Memorial Highway"</span> <span class="org-string">"city"</span> <span class="org-string">"Mount Vernon"</span>
  <span class="org-string">"state"</span> <span class="org-string">"Virginia"</span> <span class="org-string">"country"</span> <span class="org-string">"United States"</span>))
</pre>
</div>

<p>
Arrays are decoded to vectors.
</p>
</div>
</div>

<div id="outline-container-gigamonkeys-encoding" class="outline-4">
<h4 id="gigamonkeys-encoding">Encoding</h4>
<div class="outline-text-4" id="text-gigamonkeys-encoding">
<p>
There were a few surprises looking at what com.gigamonkeys.json would encode and not encode.
</p>
<ul class="org-ul">
<li>It encodes keyword symbols, but not other symbols.</li>
<li>It actually hangs on encoding chars and CLOS objects, which I found strange. Most of the other libraries generated errors.</li>
<li>Attempting to encode a pathname also results in hanging</li>
<li>nil encodes to {} (yes, empty object)</li>
<li>Like some other libraries, it cannot deal with alists directly. Consider using alexandria:alist-hash-table to convert the alist to a hash table.</li>
<li>On the other hand, in reversal from some of the other libraries, com.gigamonkeys.json will assume a plain list is a plist, returning a JSON object with key-value pairs. If the length of the list is odd, the final value in the list will be treated as a key and an empty set will be inserted as the value.</li>
</ul>

<p>
Let's take a closer look at the encoding functions. As noted previously, com.gigamonkeys.json will assume a plain list is a plist, returning a JSON object with key-value pairs. In the examples below, that means that since it is given a three value list, the third value is assumed to be the second key in an object and the value then is an empty set.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 57:</span> Encoding Functions applied to a list</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Input</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">json</td>
<td class="org-left">'(1 2 3)</td>
<td class="org-left">"{\"1\":2,\"3\":{}}"</td>
</tr>

<tr>
<td class="org-left">to-json</td>
<td class="org-left">'(1 2 3)</td>
<td class="org-left">(1 2 3)</td>
</tr>

<tr>
<td class="org-left">write-json</td>
<td class="org-left">'(1 2 3)</td>
<td class="org-left">{"1":2,"3":{}}</td>
</tr>
</tbody>
</table>

<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 58:</span> Encoding Functions applied to an array</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-left">Input</th>
<th scope="col" class="org-left">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">json</td>
<td class="org-left">#(1 2 3)</td>
<td class="org-left">"[1,2,3]"</td>
</tr>

<tr>
<td class="org-left">to-json</td>
<td class="org-left">#(1 2 3)</td>
<td class="org-left">#(1 2 3)</td>
</tr>

<tr>
<td class="org-left">write-json</td>
<td class="org-left">#(1 2 3)</td>
<td class="org-left">[1,2,3]</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-gigamonkeys-symmetry" class="outline-4">
<h4 id="gigamonkeys-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-gigamonkeys-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, it did not have any issues.
</p>

<p>
As you might have expected given its ignoring lists, going from CL-&gt;JSON-&gt;CL resulted in failure with tests starting with lists. If you started from an array, nil turned into {}, and it could get a little excited about how many decimal points it would return with respect to a float.
</p>
</div>
</div>
<div id="outline-container-gigamonkeys-security" class="outline-4">
<h4 id="gigamonkeys-security">Security</h4>
<div class="outline-text-4" id="text-gigamonkeys-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data. com.gigamonkeys.json did not exhibit the first issue.
</p>

<p>
With respect to the second issue, com.gigamonkeys.json accepted many malformed test cases which triggered stack exhaustion by opening too many levels of JSON open arrays and not closing them or similar types of issues.
</p>
</div>
</div>
<div id="outline-container-gigamonkeys-conformity" class="outline-4">
<h4 id="gigamonkeys-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-gigamonkeys-conformity">
<p>
com.gigamonkeys.json accepted all 95 test cases that are considered "must accept".
</p>

<p>
It accepted 14 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>
<div id="outline-container-gigamonkeys-benchmarking" class="outline-4">
<h4 id="gigamonkeys-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-gigamonkeys-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>
<div id="outline-container-gigamonkeys-exported-symbols" class="outline-4">
<h4 id="gigamonkeys-exported-symbols">com.gigamonkeys.json exported symbols</h4>
<div class="outline-text-4" id="text-gigamonkeys-exported-symbols">
<ul class="org-ul">
<li><b>*object-type*</b></li>
<li><b>json</b> - The top-level function for converting Lisp objects into a string in the JSON format. It can convert any object that can be converted to a json-exp via the to-json generic function.</li>
<li><b>json-stringify</b> - Convert object directly to a JSON representation as a string. Default methods are provided for strings, symbols (which must be keywords), and numbers but there may be situations where it is appropriate to define new methods on this function. In general, however, it is probably better to define a method on to-json to convert the object to a sexp that can be rendered as JSON.</li>
<li><b>parse-json</b> - Parse JSON text into Lisp objects. Hash tables are used to represent Javascript objects and vectors to represent arrays.</li>
<li><b>to-json</b> - Generic function that can convert an arbitrary Lisp object to a json-exp, i.e. a sexp that can then be rendered as JSON. To make an arbitrary class convertable to JSON, add a method to this generic function that generates a json-exp.</li>
<li><b>write-json</b> - Write data to stream in JSON format.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-com.inuoe.jzon" class="outline-3">
<h3 id="com.inuoe.jzon">com.inuoe.jzon</h3>
<div class="outline-text-3" id="text-com.inuoe.jzon">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#com.inuoe.jzon">com.inuoe.jzon</a></td>
<td class="org-left">Wilfredo Velázquez-Rodríguez</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/Zulu-Inuoe/jzon">https://github.com/Zulu-Inuoe/jzon</a></td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Com.inuoe.jzon is my new overall favorite. It is fast, it handles null correctly, it encodes all kinds of lists, CLOS objects, structures and hash-tables.
</p>
</div>

<div id="outline-container-jzon-mapping" class="outline-4">
<h4 id="jzon-mapping">Default Mapping</h4>
<div class="outline-text-4" id="text-jzon-mapping">
</div>
<div id="outline-container-jzon-mapping-json-cl" class="outline-5">
<h5 id="jzon-mapping-json-cl">Type Mapping JSON -&gt; CL</h5>
<div class="outline-text-5" id="text-jzon-mapping-json-cl">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">JSON</th>
<th scope="col" class="org-left">CL</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">true</td>
<td class="org-left">t</td>
</tr>

<tr>
<td class="org-left">false</td>
<td class="org-left">nil</td>
</tr>

<tr>
<td class="org-left">null</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">number</td>
<td class="org-left">integer or double float</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">simple-string</td>
</tr>

<tr>
<td class="org-left">array</td>
<td class="org-left">simple-vector</td>
</tr>

<tr>
<td class="org-left">object</td>
<td class="org-left">hash-table using equal as the test function</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-jzon-mapping-cl-json" class="outline-5">
<h5 id="jzon-mapping-cl-json">Type Mapping CL -&gt; JSON</h5>
<div class="outline-text-5" id="text-jzon-mapping-cl-json">
<p>
Using the stringify function, com.inuoe.jzon will map the following CL data types.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">CL</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">symbol</td>
<td class="org-left">string (generally downcased unless they contain mixed case characters)</td>
</tr>

<tr>
<td class="org-left">numbers</td>
<td class="org-left">number</td>
</tr>

<tr>
<td class="org-left">alist</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">plist</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">list or sequence</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">CLOS objects</td>
<td class="org-left">object (using bound slots as keys)</td>
</tr>

<tr>
<td class="org-left">structures</td>
<td class="org-left">object</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-jzon-decoding" class="outline-4">
<h4 id="jzon-decoding">Decoding</h4>
<div class="outline-text-4" id="text-jzon-decoding">
</div>
<div id="outline-container-jzon-decoding-acceptable-input-for-parse" class="outline-5">
<h5 id="jzon-decoding-acceptable-input-for-parse">Acceptable Input for Parse</h5>
<div class="outline-text-5" id="text-jzon-decoding-acceptable-input-for-parse">
<p>
com.inuoe.jzon will accept strings, octets in utf8, stream characters or binary in utf8, or a pathname (at which point the library will assume you want it to open a file for reading.
</p>

<p>
The README also notes that (parse &#x2026;) accepts the following keyword arguments:
</p>
<ul class="org-ul">
<li>:allow-comments This allows the given JSON to contain //cpp-style comments</li>
<li>:maximum-depth This controls the maximum depth to allow arrays/objects to nest. Can be a positive integer, or nil to disable depth tests. This turned out to be important when dealing with deliberately malformed incoming JSON data because the library was able to call a halt well before the stack was exhausted.</li>
<li>:key-fn A function of one argument responsible for 'interning' object keys. Should accept a simple-string and return the 'interned' key. The :key-fn parameter could be #'alexandria:make-keyword if you wanted to make object keys into symbols (but this is a bad practice from a security standpoint if the incoming JSON data is uncontrolled.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-jzon-encoding" class="outline-4">
<h4 id="jzon-encoding">Encoding</h4>
<div class="outline-text-4" id="text-jzon-encoding">
<p>
com.inuoe.jzon can encode to either a stream or string. E.g.:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(com.inuoe.jzon:stringify '(<span class="org-string">"A"</span> <span class="org-string">"b"</span> 4 3.2 9/4) <span class="org-builtin">:stream</span> *standard-output*)
[<span class="org-string">"A"</span>,<span class="org-string">"b"</span>,4,3.2,2.25]

(com.inuoe.jzon:stringify '(<span class="org-string">"A"</span> <span class="org-string">"b"</span> 4 3.2 9/4))
<span class="org-string">"[\"A\",\"b\",4,3.2,2.25]"</span>
</pre>
</div>

<p>
Additional Keyword Parameters for Stringify
</p>
<ul class="org-ul">
<li>:pretty If true, output pretty-formatted JSON</li>
<li>:coerce-element A function for coercing 'non-native' values to JSON.</li>
<li>:coerce-key A function for coercing key values to strings.</li>
</ul>

<p>
On the plus side,
</p>
<ul class="org-ul">
<li>It automatically handles standard CLOS objects and also allows you to specialize.</li>
<li>It is one of only two libraries which can encode a structure</li>
</ul>

<p>
On the "pay attention to your data structures" side:
com.inuoe.jzon:stringify will encode an alist as a JSON object. It uses heuristics to predict what data structure it is using. Consider the difference between giving it an alist with dotted pairs and an alist without dotted pairs:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(com.inuoe.jzon:stringify '((<span class="org-string">"A"</span> . 1) (<span class="org-string">"B"</span> . 2) (<span class="org-string">"C"</span> . 3)) <span class="org-builtin">:stream</span> *standard-output*)
{<span class="org-string">"A"</span><span class="org-builtin">:1</span>,<span class="org-string">"B"</span><span class="org-builtin">:2</span>,<span class="org-string">"C"</span><span class="org-builtin">:3}</span>

(com.inuoe.jzon:stringify '((<span class="org-string">"A"</span> 1) (<span class="org-string">"B"</span> 2) (<span class="org-string">"C"</span> 3)) <span class="org-builtin">:stream</span> *standard-output*)
{<span class="org-string">"A"</span><span class="org-builtin">:[1]</span>,<span class="org-string">"B"</span><span class="org-builtin">:[2]</span>,<span class="org-string">"C"</span><span class="org-builtin">:[3]}</span>
</pre>
</div>
<p>
Both are returned as JSON objects, but in the case of the undotted pairs, each value is embedded in its own array.
    It is pretty good at correctly guessing when something is a alist which should be encoded as key:value. Consider the following:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(com.inuoe.jzon:stringify '((<span class="org-string">"foo"</span> . <span class="org-string">"bar"</span>) (<span class="org-string">"baz"</span> . ((1 2 3) (4 5 6))))
                    <span class="org-builtin">:stream</span> *standard-output*)
{<span class="org-string">"foo"</span>:<span class="org-string">"bar"</span>,<span class="org-string">"baz"</span><span class="org-builtin">:[[1</span>,2,3],[4,5,6]]}
</pre>
</div>
<p>
and this particular sample works because it does not try to make an integer into a key. However, if you change the sample data slightly so that the first value in eash list in the embedded alist was a string, it would have predicated that the "A" and "B" should be keys. The next two examples show the differences between its interpretation depending on whether you provided dotted pairs or not:
</p>
<div class="org-src-container">
<pre class="src src-lisp">  (com.inuoe.jzon:stringify '((<span class="org-string">"foo"</span> . <span class="org-string">"bar"</span>) (<span class="org-string">"baz"</span> . ((<span class="org-string">"A"</span> 2 3) (<span class="org-string">"B"</span> 5 6))))
                            <span class="org-builtin">:stream</span> *standard-output*)
  {<span class="org-string">"foo"</span>:<span class="org-string">"bar"</span>,<span class="org-string">"baz"</span><span class="org-builtin">:{</span><span class="org-string">"A"</span><span class="org-builtin">:[2</span>,3],<span class="org-string">"B"</span><span class="org-builtin">:[5</span>,6]}}

(com.inuoe.jzon:stringify '((<span class="org-string">"foo"</span>  <span class="org-string">"bar"</span>) (<span class="org-string">"baz"</span> ((<span class="org-string">"A"</span> 2 3) (<span class="org-string">"B"</span> 5 6))))
                            <span class="org-builtin">:stream</span> *standard-output*)
{<span class="org-string">"foo"</span><span class="org-builtin">:[</span><span class="org-string">"bar"</span>],<span class="org-string">"baz"</span><span class="org-builtin">:[{</span><span class="org-string">"A"</span><span class="org-builtin">:[2</span>,3],<span class="org-string">"B"</span><span class="org-builtin">:[5</span>,6]}]}
</pre>
</div>
<p>
This may or may not have been what you wanted.
</p>
</div>


<div id="outline-container-org05790f2" class="outline-5">
<h5 id="org05790f2">Encoding Objects</h5>
<div class="outline-text-5" id="text-org05790f2">
<p>
com.inuoe.jzon actually uses the :type of each slot to determine what to do with nil. Consider the following where two slots have no specified type, two have a list type and two have an array type. Specifically, consider the resulting difference between value-list0 and value-array0 when writing the object out:
</p>
<div class="org-src-container">
<pre class="src src-lisp">  (<span class="org-keyword">defclass</span> <span class="org-type">my-class</span> ()
  ((name <span class="org-builtin">:initarg</span> <span class="org-builtin">:name</span>)
   (value0 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value0</span>)
   (value-list0 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value-list0</span>
               <span class="org-builtin">:type</span> list)
   (value-array0 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value-array0</span>
               <span class="org-builtin">:type</span> array)
   (value1 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value1</span>)
   (value-list1 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value-list1</span>
               <span class="org-builtin">:type</span> list)
   (value-array1 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value-array1</span>
               <span class="org-builtin">:type</span> array)))

(<span class="org-keyword">let</span> ((obj (make-instance 'my-class
                          <span class="org-builtin">:name</span> <span class="org-string">"Name"</span>
                          <span class="org-builtin">:value0</span> nil
                          <span class="org-builtin">:value-list0</span> nil
                          <span class="org-builtin">:value-array0</span> nil
                          <span class="org-builtin">:value1</span> 1
                          <span class="org-builtin">:value-list1</span> '(1 2 3)
                          <span class="org-builtin">:value-array1</span> #(<span class="org-string">"a"</span> <span class="org-string">"b"</span> <span class="org-string">"c"</span>))))
  (stringify obj))
<span class="org-string">"{</span>
<span class="org-string">  \"name\":\"Name\",</span>
<span class="org-string">  \"value0\":null,</span>
<span class="org-string">  \"value-list0\":[],</span>
<span class="org-string">  \"value-array0\":null,</span>
<span class="org-string">  \"value1\":1,</span>
<span class="org-string">  \"value-list1\":[1,2,3],</span>
<span class="org-string">  \"value-array1\":[\"a\",\"b\",\"c\"]</span>
<span class="org-string">}"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-jzon-decoding-specialize-serialization" class="outline-5">
<h5 id="jzon-decoding-specialize-serialization">Specialize Serialization</h5>
<div class="outline-text-5" id="text-jzon-decoding-specialize-serialization">
<p>
com.inuoe.jzon allows you to specialize the coerced-fields method to handle CL data types not included in the above list, including excluding, renaming and adding fields. See the <a href="https://github.com/Zulu-Inuoe/jzon">README</a> for examples.
</p>
</div>
</div>

<div id="outline-container-jzon-incremental" class="outline-5">
<h5 id="jzon-incremental">Incremental Encoding</h5>
<div class="outline-text-5" id="text-jzon-incremental">
<p>
The first simple example is just incrementally writing an array. We will set :pretty to nil.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">com.inuoe.jzon:with-writer*</span> (<span class="org-builtin">:stream</span> *standard-output* <span class="org-builtin">:pretty</span> nil)
  (com.inuoe.jzon:begin-array*)
  (<span class="org-keyword">dotimes</span> (i 3)
    (com.inuoe.jzon:write-value* i))
  (com.inuoe.jzon:end-array*))
[0,1,2]
</pre>
</div>
<p>
The second example borrows from the readme documentation and incrementally writes a JSON object:
</p>
<div class="org-src-container">
<pre class="src src-lisp">  (<span class="org-keyword">com.inuoe.jzon:with-writer*</span> (<span class="org-builtin">:stream</span> *standard-output* <span class="org-builtin">:pretty</span> t)
  (<span class="org-keyword">com.inuoe.jzon:with-object*</span>
    (com.inuoe.jzon:write-key* <span class="org-builtin">:age</span>)
    (com.inuoe.jzon:write-value* 24)

    (com.inuoe.jzon:write-property* <span class="org-builtin">:colour</span> <span class="org-builtin">:blue</span>)

    (com.inuoe.jzon:write-properties* <span class="org-builtin">:outside</span> nil
                            <span class="org-builtin">:interests</span> #()
                            <span class="org-builtin">:talent</span> 'null)

    (com.inuoe.jzon:write-key* <span class="org-string">"an-array"</span>)
    (<span class="org-keyword">com.inuoe.jzon:with-array*</span>
      (com.inuoe.jzon:write-values* <span class="org-builtin">:these</span> <span class="org-builtin">:are</span> <span class="org-builtin">:elements</span>))

    (com.inuoe.jzon:write-key* <span class="org-string">"another array"</span>)
    (com.inuoe.jzon:write-array* <span class="org-builtin">:or</span> <span class="org-string">"you"</span> <span class="org-string">"can use this"</span>)))
{
  <span class="org-string">"age"</span>: 24,
  <span class="org-string">"colour"</span>: <span class="org-string">"BLUE"</span>,
  <span class="org-string">"outside"</span>: false,
  <span class="org-string">"interests"</span>: [],
  <span class="org-string">"talent"</span>: null,
  <span class="org-string">"an-array"</span>: [
    <span class="org-string">"THESE"</span>,
    <span class="org-string">"ARE"</span>,
    <span class="org-string">"ELEMENTS"</span>
  ],
  <span class="org-string">"another array"</span>: [
    <span class="org-string">"OR"</span>,
    <span class="org-string">"you"</span>,
    <span class="org-string">"can use this"</span>
  ]
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-jzon-symmetry" class="outline-4">
<h4 id="jzon-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-jzon-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, it did not have any issues. It struggled a bit more with respect to going from CL-&gt;JSON-&gt;CL. The first test had a starting point of:
</p>
<div class="org-src-container">
<pre class="src src-lisp">((<span class="org-builtin">:NAME</span> <span class="org-string">"George Washington"</span>) (<span class="org-builtin">:BIRTHDAY</span> <span class="org-string">"February 22, 1732"</span>)
                             (<span class="org-builtin">:ADDRESS</span> <span class="org-string">"Mount Vernon, Virginia, United States"</span>))
</pre>
</div>
<p>
and a result (adjusted to get the elements out of the hash-table) of:
</p>
<div class="org-src-container">
<pre class="src src-lisp">((<span class="org-string">"address"</span> . #(<span class="org-string">"Mount Vernon, Virginia, United States"</span>))
 (<span class="org-string">"birthday"</span> . #(<span class="org-string">"February 22, 1732"</span>)) (<span class="org-string">"name"</span> . #(<span class="org-string">"George Washington"</span>)))
</pre>
</div>
<p>
So we went from undotted alist to dotted alist where each value was an array instead of a string. The second test started with an array instead of an alist and com.inuoe.jzon handled it with the one caveat that :NULL turned into "NULL".
</p>
</div>
</div>
<div id="outline-container-jzon-security" class="outline-4">
<h4 id="jzon-security">Security</h4>
<div class="outline-text-4" id="text-jzon-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data. com.inuoe.jzon did not exhibit the first issue.
</p>

<p>
With respect to the second issue, com.inuoe.jzon rejected all the malformed test cases. It was one of four packages which allowed you to limit the depths to which it would dive in nested JSON objects and, therefore, did not trigger the stack exhaustion exhibited by most of the other packages.
</p>
</div>
</div>
<div id="outline-container-jzon-conformity" class="outline-4">
<h4 id="jzon-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-jzon-conformity">
<p>
com.inuoe.jzon accepted all 95 test cases that are considered "must accept".
</p>

<p>
It accepted 7 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>
<div id="outline-container-jzon-benchmarking" class="outline-4">
<h4 id="jzon-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-jzon-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>

<div id="outline-container-jzon-exported-symbols" class="outline-4">
<h4 id="jzon-exported-symbols">com.inuoe.jzon exported symbols</h4>
<div class="outline-text-4" id="text-jzon-exported-symbols">
<ul class="org-ul">
<li><b>coerce-element</b> - Coerce "element" into a "json-element", using "coerce-key" in cases the result is a hash-table.</li>
<li><b>coerce-key</b> - Coerce "key" into a string designator, or "nil" if "key" is an unsuitable key.</li>
<li><b>coerced-fields</b> - Return a list of key definitions for "element". A key definition is a three-element list of the form (name value type). Name is the key name and will be coerced if not already a string. Value is the value, and will be coerced if not a json-element. Type is a type for the key, in order to handle ambiguous "nil" interpretations.</li>
<li><b>json-atom</b> - a type definition including t, nil, null, real and string</li>
<li><b>json-element</b> - a type definition including json-atoms, vectors and hash-tables</li>
<li><b>json-eof-error</b> - a json-parse-error</li>
<li><b>json-error</b> - a simple condition</li>
<li><b>json-parse-error</b> - a json-error condition</li>
<li><b>parse</b> - Read a JSON value from `in', which may be a vector, a stream, or a pathname. Keyword parameters: :maximum-depth controls the maximum depth of the object/array nesting. :allow-comments controls whether or not single-line // comments are allowed. :key-fn is a function of one value which 'pools' object keys, or null for the default pool.</li>
<li><b>stringify</b> - Serialize "element" into JSON. Returns a fresh string if "stream" is nil, nil otherwise.  ":stream" like the "destination" in "format" ":pretty" if true, pretty-format the output  ":coerce-element" is a function of two arguments, and is used to coerce an unknown value to a "json-element"  ":coerce-key" is a function of one argument, and is used to coerce object keys into non-nil string designators. See "coerce-element" and "coerce-key".</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-jonathan" class="outline-3">
<h3 id="jonathan">jonathan</h3>
<div class="outline-text-3" id="text-jonathan">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#jonathan">jonathan</a></td>
<td class="org-left">Rudolph Miller</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/Rudolph-Miller/jonathan">https://github.com/Rudolph-Miller/jonathan</a></td>
</tr>
</tbody>
</table>

<p>
While jsown is the winner in the decoding speed stakes, Jonathan can be faster or orders of magnitude slower depending on the amount of JSON data and its structure. Jonathan is among the leaders in <a href="#write-times">encoding speed</a> along with <a href="#st-json">st-json</a>, <a href="#com.inuoe.jzon">com.inuoe.jzon</a>, and <a href="#com.gigamonkeys.json">com.gigamonkeys.json</a>. However, speed is not everything and there are a few concerning issues. It has optimize set for safety 0 to increase speed. This has bitten some users hard in the past, so you have been warned.
</p>

<ul class="org-ul">
<li>As previously noted, jonathan shows substantial slow downs in decoding nested JSON objects of any real size.</li>
<li>Jonathan is unable to parse float if SAFETY restricted to 2 or 3 on SBCL. See <a href="https://github.com/Rudolph-Miller/jonathan/issues/66">https://github.com/Rudolph-Miller/jonathan/issues/66</a>.</li>
</ul>
</div>

<div id="outline-container-jonathan-mapping" class="outline-4">
<h4 id="jonathan-mapping">Default Mappping</h4>
<div class="outline-text-4" id="text-jonathan-mapping">
<p>
Please note the direction of the arrows in the following table.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lisp</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">integer</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with no frac or exp parts</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">rational</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">ratio</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">true</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">[]</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-</td>
<td class="org-left">false</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">other symbol</td>
<td class="org-left">-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">character</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">list (except alists)</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">vector</td>
<td class="org-left">-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">alist w/o dotted pairs</td>
<td class="org-left">-&gt;</td>
<td class="org-left">array of arrays</td>
</tr>

<tr>
<td class="org-left">alist with dotted pairs</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">hash-table</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">plist</td>
<td class="org-left">&lt;-</td>
<td class="org-left">object (1)</td>
</tr>

<tr>
<td class="org-left">standard object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) Jonathan can parse a JSON object into plists (the default), alists, hash-tables or a "JSON object" by passing different keyword parameters to the parse function.</li>
</ul>
</div>
</div>

<div id="outline-container-jonathan-decoding" class="outline-4">
<h4 id="jonathan-decoding">Decoding</h4>
<div class="outline-text-4" id="text-jonathan-decoding">
</div>
<div id="outline-container-jonathan-decoding-overview" class="outline-5">
<h5 id="jonathan-decoding-overview">Overview</h5>
<div class="outline-text-5" id="text-jonathan-decoding-overview">
<p>
Jonathan decodes strings, not streams.   In testing, jonathan hung when trying to decode "[123e-10000000]". In its default settings, jonathan will decode a JSON null as nil, but if you set jonathan:*null-value* to :null, it will decod a JSON null properly as :null.
</p>

<p>
Jonathan parse a JSON object by default into plists, usually reversed. You can change the resulting data structure by passing :as :XXX to the parse function. E.g.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jonathan:parse <span class="org-string">"{\"a\":1,\"b\":2}"</span>)
(:|b| 2 :|a| 1)

(jonathan:parse <span class="org-string">"{\"a\":1,\"b\":2}"</span> <span class="org-builtin">:as</span> <span class="org-builtin">:alist</span>)
((<span class="org-string">"b"</span> . 2) (<span class="org-string">"a"</span> . 1))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp">(jonathan:parse *address-1* <span class="org-builtin">:as</span> <span class="org-builtin">:jsown</span>)
(<span class="org-builtin">:OBJ</span> (<span class="org-string">"address"</span> . <span class="org-string">"Mount Vernon, Virginia, United States"</span>)
 (<span class="org-string">"birthday"</span> . <span class="org-string">"February 22, 1732"</span>) (<span class="org-string">"name"</span> . <span class="org-string">"George Washington"</span>))
</pre>
</div>
<p>
The result is a cons cell format that appears to have originated with the jsown library.
</p>
</div>
</div>

<div id="outline-container-jonathan-unicode" class="outline-5">
<h5 id="jonathan-unicode">Unicode</h5>
<div class="outline-text-5" id="text-jonathan-unicode">
<p>
Jonathan can parse unicode and escaped unicode characters and can return unicode characters or escaped unicode characters.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jonathan:parse <span class="org-string">"\"\\u30b8\\u30e7\\u30ca\\u30b5\\u30f3\""</span>)
<span class="org-string">"&#12472;&#12519;&#12490;&#12469;&#12531;"</span>

(jonathan:parse <span class="org-string">"\"\\u30b8\\u30e7\\u30ca\\u30b5\\u30f3\""</span>
       <span class="org-builtin">:unescape-unicode-escape-sequence</span> nil)
<span class="org-string">"u30b8u30e7u30cau30b5u30f3"</span>

(jonathan:parse <span class="org-string">"{\"name\": \"&#12472;&#12519;&#12490;&#12469;&#12531;\"}"</span>)
(:|name| <span class="org-string">"&#12472;&#12519;&#12490;&#12469;&#12531;"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-jonathan-filters" class="outline-5">
<h5 id="jonathan-filters">Nested JSON Objects (Filters and Subsets)</h5>
<div class="outline-text-5" id="text-jonathan-filters">
<p>
Jonathan can easily extract a subset of data from the first level of a nested object, but you need to write a recursion method if you need to extract a subset of nested data that is deeper in the JSON object.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(jonathan:parse *nested-address-1* <span class="org-builtin">:keywords-to-read</span> '(<span class="org-string">"first_name"</span>))
(:|first_name| <span class="org-string">"George"</span>)

(jonathan:parse *nested-address-1* <span class="org-builtin">:keywords-to-read</span> '(<span class="org-string">"address"</span>))
(:|address|
  (:|country| <span class="org-string">"United States"</span> :|state| <span class="org-string">"Virginia"</span> :|city| <span class="org-string">"Mount Vernon"</span>
                              :|street_address| <span class="org-string">"3200 Mount Vernon Memorial Highway"</span>))

(jonathan:parse *nested-address-1* <span class="org-builtin">:keywords-to-read</span> '(<span class="org-string">"state"</span>))
nil
</pre>
</div>
</div>
</div>

<div id="outline-container-jonathan-decoding-allow-json-comments" class="outline-5">
<h5 id="jonathan-decoding-allow-json-comments">Allow JSON comment string</h5>
<div class="outline-text-5" id="text-jonathan-decoding-allow-json-comments">
<ul class="org-ul">
<li>can allow junked JSON format string (:junk-allowed t)</li>
<li>can customize <b>null-value</b>, <b>false-value</b> and <b>empty-array-value</b>.</li>
<li>can restrict keywords to read. (:keywords-to-read)</li>
<li>can normalize keywords. (:keyword-normalizer)</li>
<li>can not normalize keywords in nested objects.</li>
<li>can ignore keywords when normalizer returns NIL.</li>
<li>can unescape unicode escape sequences. (:unescape-unicode-escape-sequence)</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-jonathan-encoding" class="outline-4">
<h4 id="jonathan-encoding">Encoding</h4>
<div class="outline-text-4" id="text-jonathan-encoding">
<p>
The basic encoding function is jonathan:to-json. Jonathan can return either a string or octets.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jonathan:to-json '(<span class="org-builtin">:name</span> <span class="org-string">"Common Lisp"</span> <span class="org-builtin">:born</span> 1984 <span class="org-builtin">:impls</span> (SBCL KCL))
         <span class="org-builtin">:octets</span> t)
#(123 34 78 65 77 69 34 58 34 67 111 109 109 111 110 32 76 105 115 112 34 44 34
  66 79 82 78 34 58 49 57 56 52 44 34 73 77 80 76 83 34 58 91 34 83 66 67 76 34
  44 34 75 67 76 34 93 125)
</pre>
</div>

<p>
When encoding alists or plists or jsown "objects", jonathan requires extra keyword parameters like :from :alist (or :plist, :jsown)
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jonathan:to-json '((a 1) (b 2)) <span class="org-builtin">:from</span> <span class="org-builtin">:alist</span>)
<span class="org-string">"{\"A\":[1],\"B\":[2]}"</span>
</pre>
</div>

<p>
While to-json can handle a plist without any additional parameters, to-json will throw an error if handed an alist without warning. This gets resolved by adding the additional keyword parameters :from :alist
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jonathan:to-json '((A . 1) (B . 2) (C . 3)) <span class="org-builtin">:from</span> <span class="org-builtin">:alist</span>)
<span class="org-string">"{\"A\":1,\"B\":2,\"C\":3}"</span>
</pre>
</div>
<p>
Jonathan expects simple-strings, so if your data source does not produce simple strings, you may have to massage the input to get there. Similarly, attempting to encode a char or a pathname will trigger an error. You should be able to methods that would handle them. The same situation arises with respect to encoding structs.
</p>

<p>
Now consider what happens when jonathan tries to encode alists with dotted pairs:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jonathan:to-json '((<span class="org-string">"foo"</span> . <span class="org-string">"bar"</span>) (<span class="org-string">"baz"</span> . ((1 2 3) (4 5 6)))) <span class="org-builtin">:from</span> <span class="org-builtin">:alist</span>)

<span class="org-string">"{\"foo\":\"bar\",\"baz\":{\"1\":[2,3],\"4\":[5,6]}}"</span>
</pre>
</div>
<p>
and now without dotted pairs.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jonathan:to-json '((<span class="org-string">"foo"</span> <span class="org-string">"bar"</span>) (<span class="org-string">"baz"</span>  ((1 2 3) (4 5 6)))) <span class="org-builtin">:from</span> <span class="org-builtin">:alist</span>)
<span class="org-string">"{\"foo\":[\"bar\"],\"baz\":[{\"1\":[2,3],\"4\":[5,6]}]}"</span>
</pre>
</div>
<p>
In both situations, jonathan is trying to force key:value pairs into places you would not expect.
</p>
</div>
<div id="outline-container-jonathan-encoding-clos" class="outline-5">
<h5 id="jonathan-encoding-clos">Encoding Clos</h5>
<div class="outline-text-5" id="text-jonathan-encoding-clos">
<p>
Jonathan can encode CLOS objects to JSON if you create a method for that class. Consider our person class:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defclass</span> <span class="org-type">person</span> ()
    ((name
      <span class="org-builtin">:initarg</span> <span class="org-builtin">:name</span> <span class="org-builtin">:initform</span> <span class="org-string">"Sabra"</span>
      <span class="org-builtin">:accessor</span> name)
     (eye-colour <span class="org-builtin">:initarg</span> <span class="org-builtin">:eye-colour</span>
      <span class="org-builtin">:initform</span> <span class="org-string">"brown"</span>
      <span class="org-builtin">:accessor</span> eye-colour)))
</pre>
</div>
<p>
Creating the required method for this class is straight forward:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmethod</span> <span class="org-function-name">jonathan:%to-json</span> ((person person))
              (<span class="org-keyword">jonathan:with-object</span>
                  (jonathan:write-key-value <span class="org-string">"name"</span> (slot-value person 'name))
                  (jonathan:write-key-value <span class="org-string">"eye-colour"</span> (slot-value person 'eye-colour))))
</pre>
</div>
<p>
That then allows you to write something like this:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((data (make-instance 'person)))
  (jonathan:to-json data))
<span class="org-string">"{\"name\":\"Sabra\",\"eye-colour\":\"brown\"}"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-jonathan-incremental" class="outline-5">
<h5 id="jonathan-incremental">Incremental Encoding</h5>
<div class="outline-text-5" id="text-jonathan-incremental">
<p>
The following examples use two exercises. First, incrementally build a JSON array. Second, incrementally build a JSON object which also contains an incrementally built JSON array.
</p>
<div class="org-src-container">
<pre class="src src-lisp">  (<span class="org-keyword">jonathan:with-output</span> (*standard-output*)
      (<span class="org-keyword">jonathan:with-array</span> ()
        (<span class="org-keyword">dotimes</span> (i 3)
          (jonathan:write-item i))))
[0,1,2]
</pre>
</div>
<p>
The second is also straight forward.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">jonathan:with-output</span> (*standard-output*)
  (<span class="org-keyword">jonathan:with-object</span>
      (jonathan:write-key-value <span class="org-string">"hello"</span> <span class="org-string">"hu hu"</span>)
    (jonathan:write-key <span class="org-string">"harr"</span>)
    (jonathan:write-value
     (<span class="org-keyword">jonathan:with-array</span> ()
       (<span class="org-keyword">dotimes</span> (i 3)
         (jonathan:write-item i))))))
{<span class="org-string">"hello"</span>:<span class="org-string">"hu hu"</span>,<span class="org-string">"harr"</span><span class="org-builtin">:[0</span>,1,2]}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-jonathan-symmetry" class="outline-4">
<h4 id="jonathan-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-jonathan-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, jonathan reversed the order of the list and converted both falsee and null to [].
</p>

<p>
Going from CL-&gt;JSON-&gt;CL, it is not symmetric if the alists have dotted pairs. The array test resulted in getting the array converted into a list and :NULL was converted to nil.
</p>
</div>
</div>
<div id="outline-container-jonathan-security" class="outline-4">
<h4 id="jonathan-security">Security</h4>
<div class="outline-text-4" id="text-jonathan-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data. Jonathan has the first issue.
</p>

<p>
With respect to the second issue, jonathan properly rejected 128 out of 173 malformed test cases. Unfortunately it was one of the packages that accepted malformed JSON data that would trigger stack exhaustion.
</p>
</div>
</div>
<div id="outline-container-jonathan-conformity" class="outline-4">
<h4 id="jonathan-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-jonathan-conformity">
<p>
jonathan accepted 94 of the 95 test cases that are considered "must accept". It signaled an overflow when trying to decode "[123.456e78]".
</p>

<p>
It accepted 9 out of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject. It actually hung when trying to decode the underflow number [123e-10000000].
</p>
</div>
</div>
<div id="outline-container-jonathan-benchmarking" class="outline-4">
<h4 id="jonathan-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-jonathan-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>

<div id="outline-container-jonathan-exported-symbols" class="outline-4">
<h4 id="jonathan-exported-symbols">jonathan exported symbols</h4>
<div class="outline-text-4" id="text-jonathan-exported-symbols">
<ul class="org-ul">
<li><b>%to-json</b> - Write obj as JSON string.</li>
<li><b>%write-char</b> - Write character to *stream*.</li>
<li><b>%write-string</b> - Write string to *stream*.</li>
<li><b>*empty-array-value*</b> - LISP value of [].</li>
<li><b>*empty-object-value*</b> - LISP value of {}.</li>
<li><b>*false-value*</b> - LISP value of false.</li>
<li><b>*from*</b> - Default value of from used by #'to-json.</li>
<li><b>*null-value*</b> - LISP value of null.</li>
<li><b>*octets*</b> - Default value of octets used by #'to-json.</li>
<li><b>&lt;jonathan-error&gt;</b> - Base condition of jonathan-errors.</li>
<li><b>&lt;jonathan-incomplete-json-error&gt;</b></li>
<li><b>&lt;jonathan-not-supported-error&gt;</b></li>
<li><b>&lt;jonathan-unexpected-eof-error&gt;</b></li>
<li><b>&lt;jonathan-without-tail-surrogate-error&gt;</b></li>
<li><b>compile-encoder</b> - Compile encoder</li>
<li><b>parse</b> - Convert JSON String to LISP object.</li>
<li><b>to-json</b> - Convert LISP object to JSON String.</li>
<li><b>with-array</b> - Make writing array safe.</li>
<li><b>with-object</b> - Make writing object safe.</li>
<li><b>with-output</b> - Bind *stream* to stream.</li>
<li><b>with-output-to-string</b> - Output *stream* as string.</li>
<li><b>write-item</b> - Write item of array.</li>
<li><b>write-key</b> - Write key part of object.</li>
<li><b>write-key-value</b> - Write key and value of object.</li>
<li><b>write-value</b> - Write value part of object.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-json-lib" class="outline-3">
<h3 id="json-lib">json-lib</h3>
<div class="outline-text-3" id="text-json-lib">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#json-lib">json-lib</a></td>
<td class="org-left">Alex Nygren</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/KinaKnowledge/json-lib">https://github.com/KinaKnowledge/json-lib</a></td>
<td class="org-left">Not in Quicklisp</td>
</tr>
</tbody>
</table>

<p>
Json-lib describes itself as a simple JSON decoder and encoder which tries to achieve symmetry. It falls a little short when dealing with JSON's false and with unicode char codes. On the plus side, it was one of four libraries to limit depth and avoid stack exhaustion on malformed JSON data. I think it generally does what it was intended for.
</p>
</div>

<div id="outline-container-json-lib-mapping" class="outline-4">
<h4 id="json-lib-mapping">Mapping</h4>
<div class="outline-text-4" id="text-json-lib-mapping">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">JSON</th>
<th scope="col" class="org-left">CL</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">null</td>
<td class="org-left">nil</td>
</tr>

<tr>
<td class="org-left">false</td>
<td class="org-left">nil</td>
</tr>

<tr>
<td class="org-left">true</td>
<td class="org-left">T</td>
</tr>

<tr>
<td class="org-left">integer</td>
<td class="org-left">integer</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">double-float</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">array</td>
<td class="org-left">vector</td>
</tr>

<tr>
<td class="org-left">object</td>
<td class="org-left">hash-table</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-json-lib-decoding" class="outline-4">
<h4 id="json-lib-decoding">Decoding</h4>
<div class="outline-text-4" id="text-json-lib-decoding">
<p>
Json-lib parses utf-8 encoding JSON strings (and not streams). So if you are reading a JSON encoded file, you would need to specify in the input stream conversions that utf-8 be used. E.g.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(json-lib:parse (alexandria:read-file-into-string <span class="org-string">"file.json"</span>
                                                  <span class="org-builtin">:external-format</span> <span class="org-builtin">:utf8</span>))
</pre>
</div>
<p>
As with many of the libraries, it decodes a JSON 'null' as NIL. It also fails to handle unicode surrogate pairs if you care about that.
</p>

<p>
According to the README, the json-lib parser uses whitespace presence, regardless of commas, as a delimiting marker.
</p>
</div>

<div id="outline-container-json-lib-nested-json-objects" class="outline-5">
<h5 id="json-lib-nested-json-objects">Nested JSON Objects</h5>
<div class="outline-text-5" id="text-json-lib-nested-json-objects">
<p>
Json-lib does require that you completely parse the JSON data instead of being able to filter it while taking it in. Taking the nested JSON object below, how could we get a information out of the innermost nested object?
</p>

<div class="org-src-container">
<pre class="src src-json">{
  "items": [
    {
      "index": 1,
      "integer": 29,
      "float": 16.8278,
      "fullname": "Milton Jensen",
      "bool": false
    }
  ]
}
</pre>
</div>
<p>
You need to know your data structure so that you can figure out how to walk the tree. How would we get the value of the key "integer"? Looking at it, it is a JSON object which keyword "items"contains an array which contains a JSON object.
</p>

<p>
By default, json-lib decodes JSON objects to hash-tables and arrays into vectors. So we can descend the parsed JSON tree in this particular example something like this (assuming the JSON object was in a file named json4.txt):
</p>
<div class="org-src-container">
<pre class="src src-lisp">(gethash <span class="org-string">"integer"</span>
         (aref
          (gethash <span class="org-string">"items"</span>
                   (json-lib:parse
                    (alexandria:read-file-into-string #P<span class="org-string">"/home/sabra/json4.txt"</span>)))
          0))

29
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-json-lib-encoding" class="outline-4">
<h4 id="json-lib-encoding">Encoding</h4>
<div class="outline-text-4" id="text-json-lib-encoding">
<p>
Json-lib will encode to strings, not streams. Some idiosyncrasies are noted in the following points:
</p>
<ul class="org-ul">
<li>It encodes keyword symbols, but other symbols get encoded to "null"
<ul class="org-ul">
<li>It encodes a char to "null". You could write a method to handle char</li>
<li>Ratios are encoded as "null"</li>
<li>Attempting to encode a CLOS object or pathname returned "null".</li>
<li>In encoding a hash-table, json-lib will be successful if the hash-table keys are strings or keyword symbols. If the keys are other symbols, the key will be rendered as "null".</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-json-lib-symmetry" class="outline-4">
<h4 id="json-lib-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-json-lib-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, json-lib lost the unicode character in the middle of a string and converted false to null.
</p>

<p>
Going from CL-&gt;JSON-&gt;CL, it took an input of alists and converted it to vectors of vectors with keywords symbols being turned into strings. In the second test it took an array input and the only hiccup was converting :NULL to "null".
</p>
</div>
</div>
<div id="outline-container-json-lib-security" class="outline-4">
<h4 id="json-lib-security">Security</h4>
<div class="outline-text-4" id="text-json-lib-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data.
json-lib did not exhibit the first issue.
</p>

<p>
With respect to the second issue, json-lib rejected 110 out of 173 malformed test cases. It was one of four packages which allowed you to limit the depths to which it would dive in nested json objects and, therefore, did not trigger the stack exhaustion exhibited by most of the other packages.
</p>
</div>
</div>
<div id="outline-container-json-lib-conformity" class="outline-4">
<h4 id="json-lib-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-json-lib-conformity">
<p>
json-lib accepted 95 of the 95 test cases that are considered "must accept".  If *read-default-float-format* is set to 'single-float, it would refuse to accept:  [123e65], [123e45] and [123.456e78].
</p>

<p>
It accepted 12 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>
<div id="outline-container-json-lib-benchmarking" class="outline-4">
<h4 id="json-lib-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-json-lib-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>

<div id="outline-container-json-lib-miscellaneous-comments" class="outline-4">
<h4 id="json-lib-miscellaneous-comments">Miscellaneous Comments</h4>
<div class="outline-text-4" id="text-json-lib-miscellaneous-comments">
<p>
Json-lib has conversion functions lisp-to-snakecase, snakecase-to-lisp and lisp-to-camelcase. These will only be applied to keyword symbols.
</p>
</div>
</div>

<div id="outline-container-json-lib-exported-symbols" class="outline-4">
<h4 id="json-lib-exported-symbols">Json-lib exported symbols</h4>
<div class="outline-text-4" id="text-json-lib-exported-symbols">
<ul class="org-ul">
<li><b>encode-string</b></li>
<li><b>parse</b> - Given an encoded utf-8 JSON string, returns a cl structure or value. If use-keywords-for-keys is T, then hash table keys will be constructed as keywords. If an object-key-handler lambda/function is provided, this will be called for each object key and the result value used for the specific object key. By default the limit is 1000 for structural depth, but this can be set with the keyword max-depth. Exponent representation in serialized form is limited to a length of 2 to prevent huge values causing slow downs and other issues in the conversion process.</li>
<li><b>stringify</b> - Converts the given data structure to a stringified JSON form, suitable for serialization and other uses. An optional function can be passed for case encoding of native lisp keyword structures. If a function for unencodable-items is provided, this function will be called, and should return a JSON compliant string representing the encoded items. If no value is provided for unencodable-items, the JSON null value is used.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-json-streams" class="outline-3">
<h3 id="json-streams">json-streams</h3>
<div class="outline-text-3" id="text-json-streams">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#json-streams">json-streams</a></td>
<td class="org-left">Thomas Bakketun, Stian Sletner</td>
<td class="org-left">GPL3</td>
<td class="org-left"><a href="http://github.com/rotatef/json-streams">http://github.com/rotatef/json-streams</a></td>
</tr>
</tbody>
</table>

<p>
The author describes Json-streams advantages as:
</p>

<ul class="org-ul">
<li>Separation of low-level and high-level functionality. json-streams provides a basic tokenizer for JSON, so that it's easy to build any data structure mapping one wants on top of it. All the other JSON libraries could in theory be built on it. The problem with many of them is that they've chosen a particular data mapping that very often is non-deterministic (False and [] both map to NIL, for example), or simply doesn't suit a particular use case. With JSON-streams you have full control of these things. But it also comes with a high-level API with a chosen mapping so it's ready to use.</li>
<li>The API is streaming, so you don't have to process more than you want to, and you can process files of any size.</li>
<li>Both Unicode and numbers are properly handled.</li>
</ul>

<p>
I am a bit surprised that something like json-streams that advertises itself as designed to be used as a building block for more high level libraries has no doc strings. Fortunately the README appears to be fairly comprehensive. However, after trying it during the course of testing, I am not convinced that it offers flexibility enough to counter the out of the box functionality of many of the other libraries, nor does it offer any speed advantage.
</p>
</div>
<div id="outline-container-json-streams-mapping" class="outline-4">
<h4 id="json-streams-mapping">Default Mapping</h4>
<div class="outline-text-4" id="text-json-streams-mapping">
<p>
This is the default mapping. Do you see a distinct lack of data structures on the CL side? See the discussion under <a href="#json-streams-encoding">Json-streams Encoding</a> for more info.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">JSON</th>
<th scope="col" class="org-left">Lisp</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">true</td>
<td class="org-left">T</td>
</tr>

<tr>
<td class="org-left">false</td>
<td class="org-left">NIL</td>
</tr>

<tr>
<td class="org-left">null</td>
<td class="org-left">:NULL</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">number</td>
<td class="org-left">integer, float or ratio</td>
</tr>

<tr>
<td class="org-left">array</td>
<td class="org-left">(:ARRAY &#x2026; )  (1)</td>
</tr>

<tr>
<td class="org-left">object</td>
<td class="org-left">(:OBJECT (key . value) &#x2026; ) (1)</td>
</tr>
</tbody>
</table>
<p>
(1) This is a cons and not a CLOS object.
</p>
</div>
</div>

<div id="outline-container-json-streams-decoding" class="outline-4">
<h4 id="json-streams-decoding">Decoding</h4>
<div class="outline-text-4" id="text-json-streams-decoding">
<p>
Generally speaking json-streams does what you would expect with respect to decoding. As you might expect, given the name, it can handle either stream or string input. However, consider parsing the two following JSON strings. The first is a JSON object which includes a JSON array and the second is just an array::
</p>
<div class="org-src-container">
<pre class="src src-lisp">(json-streams:json-parse <span class="org-string">"{\"A\":false,\"B\":[false]}"</span>)
(<span class="org-builtin">:OBJECT</span> (<span class="org-string">"A"</span>) (<span class="org-string">"B"</span> <span class="org-builtin">:ARRAY</span> NIL))

(json-streams:json-parse <span class="org-string">"[\"B\",false]"</span>)
(<span class="org-builtin">:ARRAY</span> <span class="org-string">"B"</span> NIL)
</pre>
</div>
<p>
Both of the results are CONS. I do not know what I was expecting, but it probably was not that.
</p>
</div>
</div>

<div id="outline-container-json-streams-encoding" class="outline-4">
<h4 id="json-streams-encoding">Encoding</h4>
<div class="outline-text-4" id="text-json-streams-encoding">
<p>
I found json-streams frustrating when it comes to simple, straightforward encoding. You cannot just pass CL data to it and assume that it will work.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Data</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T</td>
<td class="org-left">true</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">NIL</td>
<td class="org-left">false</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">:null</td>
<td class="org-left">null</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">A (symbol)</td>
<td class="org-left">Error (1)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">"b"</td>
<td class="org-left">"b"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">1</td>
<td class="org-left">1</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">1.2</td>
<td class="org-left">1.2</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">9/17</td>
<td class="org-left">Error (1)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(1 2)</td>
<td class="org-left">Error (1)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">((A . 1))</td>
<td class="org-left">Error (1)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(B 2)</td>
<td class="org-left">Error (1)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">#(1 2 3)</td>
<td class="org-left">Error (1)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(MAKE-INSTANCE 'PERSON)</td>
<td class="org-left">Error (1)</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) A fell through ETYPECASE expression. Wanted one of ((OR STRING REAL) (MEMBER T NIL) (MEMBER :NULL) JSON-STREAMS:JSON-ARRAY JSON-STREAMS:JSON-OBJECT).</li>
</ul>

<p>
So how do you actually use stringify? Well,
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Data</th>
<th scope="col" class="org-left">Result</th>
<th scope="col" class="org-left">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(json-streams:json-stringify '(:array 1 :null t nil))</td>
<td class="org-left">"[1,null,true,false]"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(json-stringify '(:object ("a". 1) ("b" . 2) ("c". 3)))</td>
<td class="org-left">"{\"a\":1,\"b\":2,\"c\":3}"</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(json-stringify '(:object ("a" 1) ("b" 2) ("c" 3)))</td>
<td class="org-left">Error (1)</td>
<td class="org-left">Oops</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) A fell through ETYPECASE expression. Wanted one of ((OR STRING REAL) (MEMBER T NIL) (MEMBER :NULL) JSON-STREAMS:JSON-ARRAY JSON-STREAMS:JSON-OBJECT).</li>
</ul>

<p>
In case you were wondering, json-stringify json-stringify-multiple and JSON-stringify-single are regular functions. You cannot just write a new method to deal with a new datatype. They take a type json-object, json-array or json-string defined as:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">deftype</span> <span class="org-type">json-object</span> ()
  '(cons (member <span class="org-builtin">:object</span>) t))
</pre>
</div>
</div>
<div id="outline-container-json-streams-encoding-hash-tables" class="outline-5">
<h5 id="json-streams-encoding-hash-tables">Encoding Hash Tables</h5>
<div class="outline-text-5" id="text-json-streams-encoding-hash-tables">
<p>
As result, when you want to encode CL data structures, you need to resort to more complicated calls such as the following for dealing with hash tables or similar calls. :
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((data (alexandria:plist-hash-table '(<span class="org-string">"foo"</span> 1 <span class="org-string">"bar"</span> (7 8 9)) <span class="org-builtin">:test</span> #'equal)))
  (<span class="org-keyword">json-streams:with-json-output</span> (nil <span class="org-builtin">:key-encoder</span> #'string-downcase <span class="org-builtin">:indent</span> t)
    (<span class="org-keyword">json-streams:with-json-object</span>
        (json-streams:json-output-member <span class="org-builtin">:my-hash-table</span> data))))

<span class="org-string">"{\"my-hash-table\": {\"foo\": 1,\"bar\": [7,8,9]}}"</span>
</pre>
</div>
<p>
This does not always work and there is no obvious way to just write additional methods dealing with new lisp data types other than to write your own methods which then wrap around lower level json-streams components. This essentially means that dealing with any type of CL data structure requires that you engage in incremental encoding.
</p>
</div>
</div>

<div id="outline-container-json-streams-encoding-arrays" class="outline-5">
<h5 id="json-streams-encoding-arrays">Encoding Arrays</h5>
<div class="outline-text-5" id="text-json-streams-encoding-arrays">
<p>
Encoding arrays is simile to encoding hash-tables (see above).
</p>
</div>
</div>
<div id="outline-container-json-streams-incremental" class="outline-5">
<h5 id="json-streams-incremental">Incremental Encoding</h5>
<div class="outline-text-5" id="text-json-streams-incremental">
<p>
The following examples use two exercises. First, incrementally build a JSON array. Second, incrementally build a JSON object which also contains an incrementally built JSON array.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">json-streams:with-json-output</span> (nil <span class="org-builtin">:key-encoder</span> #'string-downcase <span class="org-builtin">:indent</span> t)
  (<span class="org-keyword">json-streams:with-json-array</span>
      (<span class="org-keyword">dotimes</span> (i 3) (json-streams:json-output-value i))))
<span class="org-string">"[0,1,2]"</span>
</pre>
</div>
<p>
And now the second:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">json-streams:with-json-output</span> (nil <span class="org-builtin">:key-encoder</span> #'string-downcase)
  (<span class="org-keyword">json-streams:with-json-object</span>
      (json-streams:json-output-member <span class="org-string">"hello"</span> <span class="org-string">"hu hu"</span>)
    (<span class="org-keyword">json-streams:with-json-member</span> <span class="org-builtin">:harr</span>
      (<span class="org-keyword">json-streams:with-json-array</span>
          (<span class="org-keyword">dotimes</span> (i 3) (json-streams:json-output-value i))))))
<span class="org-string">"{\"hello\":\"hu hu\",\"harr\":[0,1,2]}"</span>
</pre>
</div>
<p>
The following is a more complicated version from the README:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">with-json-output</span> (nil <span class="org-builtin">:key-encoder</span> #'string-downcase <span class="org-builtin">:indent</span> t)
                 (<span class="org-keyword">with-json-object</span>
                     (json-output-member <span class="org-builtin">:first-name</span> <span class="org-string">"John"</span>)
                   (json-output-member <span class="org-builtin">:last-name</span> <span class="org-string">"Smith"</span>)
                   (<span class="org-keyword">with-json-member</span> <span class="org-builtin">:is-alive</span> (json-output-boolean t))
                   (json-output-member <span class="org-builtin">:age</span> 25)
                   (<span class="org-keyword">with-json-member</span> <span class="org-builtin">:address</span>
                     (json-output-alist '((<span class="org-builtin">:street-address</span> . <span class="org-string">"21 2nd Street"</span>)
                                          (<span class="org-builtin">:city</span> . <span class="org-string">"New York"</span>)
                                          (<span class="org-builtin">:state</span> . <span class="org-string">"NY"</span>)
                                          (<span class="org-builtin">:postal-code</span> . <span class="org-string">"10021-3100"</span>))))
                   (<span class="org-keyword">with-json-member</span> <span class="org-builtin">:phone-numbers</span>
                     (<span class="org-keyword">with-json-array</span>
                         (json-output-plist '(<span class="org-builtin">:type</span> <span class="org-string">"home"</span>
                                              <span class="org-builtin">:number</span> <span class="org-string">"212 555-1234"</span>))
                       (json-output-plist '(<span class="org-builtin">:type</span> <span class="org-string">"office"</span>
                                            <span class="org-builtin">:number</span> <span class="org-string">"646 555-4567"</span>))
                       (json-output-plist '(<span class="org-builtin">:type</span> <span class="org-string">"mobile"</span>
                                            <span class="org-builtin">:number</span> <span class="org-string">"123 456-7890"</span>))))
                   (json-output-member <span class="org-builtin">:children</span> #())
                   (<span class="org-keyword">with-json-member</span> <span class="org-builtin">:spouse</span> (json-output-null))))

<span class="org-string">"{</span>
<span class="org-string">  \"first-name\": \"John\",</span>
<span class="org-string">  \"last-name\": \"Smith\",</span>
<span class="org-string">  \"is-alive\": true,</span>
<span class="org-string">  \"age\": 25,</span>
<span class="org-string">  \"address\": {</span>
<span class="org-string">    \"street-address\": \"21 2nd Street\",</span>
<span class="org-string">    \"city\": \"New York\",</span>
<span class="org-string">    \"state\": \"NY\",</span>
<span class="org-string">    \"postal-code\": \"10021-3100\"</span>
<span class="org-string">  },</span>
<span class="org-string">  \"phone-numbers\": [</span>
<span class="org-string">    {</span>
<span class="org-string">      \"type\": \"home\",</span>
<span class="org-string">      \"number\": \"212 555-1234\"</span>
<span class="org-string">    },</span>
<span class="org-string">    {</span>
<span class="org-string">      \"type\": \"office\",</span>
<span class="org-string">      \"number\": \"646 555-4567\"</span>
<span class="org-string">    },</span>
<span class="org-string">    {</span>
<span class="org-string">      \"type\": \"mobile\",</span>
<span class="org-string">      \"number\": \"123 456-7890\"</span>
<span class="org-string">    }</span>
<span class="org-string">  ],</span>
<span class="org-string">  \"children\": [</span>
<span class="org-string">  ],</span>
<span class="org-string">  \"spouse\": null</span>
<span class="org-string">}"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-json-streams-symmetry" class="outline-4">
<h4 id="json-streams-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-json-streams-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, json-streams had no issues.
</p>

<p>
Going from CL-&gt;JSON-&gt;CL, it failed (as you might expect) with both the alist input and the vector input because you would need to write a new method for dealing with either one.
</p>
</div>
</div>
<div id="outline-container-json-streams-security" class="outline-4">
<h4 id="json-streams-security">Security</h4>
<div class="outline-text-4" id="text-json-streams-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data. json-streams did not exhibit the first issue.
</p>

<p>
With respect to the second issue, json-streams rejected all 173 malformed test cases. It was one of four packages which allowed you to limit the depths to which it would dive in nested JSON objects and, therefore, did not trigger the stack exhaustion exhibited by most of the other packages.
</p>
</div>
</div>
<div id="outline-container-json-streams-conformity" class="outline-4">
<h4 id="json-streams-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-json-streams-conformity">
<p>
Without additional parameters, json-streams accepted 93 of 95 test cases that are considered "must accept". The rejected test cases were files with duplicate keys and those would have been accepted by passing the keyword parameter :duplicate-key-check nil.
</p>

<p>
It accepted 1 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>
<div id="outline-container-json-streams-benchmarking" class="outline-4">
<h4 id="json-streams-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-json-streams-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>

<div id="outline-container-json-streams-exported-symbols" class="outline-4">
<h4 id="json-streams-exported-symbols">json-streams exported symbols</h4>
<div class="outline-text-4" id="text-json-streams-exported-symbols">
<p>
As mentioned above, there are no doc-strings for json-streams' exported symbols.
</p>
<ul class="org-ul">
<li>call-with-json-output</li>
<li>json-array</li>
<li>json-close</li>
<li>json-error</li>
<li>json-input-stream</li>
<li>json-object</li>
<li>json-output-alist</li>
<li>json-output-boolean</li>
<li>json-output-member</li>
<li>json-output-null</li>
<li>json-output-plist</li>
<li>json-output-stream</li>
<li>json-output-value</li>
<li>json-parse</li>
<li>json-parse-error</li>
<li>json-parse-multiple</li>
<li>json-read</li>
<li>json-stream</li>
<li>json-stream-position</li>
<li>json-string</li>
<li>json-stringify</li>
<li>json-stringify-multiple</li>
<li>json-write</li>
<li>json-write-error</li>
<li>make-json-input-stream</li>
<li>make-json-output-stream</li>
<li>most-negative-json-integer</li>
<li>most-positive-json-integer</li>
<li>with-json-array</li>
<li>with-json-member</li>
<li>with-json-object</li>
<li>with-json-output</li>
<li>with-open-json-stream</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-jsown" class="outline-3">
<h3 id="jsown">jsown</h3>
<div class="outline-text-3" id="text-jsown">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#jsown">jsown</a></td>
<td class="org-left">Aad Versteden</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/madnificent/jsown">https://github.com/madnificent/jsown</a></td>
</tr>
</tbody>
</table>

<p>
Yes, it is the fastest in pure decoding but speed is not everything. It has optimize set for safety 0 to increase speed. This has bitten some users hard in the past, so you have been warned. You do have to be careful about what data structures you use. For example, encoding dotted alists triggered memory fault issues. It fails to deal with JSON's null properly and actually hung when trying to decode a JSON real number with an underflow problem.
</p>

<p>
On the plus side, it has the ability to extract a subset out of a JSON string, but you have to have read the entire string since it does not deal with streams.
</p>
</div>

<div id="outline-container-jsown-mapping" class="outline-4">
<h4 id="jsown-mapping">Default Mappping</h4>
<div class="outline-text-4" id="text-jsown-mapping">
<p>
Please note the direction of the arrows in the following table.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lisp</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">integer</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with no frac or exp parts</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">rational</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">ratio</td>
<td class="org-left">&lt;-</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">true</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">nil</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-</td>
<td class="org-left">false</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-</td>
<td class="org-left">[]</td>
</tr>

<tr>
<td class="org-left">other symbol</td>
<td class="org-left">-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">character</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">list (except alists)</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">cons</td>
<td class="org-left">&lt;-</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">vector</td>
<td class="org-left">-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">alist w/o dotted pairs</td>
<td class="org-left">-&gt;</td>
<td class="org-left">array of arrays</td>
</tr>

<tr>
<td class="org-left">alist with dotted pairs</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">hash-table</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">standard object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-jsown-decoding" class="outline-4">
<h4 id="jsown-decoding">Decoding</h4>
<div class="outline-text-4" id="text-jsown-decoding">
<p>
This is where jsown really shines. Jsown is by far the fastest decoder. It not only decodes, it also makes it easy to pull out elements of the json-object (at least at the first level of the object).
</p>

<p>
One thing that was interesting was that jsown is the only library to decode JSON floats to CL ratios.
</p>

<p>
As a minor annoyance, parsing strings that have form feeds get translated to line feeds.
</p>

<p>
When reading JSON objects, jsown converts their content to the most lispy translation of what was in there. As such, JSON's false will be translated to nil, which coincidentally also be the translation of JSON's []. JSON's null is also translated to nil.
</p>

<p>
As you can tell from the default mapping table, JSON arrays are decoded to lists and JSON objects decoded to cons cells:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:parse <span class="org-string">"[1, \"a\"]"</span>)
(1 <span class="org-string">"a"</span>)

(jsown:parse <span class="org-string">"{\"foo\": \"alpha\", \"bar\":3.2}"</span>)
(<span class="org-builtin">:OBJ</span> (<span class="org-string">"foo"</span> . <span class="org-string">"alpha"</span>) (<span class="org-string">"bar"</span> . 16/5))
</pre>
</div>
</div>

<div id="outline-container-jsown-filters" class="outline-5">
<h5 id="jsown-filters">Nested JSON Objects (Filters and Subsets)</h5>
<div class="outline-text-5" id="text-jsown-filters">
<p>
Now consider the nested JSON object *nested-address-1*. Again, as a reminder, here is the object.
</p>

<div class="org-src-container">
<pre class="src src-json">"{
  \"first_name\": \"George\",
  \"last_name\": \"Washington\",
  \"birthday\": \"1732-02-22\",
  \"address\": {
    \"street_address\": \"3200 Mount Vernon Memorial Highway\",
    \"city\": \"Mount Vernon\",
    \"state\": \"Virginia\",
    \"country\": \"United States\"
  }
}"
</pre>
</div>
<p>
What can we do with it in jsown? It is a JSON object which keyword "address"contains another JSON object.
</p>

<p>
A basic call to parse returns a cons representing the entire object
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:parse *nested-address-1*)
(<span class="org-builtin">:OBJ</span> (<span class="org-string">"first_name"</span> . <span class="org-string">"George"</span>) (<span class="org-string">"last_name"</span> . <span class="org-string">"Washington"</span>)
 (<span class="org-string">"birthday"</span> . <span class="org-string">"1732-02-22"</span>)
 (<span class="org-string">"address"</span> <span class="org-builtin">:OBJ</span> (<span class="org-string">"street_address"</span> . <span class="org-string">"3200 Mount Vernon Memorial Highway"</span>)
  (<span class="org-string">"city"</span> . <span class="org-string">"Mount Vernon"</span>) (<span class="org-string">"state"</span> . <span class="org-string">"Virginia"</span>)
  (<span class="org-string">"country"</span> . <span class="org-string">"United States"</span>)))
</pre>
</div>
<p>
If we add the keyword address, we get back a subset of the object:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:parse *nested-address-1* <span class="org-string">"address"</span>)
(<span class="org-builtin">:OBJ</span>
 (<span class="org-string">"address"</span> <span class="org-builtin">:OBJ</span> (<span class="org-string">"street_address"</span> . <span class="org-string">"3200 Mount Vernon Memorial Highway"</span>)
  (<span class="org-string">"city"</span> . <span class="org-string">"Mount Vernon"</span>) (<span class="org-string">"state"</span> . <span class="org-string">"Virginia"</span>)
  (<span class="org-string">"country"</span> . <span class="org-string">"United States"</span>)))
</pre>
</div>
<p>
According to the README, "In order to achieve high performance when parsing specific keywords, the keywords to be found should be known at compile time. The compiler-macro-function can calculate the keyword container with the requested keywords at compile-time. When specifying the keywords in which you’re interested you should ignore any escaped characters. For instance, supplying the string “foo” will automatically match “f\\\\oo” too."
</p>

<p>
We can walk the tree deeper by applying the filter and val functions.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:val
 (jsown:filter
  (jsown:parse *nested-address-1*)
  <span class="org-string">"address"</span>)
 <span class="org-string">"city"</span>)
<span class="org-string">"Mount Vernon"</span>
</pre>
</div>
<p>
Jsown has the ability, once a JSON object has been parsed into a jsown object, to get the first level keywords of the object.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:keywords (jsown:parse *nested-address-1*))
(<span class="org-string">"first_name"</span> <span class="org-string">"last_name"</span> <span class="org-string">"birthday"</span> <span class="org-string">"address"</span>)
</pre>
</div>
<p>
Jsown also has the ability to loop over the first level keywords of an object:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">jsown:do-json-keys</span> (keyword value)
  (jsown:parse *nested-address-1*)
  (format t <span class="org-string">"~a =&gt; ~a~%"</span> keyword value))

first_name =&gt; George
last_name =&gt; Washington
birthday =&gt; 1732-02-22
address =&gt; (OBJ (street_address . 3200 Mount Vernon Memorial Highway)
            (city . Mount Vernon) (state . Virginia) (country . United States))
</pre>
</div>
<p>
On the downside, jsown actually hung when trying to decode an underflow number: "[123e-10000000]".
</p>
</div>
</div>
</div>

<div id="outline-container-jsown-encoding" class="outline-4">
<h4 id="jsown-encoding">Encoding</h4>
<div class="outline-text-4" id="text-jsown-encoding">
<p>
(to-json x) is a generic function which you can specialize on your own types. This allows you to nest lisp objects in a jsown object and serialize them in a suitable way.
</p>

<p>
(to-json* x) is the non-generic function variant of the same thing. It isn't as smart, but it is faster.
</p>

<p>
Encoding chars, pathnames, CLOS objects, structs and other data structures not listed in the default mapping above will require that you write a new to-json method to handle that particular datatype.
</p>

<p>
On the plus side, jsown is the one of the two libraries (the other is shasht) which can handle multi-dimensional arrays
</p>

<p>
When writing to JSON, lisp's nil is translated to the empty JSON list []. You can write JSON's false by writing lisp's keywords :false or :f.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:to-json (jsown:new-js (<span class="org-string">"items"</span> nil) (<span class="org-string">"falseIsEmptyList"</span> <span class="org-builtin">:f</span>) (<span class="org-string">"success"</span> t)))

<span class="org-string">"{\"items\":[],\"falseIsEmptyList\":false,\"success\":true}"</span>
</pre>
</div>
<p>
As you can tell from the default mapping table, lists and vectors are automatically encoded to JSON arrays and hash-tables are encoded to JSON objects. As alists are considered lists of lists, an alist will return an array of arrays. Plists are treated the same as plain lists and will lose their key-value connections.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:to-json '((<span class="org-string">"a"</span> <span class="org-string">"alpha"</span>) (<span class="org-string">"b"</span> <span class="org-string">"beta"</span>)))
<span class="org-string">"[[\"a\",\"alpha\"],[\"b\",\"beta\"]]"</span>
</pre>
</div>
<p>
You can specify that JSON returns an object.  The following call to to-json wraps the alist in another list headed by :obj and returns a JSON object.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(jsown:to-json '(<span class="org-builtin">:obj</span> ((<span class="org-string">"a"</span> <span class="org-string">"alpha"</span>) (<span class="org-string">"b"</span> <span class="org-string">"beta"</span>))))
 <span class="org-string">"{\"(a alpha)\":[[\"b\",\"beta\"]]}"</span>
</pre>
</div>
<p>
If jsown tries to encode an alist which has dotted cons cells, jsown triggered unhandled memory faults with SBCL 2.1.11-x86-64-linux, CCL version 1.12.1 LinuxX8664 and ecl-version 21.2.1. This appears to be because jsown has optimized the code and assumed that all lists will be proper lists. The assumption obviously fails in the context of dotted cons cells.
</p>

<p>
When to-json is called, jsown will internally call to-json each step of the way. This has a performance downside, yet it seems to provide the least surprises in the output. If you need more performance, jsown* offers that, at the cost of flexibility.
</p>

<p>
If you are constructing JSON objects, consider using the jsown:new-js and jsown:extend-js functions.jsown:js-new has a clean and clear interface for building content. It works together with jsown:extend-js if you need to split up the object creation.
</p>

<p>
Jsown has a setf-expander on (setf jsown:val) which automatically creates a jsown-object if no such object was available at the designated place. An example should clarify:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> (doc)
  (setf (jsown:val (jsown:val (jsown:val doc <span class="org-string">"properties"</span>) <span class="org-string">"color"</span>) <span class="org-string">"paint"</span>) <span class="org-string">"red"</span>)
  (jsown:to-json doc))

<span class="org-string">"{\"properties\":{\"color\":{\"paint\":\"red\"}}}"</span>
</pre>
</div>

<p>
It turns out to be a handy little feature when you need to build deeply nested JSON documents.
</p>
</div>
<div id="outline-container-jsown-encoding-clos" class="outline-5">
<h5 id="jsown-encoding-clos">Encoding CLOS</h5>
<div class="outline-text-5" id="text-jsown-encoding-clos">
<p>
Jsown does not have a handy ability to automagically encode clos classes. For that you would have to write your own jsown:to-json method. Taking our simple person class with slots name and eye-colour, such a method could look something like this:
</p>
<div class="org-src-container">
<pre class="src src-lisp">  (<span class="org-keyword">defmethod</span> <span class="org-function-name">jsown:to-json</span> ((object person))
    (jsown:to-json
     `(<span class="org-builtin">:obj</span> (<span class="org-string">"name"</span> . ,(name object))
            (<span class="org-string">"eye-colour"</span> . ,(eye-colour object)))))

(jsown:to-json (make-instance 'person))
<span class="org-string">"{\"name\":\"Sabra\",\"eye-colour\":\"brown\"}"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-jsown-incremental" class="outline-5">
<h5 id="jsown-incremental">Incremental Encoding</h5>
<div class="outline-text-5" id="text-jsown-incremental">
<p>
The following examples use two exercises. First, incrementally build a JSON array. Second, incrementally build a JSON object which also contains an incrementally built JSON array. With jsown, I found using loop easier than dotimes.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:to-json
 (<span class="org-keyword">loop</span> <span class="org-builtin">:for</span> i <span class="org-builtin">:from</span> 0 <span class="org-builtin">:to</span> 2 <span class="org-builtin">:collect</span> i))
<span class="org-string">"[0,1,2]"</span>
</pre>
</div>
<p>
The second exercise
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:to-json
 `(<span class="org-builtin">:obj</span>
   (<span class="org-string">"hello"</span> . <span class="org-string">"hu hu"</span>)
   (<span class="org-string">"harr"</span> .
           ,(<span class="org-keyword">loop</span> <span class="org-builtin">:for</span> i <span class="org-builtin">:from</span> 0 <span class="org-builtin">:to</span> 2 <span class="org-builtin">:collect</span> i))))
<span class="org-string">"{\"hello\":\"hu hu\",\"harr\":[0,1,2]}"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-jsown-symmetry" class="outline-4">
<h4 id="jsown-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-jsown-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, jsown had no issues except for dealing with false and null.
</p>

<p>
Going from CL-&gt;JSON-&gt;CL was more problematic. Keyword symbols became strings, :NULL became nil, a float was converted to a ratio and where the input started as an array, it returned a list.
</p>
</div>
</div>
<div id="outline-container-jsown-security" class="outline-4">
<h4 id="jsown-security">Security</h4>
<div class="outline-text-4" id="text-jsown-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data. Jsown did not exhibit the first issue. With respect to the second issue, jsown rejected 102 out of 173 malformed test cases. Unfortunately some of those malformed JSON data strings did trigger the stack exhaustion exhibited by most of the other packages.
</p>
</div>
</div>
<div id="outline-container-jsown-conformity" class="outline-4">
<h4 id="jsown-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-jsown-conformity">
<p>
jsown accepted 93 of the 95 test cases that are considered "must accept". It failed on lonely numbers (an integer or negative real not within a JSON array or JSON object).
</p>

<p>
It accepted 9 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>
<div id="outline-container-jsown-benchmarking" class="outline-4">
<h4 id="jsown-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-jsown-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>

<div id="outline-container-jsown-miscellaneous" class="outline-4">
<h4 id="jsown-miscellaneous">Miscellaneous</h4>
<div class="outline-text-4" id="text-jsown-miscellaneous">
<p>
Issue 27 on GitHub claims an unhandled memory fault on the following bad JSON string in SBCL 2.0.8, but I do not see that with CCL, clisp or SBCL 2.1.11, so this issue may have been fixed.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(jsown:parse <span class="org-string">"{\"foo\": a}"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-jsown-exported-symbols" class="outline-4">
<h4 id="jsown-exported-symbols">jsown exported symbols</h4>
<div class="outline-text-4" id="text-jsown-exported-symbols">
<ul class="org-ul">
<li><b>*parsed-empty-list-value*</b> - value to emit when parsing a JSON empty list '[]'</li>
<li><b>*parsed-false-value*</b> - value to emit when parsing JSON's 'false'</li>
<li><b>*parsed-null-value*</b> - value to emit when parsing JSON's 'null'</li>
<li><b>*parsed-true-value*</b> - value to emit when parsing JSON's 'true'</li>
<li><b>as-js-bool</b> - returns &lt;value&gt; as a boolean value (in jsown format)</li>
<li><b>as-js-null</b> - returns &lt;value&gt; with nil being javascript's null (in jsown format).</li>
<li><b>build-key-container</b> - Builds an internal structure to speed up the keywords which you can read. This should be used when the keywords needed are not known at compiletime, but you still want to parse those keywords of a lot of documents.</li>
<li><b>do-json-keys</b> - Macro - Iterates over the JSON key-value pairs</li>
<li><b>empty-object</b> - Returns an empty object which can be used to build new objects upon</li>
<li><b>extend-js</b> - Macro - fills in a bunch of jsown values for obj.  each spec should contain a list with the first element being the string which represents the key and the second being the form which evaluates to the value to which the key should be set</li>
<li><b>filter</b> - Fancy filtering for jsown-parsed objects. spec can be one of the following:
<ul class="org-ul">
<li>[object] key to find.  will transform into (jsown:val value key)</li>
<li>[cl:map] use this modifier with an [object] modifier after it, to filter all elements in the list.</li>
</ul></li>
<li><b>json-encoded-content</b> - escribes a JSON object whos content is serialized already</li>
<li><b>keyp</b> - Returns non-nil iff &lt;object&gt; has key &lt;key&gt;</li>
<li><b>keywords</b> - Returns a list of all the keywords contained in the object</li>
<li><b>new-js</b> - Macro - creates a new empty object and fills it is per jsown-values</li>
<li><b>parse</b> - Reads a JSON object from the given string, with the given keywords being the keywords which are fetched from the object. All parse functions assume &lt;string&gt; is not an empty JSON object.  (string/= string \"{}\")</li>
<li><b>parse-with-container</b> - Parses the keywords which have been specified in the container from the  JSON string json-string. For most cases you can just use the parse function without a special key container. This is only here to support some cases where the building of the key container takes too much time. See #'parse for the normal variant. See #'build-key-container for a way to build new keyword containers.</li>
<li><b>remkey</b> - Removes key from object</li>
<li><b>to-json</b> - Writes the given object to JSON in a generic way.</li>
<li><b>to-json*</b> - Converts an object in internal jsown representation to a string containing the JSON representation</li>
<li><b>val</b> - Returns the value of the given key in object</li>
<li><b>val-safe</b> - Returns the value of &lt;key&gt; in &lt;object&gt; if &lt;object&gt; existed, or nil if it did not. A second value is returned which indicates whether or not the key was found.</li>
<li><b>with-injective-reader</b> - Rebinds *parsed-<b>-value</b> so that reading JSON documents is injective and converting them back to JSON yields roughly the same document as the original. Rebinds: *parsed-true-value* =&gt; :true,  *parsed-false-value* =&gt; :false,  *parsed-null-value* =&gt; :null</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-shasht" class="outline-3">
<h3 id="shasht">shasht</h3>
<div class="outline-text-3" id="text-shasht">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#shasht">shasht</a></td>
<td class="org-left">Tarn W. Burton</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/yitzchak/shasht">https://github.com/yitzchak/shasht</a></td>
</tr>
</tbody>
</table>

<p>
Shasht is one of the two new libraries that I particularly like. It is fast, it handles null correctly, it encodes CLOS objects, structures and hash-tables. It can also do incremental encoding.
</p>
</div>

<div id="outline-container-shasht-mapping" class="outline-4">
<h4 id="shasht-mapping">Default Mappping</h4>
<div class="outline-text-4" id="text-shasht-mapping">
<p>
Please note the direction of the arrows in the following table.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lisp</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">integer</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with no frac or exp parts</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">rational</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">ratio</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">true</td>
</tr>

<tr>
<td class="org-left">:true</td>
<td class="org-left">-&gt;</td>
<td class="org-left">true</td>
</tr>

<tr>
<td class="org-left">:false</td>
<td class="org-left">-&gt;</td>
<td class="org-left">false</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">false</td>
</tr>

<tr>
<td class="org-left">:NULL</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">#()</td>
<td class="org-left">&lt;-</td>
<td class="org-left">[]</td>
</tr>

<tr>
<td class="org-left">other symbol</td>
<td class="org-left">-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">character</td>
<td class="org-left">-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">pathname</td>
<td class="org-left">-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">list (except alists)</td>
<td class="org-left">-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">vector</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">multi-dimensional array</td>
<td class="org-left">-&gt;</td>
<td class="org-left">nested array</td>
</tr>

<tr>
<td class="org-left">alist</td>
<td class="org-left">-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">hash-table</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">standard object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">structure</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">:empty-array</td>
<td class="org-left">-&gt;</td>
<td class="org-left">[]</td>
</tr>

<tr>
<td class="org-left">:empty-object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">{}</td>
</tr>

<tr>
<td class="org-left">'(:array 1 2 3)</td>
<td class="org-left">-&gt;</td>
<td class="org-left">[1,2,2]</td>
</tr>

<tr>
<td class="org-left">'(:object-alist ("a" . 1)("b" . 2))</td>
<td class="org-left">-&gt;</td>
<td class="org-left">{"a":1,"b":2}</td>
</tr>

<tr>
<td class="org-left">'(:object-plist "a" 1 "b" 2)</td>
<td class="org-left">-&gt;</td>
<td class="org-left">{"a":1,"b":2}</td>
</tr>
</tbody>
</table>

<p>
The following subsections are from the README:
</p>
</div>
<div id="outline-container-shasht-mapping-number-types" class="outline-5">
<h5 id="shasht-mapping-number-types">Mapping of Number Types</h5>
<div class="outline-text-5" id="text-shasht-mapping-number-types">
<p>
The format of a number read from JSON when a decimal or an exponent is present
in the number literal can be influenced with cl:*read-default-float-format*.
This is the same behavior of cl:read. In order to read JSON numbers with large
exponents one would need do something like the following.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(shasht:read-json <span class="org-string">"[2.232e75]"</span> <span class="org-builtin">:float-format</span> 'double-float)
</pre>
</div>
</div>
</div>

<div id="outline-container-shasht-mapping-array-types" class="outline-5">
<h5 id="shasht-mapping-array-types">Mapping of Array Types</h5>
<div class="outline-text-5" id="text-shasht-mapping-array-types">
<p>
The dynamic variables *read-default-array-format*,
*write-empty-array-values*, and *write-array-tags* all influence the mapping
of JSON arrays to Common Lisp vectors and lists. Common Lisp vectors and
multi-dimensional arrays are always writen as JSON arrays. By default JSON
arrays are read as Common Lisp vectors. With the default settings only non-nil
lists that don't satisfy some other mapping rule are written as JSON arrays.
</p>

<p>
If one wants to use lists as the default JSON array format then
*read-default-false-value*, *read-default-array-format*, and
*write-false-value* will need to need to be set to appropriate values since
in the default mapping nil maps to false. For example, the following
could be done.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((shasht:*read-default-false-value* <span class="org-builtin">:false</span>)
      (shasht:*read-default-array-format* <span class="org-builtin">:list</span>)
      (shasht:*write-false-values* '(<span class="org-builtin">:false</span>)))
 (shasht:read-json ...)
 (shasht:write-json ...))
</pre>
</div>

<p>
Lists with a CAR eql to a value in *write-array-tags*,
*write-object-alist-tags*, *write-object-plist-tags* will still be written
as an array or object as appropriate. To completely disable this behavior the
variables would need to be bound to nil. Or one could do the following.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(shasht:write-json '(1 2 3) <span class="org-builtin">:false-value</span> '(<span class="org-builtin">:false</span>) <span class="org-builtin">:array-tags</span> nil
                            <span class="org-builtin">:object-alist-tags</span> nil <span class="org-builtin">:object-plist-tags</span> nil)
</pre>
</div>

<p>
In this case the mapping for array types would become:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Common Lisp</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">vector</td>
<td class="org-left">-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">multi-dimensional array</td>
<td class="org-left">-&gt;</td>
<td class="org-left">nested array</td>
</tr>

<tr>
<td class="org-left">list</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">array</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-shasht-mapping-object-types" class="outline-5">
<h5 id="shasht-mapping-object-types">Mapping of Object Types</h5>
<div class="outline-text-5" id="text-shasht-mapping-object-types">
<p>
The dynamic variables *read-default-object-format*, *write-alist-as-object*,
*write-plist-as-object*, *write-empty-object-values*,
*write-object-alist-tags*, and *write-object-plist-tags* all influence the
mapping of JSON objects to Common Lisp hash tables, alists, and plists. Common
Lisp hash tables are always written as JSON objects. By default JSON objects are
read as Common Lisp hash tables.
</p>

<p>
In order to use alists as the default JSON object format the dynamic variables
*read-default-object-format*, *write-alist-as-object*,
*read-default-false-value*, and *write-false-values* will need to be set
to appropriate values. For example, the following would use alists as the
default JSON object format and :false as the JSON false value.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((shasht:*read-default-object-format* <span class="org-builtin">:alist</span>)
      (shasht:*write-alist-as-object* t)
      (shasht:*read-default-false-value* <span class="org-builtin">:false</span>)
      (shasht:*write-false-values* '(<span class="org-builtin">:false</span>)))
 (shasht:read-json ...)
 (shasht:write-json ...))
</pre>
</div>

<p>
In this case the mapping for object types would become:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Common Lisp</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">hash table</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">alist</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">standard object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">structure object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>
</tbody>
</table>

<p>
The same could be accomplished for plists by doing the following.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((shasht:*read-default-object-format* <span class="org-builtin">:plist</span>)
      (shasht:*write-plist-as-object* t)
      (shasht:*read-default-false-value* <span class="org-builtin">:false</span>)
      (shasht:*write-false-values* '(<span class="org-builtin">:false</span>)))
 (shasht:read-json ...)
 (shasht:write-json ...))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-shasht-decoding" class="outline-4">
<h4 id="shasht-decoding">Decoding</h4>
<div class="outline-text-4" id="text-shasht-decoding">
<p>
To quote from the README:
The primary interface to parsing and reading JSON is the read-json function.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(read-json <span class="org-type">&amp;optional</span> input-stream-or-string (eof-error-p t) eof-value single-value-p)
</pre>
</div>
<p>
The argument input-stream-or-string can be an stream, a string to read from, or nil to use *standard-input*. The arguments eof-error-p and eof-value have the same affect as they do in the CL function read. If the single-value-p argument is true then the input to read-json is assumed to be a single value, which means that extra tokens at the end will cause an error to be generated.
</p>

<p>
There are a number of dynamic variables that will influence the parsing of JSON data.
</p>

<ul class="org-ul">
<li>common-lisp:*read-default-float-format* — Controls the floating-point format that is to be used when reading a floating-point number.</li>
<li>*read-default-true-value* — The default value to return when reading a true token. Initially set to t.</li>
<li>*read-default-false-value* — The default value to return when reading a false token. Initially set to nil.</li>
<li>*read-default-null-value* — The default value to return when reading a null token. Initially set to :null.</li>
<li>*read-default-array-format* — The default format to use when reading an array. Current supported formats are :vector or :list. Initially set to :vector.</li>
<li>*read-default-object-format* — The default format to use when reading an object. Current supported formats are :hash-table, :alist or :plist. Initially set to :hash-table.</li>
</ul>

<p>
There is also a keyword variant read-json* which will set the various dynamic variables from supplied keywords.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(read-json* <span class="org-builtin">:stream</span> nil
            <span class="org-builtin">:eof-error</span> t
            <span class="org-builtin">:eof-value</span> nil
            <span class="org-builtin">:single-value</span> nil
            <span class="org-builtin">:true-value</span> t
            <span class="org-builtin">:false-value</span> nil
            <span class="org-builtin">:null-value</span> <span class="org-builtin">:null</span>
            <span class="org-builtin">:array-format</span> <span class="org-builtin">:vector</span>
            <span class="org-builtin">:object-format</span> <span class="org-builtin">:hash-table</span>
            <span class="org-builtin">:float-format</span> 'single-float)
</pre>
</div>
</div>
</div>

<div id="outline-container-shasht-encoding" class="outline-4">
<h4 id="shasht-encoding">Encoding</h4>
<div class="outline-text-4" id="text-shasht-encoding">
<p>
The primary interface to serializing and writing JSON is the write-json function.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(write-json value <span class="org-type">&amp;optional</span> (output-stream t))
</pre>
</div>

<p>
On the plus side, shasht was one of two libraries which could encode a pathname or a struct. It also is one of the few libraries that can encode CLOS objects out of the box:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(shasht:write-json (make-instance 'person))
{
  <span class="org-string">"NAME"</span>: <span class="org-string">"Sabra"</span>,
  <span class="org-string">"EYE-COLOUR"</span>: <span class="org-string">"brown"</span>
}
</pre>
</div>
<p>
Local-time:timestamps were encoded as {"DAY": 7990,  "SEC": 0,  "NSEC": 0}, so if you wanted them to be in any particular javascript time representation, you would have to write a specialized method.
</p>

<p>
As you might expect, plists are treated the same as plain lists and will lose their key-value connections. If you want to use plists, you will need to convert to a hash table first.
</p>

<p>
There are a number of dynamic variables that will influence the serialization of JSON data.
</p>

<ul class="org-ul">
<li>common-lisp:*print-pretty* — If true then a simple indentation algorithm will be used.</li>
<li>*write-indent-string* — The string to use when indenting objects and arrays. Initially set to #\space.</li>
<li>*write-ascii-encoding* — If true then any non ASCII values will be encoded using Unicode escape sequences. Initially set to nil.</li>
<li>*write-true-values* — Values that will be written as a true token. Initially set to '(t :true).</li>
<li>*write-false-values* — Values that will be written as a false token. Initially set to '(nil :false).</li>
<li>*write-null-values* — Values that will be written as a null token. Initially set to (:null).</li>
<li>*write-alist-as-object* — If true then undotted assocation lists will be written as an object. Initially set to nil.</li>
<li>*write-plist-as-object* — If true then property lists will be written as an object. Initially set to nil.</li>
</ul>

<p>
Consider the following:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf common-lisp:*print-pretty* nil)
(shasht:write-json '((<span class="org-string">"foo"</span> . <span class="org-string">"bar"</span>) (<span class="org-string">"baz"</span> . ((1 2 3) (4 5 6)))))
[[<span class="org-string">"foo"</span><span class="org-comment">; Evaluation aborted on #&lt;TYPE-ERROR expected-type: LIST datum: "bar"&gt;.</span>
</pre>
</div>
<p>
Now if we set shasht:*write-alist-as-object* t,
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf common-lisp:*print-pretty* nil)
(setf shasht:*write-alist-as-object* t)
(shasht:write-json '((<span class="org-string">"foo"</span> . <span class="org-string">"bar"</span>) (<span class="org-string">"baz"</span> . ((1 2 3) (4 5 6)))))

{<span class="org-string">"foo"</span>:<span class="org-string">"bar"</span>,<span class="org-string">"baz"</span><span class="org-builtin">:{1:[2</span>,3],4:[5,6]}}
</pre>
</div>

<p>
The actual serialization of JSON data is done by the generic function print-json-value which can be specialized for additional value types.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(print-json-value value output-stream)
</pre>
</div>
<p>
There is also a keyword variant write-json* which will set the various dynamic variables from supplied keywords.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(write-json* value <span class="org-builtin">:stream</span> t
                   <span class="org-builtin">:ascii-encoding</span> nil
                   <span class="org-builtin">:true-values</span> '(t <span class="org-builtin">:true</span>)
                   <span class="org-builtin">:false-values</span> '(nil <span class="org-builtin">:false</span>)
                   <span class="org-builtin">:null-values</span> '(<span class="org-builtin">:null</span>)
                   <span class="org-builtin">:empty-array-values</span> '(<span class="org-builtin">:empty-array</span>)
                   <span class="org-builtin">:empty-object-values</span> '(<span class="org-builtin">:empty-object</span>)
                   <span class="org-builtin">:alist-as-object</span> nil
                   <span class="org-builtin">:plist-as-object</span> nil
                   <span class="org-builtin">:pretty</span> nil
                   <span class="org-builtin">:indent-string</span> <span class="org-string">"  "</span>)

</pre>
</div>
<p>
In order to facilitate extending the serialization facilities of shasht there are a number of helper functions available. To aid in the printing of JSON strings there is the following.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(write-json-string value output-stream)
</pre>
</div>
<p>
In order to ease the serialization of objects and arrays there is with-json-object and with-json-array. Both of these macros take an output stream as the first argument then enable indentation and automatic handling of all delimiter tokens. Inside the body of with-json-object the function (print-json-key-value key value output-stream) should be used to output a key value pair. Inside the body of with-json-array the function (print-json-value value output-stream) should be used to output a single value. Example usage can be seen in the source code.
</p>
</div>
<div id="outline-container-orgb13671d" class="outline-5">
<h5 id="orgb13671d">Encoding Objects</h5>
<div class="outline-text-5" id="text-orgb13671d">
<p>
Shasht actually uses the :type of each slot to determine what to do with nil. Consider the following where two slots have no specified type, two have a list type and two have an array type:
</p>
<div class="org-src-container">
<pre class="src src-lisp">  (<span class="org-keyword">defclass</span> <span class="org-type">my-class</span> ()
  ((name <span class="org-builtin">:initarg</span> <span class="org-builtin">:name</span>)
   (value0 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value0</span>)
   (value-list0 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value-list0</span>
               <span class="org-builtin">:type</span> list)
   (value-array0 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value-array0</span>
               <span class="org-builtin">:type</span> array)
   (value1 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value1</span>)
   (value-list1 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value-list1</span>
               <span class="org-builtin">:type</span> list)
   (value-array1 <span class="org-builtin">:initarg</span> <span class="org-builtin">:value-array1</span>
               <span class="org-builtin">:type</span> array)))

(<span class="org-keyword">let</span> ((obj (make-instance 'my-class
                          <span class="org-builtin">:name</span> <span class="org-string">"Name"</span>
                          <span class="org-builtin">:value0</span> nil
                          <span class="org-builtin">:value-list0</span> nil
                          <span class="org-builtin">:value-array0</span> nil
                          <span class="org-builtin">:value1</span> 1
                          <span class="org-builtin">:value-list1</span> '(1 2 3)
                          <span class="org-builtin">:value-array1</span> #(<span class="org-string">"a"</span> <span class="org-string">"b"</span> <span class="org-string">"c"</span>)))
      (cl:*print-pretty* t)
      (shasht:*write-false-values* '(<span class="org-builtin">:false</span>))
      (shasht:*write-empty-array-values* '(<span class="org-builtin">:empty-array</span> nil)))
  (shasht:write-json obj nil))
  <span class="org-string">"{</span>
<span class="org-string">  \"NAME\": \"Name\",</span>
<span class="org-string">  \"VALUE0\": false,</span>
<span class="org-string">  \"VALUE-LIST0\": [],</span>
<span class="org-string">  \"VALUE-ARRAY0\": false,</span>
<span class="org-string">  \"VALUE1\": 1,</span>
<span class="org-string">  \"VALUE-LIST1\": [</span>
<span class="org-string">    1,</span>
<span class="org-string">    2,</span>
<span class="org-string">    3</span>
<span class="org-string">  ],</span>
<span class="org-string">  \"VALUE-ARRAY1\": [</span>
<span class="org-string">    \"a\",</span>
<span class="org-string">    \"b\",</span>
<span class="org-string">    \"c\"</span>
<span class="org-string">  ]</span>
<span class="org-string">}"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-shasht-incremental" class="outline-5">
<h5 id="shasht-incremental">Incremental Encoding</h5>
<div class="outline-text-5" id="text-shasht-incremental">
<p>
The following examples use two exercises. First, incrementally build a JSON array. Second, incrementally build a JSON object which also contains an incrementally built JSON array.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">shasht:with-json-array</span> *standard-output*
  (<span class="org-keyword">dotimes</span> (i 3)
    (shasht:write-json i)))
[0,1,2]
</pre>
</div>
<p>
One way of doing the second exercise could look like this:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">shasht:with-json-object</span> *standard-output*
  (shasht:print-json-key-value ()
                               <span class="org-string">"hello"</span> <span class="org-string">"hu hu"</span> *standard-output*)
  (shasht:print-json-key-value ()
                               <span class="org-string">"harr"</span>
                               (<span class="org-keyword">loop</span> <span class="org-builtin">:for</span> i <span class="org-builtin">:from</span> 0 <span class="org-builtin">:to</span> 2 <span class="org-builtin">:collect</span> i)
                               *standard-output*))
{<span class="org-string">"hello"</span>: <span class="org-string">"hu hu"</span>, <span class="org-string">"harr"</span>: [0,1,2]}
</pre>
</div>
<p>
The following two examples are taken from the README. There are keyword literals that can be used to help constructing JSON objects and arrays. The values and tags that indicate these literals can be configured via the dynamic variables *write-empty-array-values*, *write-empty-object-values*, *write-array-tags*, *write-object-alist-tags*,
and *write-object-plist-tags*.
</p>

<p>
These literals forms are only meant for serialization and not for round-trip
mapping. Therefore there is no way to read JSON in the same format.:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(shasht:write-json
 '(<span class="org-builtin">:object-alist</span> (<span class="org-string">"a"</span> . <span class="org-builtin">:empty-array</span>)
   (<span class="org-string">"b"</span> . <span class="org-builtin">:empty-object</span>)
   (<span class="org-string">"c"</span> . (<span class="org-builtin">:object-plist</span> <span class="org-string">"d"</span> 1
           <span class="org-string">"e"</span> (<span class="org-builtin">:array</span> 1 2 3)))))
{
<span class="org-string">"a"</span>: [],
<span class="org-string">"b"</span>: {},
<span class="org-string">"c"</span>: {
<span class="org-string">"d"</span>: 1,
<span class="org-string">"e"</span>: [
1,
2,
3
]
}
}

(<span class="org-builtin">:OBJECT-ALIST</span> (<span class="org-string">"a"</span> . <span class="org-builtin">:EMPTY-ARRAY</span>) (<span class="org-string">"b"</span> . <span class="org-builtin">:EMPTY-OBJECT</span>)
               (<span class="org-string">"c"</span> <span class="org-builtin">:OBJECT-PLIST</span> <span class="org-string">"d"</span> 1 <span class="org-string">"e"</span> (<span class="org-builtin">:ARRAY</span> 1 2 3)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-shasht-symmetry" class="outline-4">
<h4 id="shasht-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-shasht-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, shasht had no issues.
</p>

<p>
Going from CL-&gt;JSON-&gt;CL was more problematic. The alist input was converted to vectors of vectors and keyword symbols became strings.
</p>
</div>
</div>
<div id="outline-container-shasht-security" class="outline-4">
<h4 id="shasht-security">Security</h4>
<div class="outline-text-4" id="text-shasht-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data. shasht did not exhibit the first issue.
</p>

<p>
With respect to the second issue, shasht rejected 159 out of 173 malformed test cases. While it did not trigger the stack exhaustion issue exhibited by most of the other packages, some of the malformed JSON data strings did trigger recoverable error situations.
</p>

<p>
Shasht has also added read-level and read-length limits but these are set to nil by default.
</p>
</div>
</div>

<div id="outline-container-shasht-conformity" class="outline-4">
<h4 id="shasht-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-shasht-conformity">
<p>
shasht accepted 95 of the 95 test cases that are considered "must accept".  If *read-default-float-format* is set to 'single-float, it would refuse to accept:  [123e65], [123e45] and [123.456e78].
</p>

<p>
It accepted 9 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>
<div id="outline-container-shasht-benchmarking" class="outline-4">
<h4 id="shasht-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-shasht-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>

<div id="outline-container-shasht-exported-symbols" class="outline-4">
<h4 id="shasht-exported-symbols">Shasht Exported Symbols</h4>
<div class="outline-text-4" id="text-shasht-exported-symbols">
<ul class="org-ul">
<li><b>*read-default-array-format*</b> - The default format to use when reading an array. Current supported formats are :vector or :list. Initially set to :vector.</li>
<li><b>*read-default-false-value*</b> - The default value to return when reading a false token. Initially set to nil</li>
<li><b>*read-default-null-value*</b> - The default value to return when reading a null token. Initially set to :null</li>
<li><b>*read-default-object-format*</b> - The default format to use when reading an object. Current supported formats are :hash-table, :alist or :plist. Initially set to :hash-table</li>
<li><b>*read-default-true-value*</b> - The default value to return when reading a true token. Initially set to t</li>
<li><b>*read-length*</b> - The maximum number of values in an array or object. Initially set to nil, which disables length checking.</li>
<li><b>*read-level*</b> - The maximum number of levels to allow during reading for arrays and objects. Initially set to nil, which disables level checking.</li>
<li><b>*symbol-name-function*</b></li>
<li><b>*write-alist-as-object*</b> - If true then assocation lists will be written as an object. Initially set to nil</li>
<li><b>*write-array-tags</b>  -  Indicators in the CAR of a list that indicate that the CDR or the list should be written as an array.</li>
<li><b>*write-object-alist-tags</b> - Indicators in the CAR of a list that indicate that the CDR of the list is an alist and should be written as object.</li>
<li><b>*write-object-plist-tags</b> - Indicators in the CAR of a list that indicate that the CDR of the list is an plist and should be written as object.</li>
<li><b>*write-ascii-encoding*</b> - If true then any non ASCII values will be encoded using Unicode escape sequences. Initially set to nil</li>
<li><b>*write-empty-array-values*</b></li>
<li><b>*write-empty-object-values*</b></li>
<li><b>*write-false-values*</b> - Values that will be written as a false token. Initially set to '(nil :false)</li>
<li><b>*write-indent-string*</b> - The string to use when indenting objects and arrays. Initially set to #\space</li>
<li><b>*write-null-values*</b> - Values that will be written as a null token. Initially set to (:null)</li>
<li><b>*write-plist-as-object*</b> - If true then property lists will be written as an object. Initially set to nil</li>
<li><b>*write-true-values*</b> - Values that will be written as a true token. Initially set to '(t :true)</li>
<li><b>make-object</b></li>
<li><b>print-json-delimiter</b></li>
<li><b>print-json-key-value</b></li>
<li><b>print-json-value</b> - The actual serialization of JSON data is done by the generic function print-json-value which can be specialized for additional value types.</li>
<li><b>read-json</b> - The primary read function</li>
</ul>
<div class="org-src-container">
<pre class="src src-lisp">(read-json <span class="org-type">&amp;optional</span> input-stream-or-string (eof-error-p t) eof-value single-value-p)
</pre>
</div>
<ul class="org-ul">
<li><b>read-json*</b> - will set the various dynamic variables from supplied keywords.</li>
</ul>
<div class="org-src-container">
<pre class="src src-lisp">(read-json* <span class="org-builtin">:stream</span> nil
            <span class="org-builtin">:eof-error</span> t
            <span class="org-builtin">:eof-value</span> nil
            <span class="org-builtin">:single-value</span> nil
            <span class="org-builtin">:true-value</span> t
            <span class="org-builtin">:false-value</span> nil
            <span class="org-builtin">:null-value</span> <span class="org-builtin">:null</span>
            <span class="org-builtin">:array-format</span> <span class="org-builtin">:vector</span>
            <span class="org-builtin">:object-format</span> <span class="org-builtin">:hash-table</span>
            <span class="org-builtin">:float-format</span> 'single-float)
</pre>
</div>
<ul class="org-ul">
<li><b>shasht-parse-error</b></li>
<li><b>with-json-array</b> - macros take an output stream as the first argument then enable indentation and automatic handling of all delimiter tokens. the function (print-json-value value output-stream) should be used to output a single value.</li>
<li><b>with-json-key</b></li>
<li><b>with-json-object</b> - macros take an output stream as the first argument then enable indentation and automatic handling of all delimiter tokens. function (print-json-key-value key value output-stream) should be used to output a key value pair.</li>
<li><b>write-json</b> - The primary writing function</li>
</ul>
<div class="org-src-container">
<pre class="src src-lisp">(write-json value <span class="org-type">&amp;optional</span> (output-stream t))
</pre>
</div>
<ul class="org-ul">
<li><b>write-json*</b> - Will set the various dynamic variables from supplied keywords.</li>
</ul>
<div class="org-src-container">
<pre class="src src-lisp">(write-json* value <span class="org-builtin">:stream</span> t
                   <span class="org-builtin">:ascii-encoding</span> nil
                   <span class="org-builtin">:true-values</span> '(t <span class="org-builtin">:true</span>)
                   <span class="org-builtin">:false-values</span> '(nil <span class="org-builtin">:false</span>)
                   <span class="org-builtin">:null-values</span> '(<span class="org-builtin">:null</span>)
                   <span class="org-builtin">:empty-array-values</span> '(<span class="org-builtin">:empty-array</span>)
                   <span class="org-builtin">:empty-object-values</span> '(<span class="org-builtin">:empty-object</span>)
                   <span class="org-builtin">:alist-as-object</span> nil
                   <span class="org-builtin">:plist-as-object</span> nil
                   <span class="org-builtin">:pretty</span> nil
                   <span class="org-builtin">:indent-string</span> <span class="org-string">"  "</span>)
</pre>
</div>
<ul class="org-ul">
<li><b>write-json-string</b></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-st-json" class="outline-3">
<h3 id="st-json">st-json</h3>
<div class="outline-text-3" id="text-st-json">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#st-json">st-json</a></td>
<td class="org-left">Marijn Haverbeke</td>
<td class="org-left">zlib-style</td>
<td class="org-left"><a href="https://github.com/marijnh/ST-JSON">https://github.com/marijnh/ST-JSON</a></td>
</tr>
</tbody>
</table>

<p>
As the README says, st-json does mostly the same thing as cl-json, but is simpler and more precise about types (distinguishing boolean false, the empty array, and the empty object). It is very fast encoding. While not the fastest decoder, it has respectable decoding speed. It does have optimize set for safety 0 to increase speed. This has bitten some users hard in the past, so you have been warned. It handles JSON's null correctly. You will have to write your own methods to handle symbols and CLOS objects.
</p>

<p>
Documentation is found at <a href="https://marijnhaverbeke.nl/st-json/">https://marijnhaverbeke.nl/st-json/</a>.
</p>
</div>

<div id="outline-container-st-json-mapping" class="outline-4">
<h4 id="st-json-mapping">Default Mappping</h4>
<div class="outline-text-4" id="text-st-json-mapping">
<p>
Please note the direction of the arrows in the following table.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lisp</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">integer</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with no frac or exp parts</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">rational</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">ratio</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">true</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">[]</td>
</tr>

<tr>
<td class="org-left">:FALSE</td>
<td class="org-left">&lt;-</td>
<td class="org-left">false</td>
</tr>

<tr>
<td class="org-left">:NULL</td>
<td class="org-left">&lt;-</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">other symbol (1)</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">character (1)</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">list (except alists)</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">vector (1)</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>

<tr>
<td class="org-left">alist  (2)</td>
<td class="org-left">-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">hash-table (3)</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">struct</td>
<td class="org-left">&lt;-</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">standard object (1)</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) You can write a method to handle these</li>
<li>(2) Only if the alist does not have dotted cons cells.</li>
<li>(3) Encoding hash-tables works with the caveat that if the hash-table has symbols as keys, you will have to write your own method to handle symbols first.</li>
</ul>
</div>
</div>

<div id="outline-container-st-json-decoding" class="outline-4">
<h4 id="st-json-decoding">Decoding</h4>
<div class="outline-text-4" id="text-st-json-decoding">
<p>
In decoding, st-json creates instances of a struct "jso" which wraps an alist. The underlying idea for using a struct is that often hash tables are too heavy weight for the needs.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(st-json:read-json <span class="org-string">"{\"foo\": \"alpha\", \"bar\":3.2,\"baz\": \"null\"}"</span>)

#S(ST-JSON:JSO <span class="org-builtin">:ALIST</span> ((<span class="org-string">"foo"</span> . <span class="org-string">"alpha"</span>) (<span class="org-string">"bar"</span> . 3.2) (<span class="org-string">"baz"</span> . <span class="org-string">"null"</span>)))
</pre>
</div>
</div>
</div>
<div id="outline-container-st-json-encoding" class="outline-4">
<h4 id="st-json-encoding">Encoding</h4>
<div class="outline-text-4" id="text-st-json-encoding">
<p>
The basic encoding function is write-json. Similarly to cl-json, st-json has a function for writing JSON output to string as well as to a stream. St-json has a limited number of lisp datatypes that it handles out of the box. For example, vectors are not included. It is easy to write methods for those types, but that is an additional amount of work not necessary in most of the other libraries.
</p>
</div>
<div id="outline-container-st-json-encoding-symbols" class="outline-5">
<h5 id="st-json-encoding-symbols">Encoding Symbols</h5>
<div class="outline-text-5" id="text-st-json-encoding-symbols">
<p>
You need to write your own st-json::write-json-element function for symbols. Possibly something like:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmethod</span> <span class="org-function-name">st-json:write-json-element</span> ((element symbol) stream)
  (st-json:write-json-element (string element) stream))
</pre>
</div>
<p>
You can also write methods to handle encoding the other lisp datatypes in the default mapping table which show an error.
</p>
</div>
</div>
<div id="outline-container-st-json-encoding-arrays" class="outline-5">
<h5 id="st-json-encoding-arrays">Encoding Arrays</h5>
<div class="outline-text-5" id="text-st-json-encoding-arrays">
<p>
You need to write your own st-json::write-json-element function for arrays. Possibly something like:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmethod</span> <span class="org-function-name">write-json-element</span> ((element vector) stream)
  (<span class="org-keyword">declare</span> #.*optimize*)
  (write-char #\[ stream)
  (<span class="org-keyword">loop</span> <span class="org-builtin">:for</span> val <span class="org-builtin">:across</span> element
          <span class="org-builtin">:for</span> first <span class="org-builtin">:=</span> t <span class="org-builtin">:then</span> nil
          <span class="org-builtin">:unless</span> first <span class="org-builtin">:do</span> (write-char #\, stream)
          <span class="org-builtin">:do</span> (write-json-element val stream))
  (write-char #\] stream))
</pre>
</div>
</div>
</div>

<div id="outline-container-st-json-encoding-alists" class="outline-5">
<h5 id="st-json-encoding-alists">Encoding Alists</h5>
<div class="outline-text-5" id="text-st-json-encoding-alists">
<p>
If the alist has dotted cons cells, jsown and st-json triggered unhandled memory faults with SBCL 2.1.11-x86-64-linux, CCL version 1.12.1 LinuxX8664 and ecl-version 21.2.1. This appears to be because jsown and st-json have optimized the code and assumed that all lists will be proper lists. The assumption obviously fails in the context of dotted cons cells.
</p>
</div>
</div>
<div id="outline-container-st-json-encoding-clos" class="outline-5">
<h5 id="st-json-encoding-clos">Encoding CLOS</h5>
<div class="outline-text-5" id="text-st-json-encoding-clos">
<p>
St-json requires that you actually define a write-json-element method for the CLOS class you want to encode. Consider our little person class.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defclass</span> <span class="org-type">person</span> ()
    ((name
      <span class="org-builtin">:initarg</span> <span class="org-builtin">:name</span> <span class="org-builtin">:initform</span> <span class="org-string">"Sabra"</span>
      <span class="org-builtin">:accessor</span> name)
     (eye-colour <span class="org-builtin">:initarg</span> <span class="org-builtin">:eye-colour</span>
      <span class="org-builtin">:initform</span> <span class="org-string">"brown"</span>
      <span class="org-builtin">:accessor</span> eye-colour)))
</pre>
</div>
<p>
Creating the required method for this class is straight forward.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmethod</span> <span class="org-function-name">st-json:write-json-element</span> ((person person) stream)
  (<span class="org-keyword">let</span> ((accessors '((<span class="org-string">"name"</span> name) (<span class="org-string">"eye_colour"</span> eye-colour))))
    (write-char  #\{ stream)
    (<span class="org-keyword">loop</span> <span class="org-builtin">:for</span> (key val) <span class="org-builtin">:in</span> accessors
          <span class="org-builtin">:for</span> first <span class="org-builtin">:=</span> t <span class="org-builtin">:then</span> nil
          <span class="org-builtin">:unless</span> first <span class="org-builtin">:do</span> (write-char #\, stream)
          do
          (st-json:write-json-element key stream)
          (write-char #\: stream)
          (st-json:write-json-element (funcall val person) stream))
    (write-char  #\} stream)))

#&lt;STANDARD-METHOD ST-JSON:WRITE-JSON-ELEMENT (PERSON T) {101561B163}&gt;
JSON-TESTS&gt; (<span class="org-keyword">let</span> ((data (make-instance 'person))) (st-json:write-json data *standard-output*))
{<span class="org-string">"name"</span>:<span class="org-string">"Sabra"</span>,<span class="org-string">"eye_colour"</span>:<span class="org-string">"brown"</span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-st-json-incremental" class="outline-5">
<h5 id="st-json-incremental">Incremental Encoding</h5>
<div class="outline-text-5" id="text-st-json-incremental">
<p>
The following examples use two exercises. First, incrementally build a JSON array. Second, incrementally build a JSON object which also contains an incrementally built JSON array. The first exercise (again, like jsown, I found using loop easier than dotimes):
</p>
<div class="org-src-container">
<pre class="src src-lisp">(st-json:write-json-to-string
   (<span class="org-keyword">loop</span> <span class="org-builtin">:for</span> i <span class="org-builtin">:from</span> 0 <span class="org-builtin">:to</span> 2 <span class="org-builtin">:collect</span> i))
<span class="org-string">"[0,1,2]"</span>
</pre>
</div>
<p>
The second exercise:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(st-json:write-json-to-string
 (st-json:jso <span class="org-string">"hello"</span> <span class="org-string">"hu hu"</span> <span class="org-string">"harr"</span>
              (<span class="org-keyword">loop</span> <span class="org-builtin">:for</span> i <span class="org-builtin">:from</span> 0 <span class="org-builtin">:to</span> 2 <span class="org-builtin">:collect</span> i)))

<span class="org-string">"{\"hello\":\"hu hu\",\"harr\":[0,1,2]}"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-st-json-symmetry" class="outline-4">
<h4 id="st-json-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-st-json-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, st-json had no issues.
</p>

<p>
Going from CL-&gt;JSON-&gt;CL was more problematic solely because you need to write a method to deal with encoding symbols.
</p>
</div>
</div>
<div id="outline-container-st-json-security" class="outline-4">
<h4 id="st-json-security">Security</h4>
<div class="outline-text-4" id="text-st-json-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data. st-json did not exhibit the first issue.
</p>

<p>
With respect to the second issue, st-json rejected 140 out of 173 malformed test cases. Unfortunately it did trigger the stack exhaustion issue exhibited by most of the other packages.
</p>
</div>
</div>

<div id="outline-container-st-json-conformity" class="outline-4">
<h4 id="st-json-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-st-json-conformity">
<p>
st-json accepted 95 of the 95 test cases that are considered "must accept". If *read-default-float-format* is set to 'single-float, it would refuse to accept:  [123e65], [123e45] and [123.456e78].
</p>

<p>
It accepted 8 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>
<div id="outline-container-st-json-benchmarking" class="outline-4">
<h4 id="st-json-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-st-json-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>

<div id="outline-container-st-json-other-information" class="outline-4">
<h4 id="st-json-other-information">Other Information</h4>
<div class="outline-text-4" id="text-st-json-other-information">
<p>
St-json provides error conditions for json-type-error, json-parse error, json-error and json-eof-error. These are undocumented, so you will have to look at the source code for how to use them.
</p>
</div>
</div>

<div id="outline-container-st-json-exported-symbols" class="outline-4">
<h4 id="st-json-exported-symbols">st-json exported symbols</h4>
<div class="outline-text-4" id="text-st-json-exported-symbols">
<ul class="org-ul">
<li><b>*allow-comments*</b> - Non-nil means ignore comments when parsing.</li>
<li><b>*decode-objects-as*</b> - Valid values: :jso :hashtable
Controls how js objects should be decoded. :jso means decode to internal struct which
can be processed by getjso, mapjso etc. :hashtable means decode as hash tables.</li>
<li><b>*output-literal-unicode*</b> - Bind this to T in order to reduce the use of \uXXXX Unicode escapes,
by emitting literal characters (encoded in UTF-8). This may help
reduce the parsing effort for any recipients of the JSON output, if
they can already read UTF-8, or else, they'll need to implement
complex unicode (eg UTF-16 surrogate pairs) escape parsers.</li>
<li><b>*script-tag-hack*</b> - Bind this to T when writing JSON that will be written to an HTML
document. It prevents '&lt;/script&gt;' from occurring in strings by
escaping any slash following a '&lt;' character.</li>
<li><b>as-json-bool</b> - Convert a generalised boolean to a :true/:false keyword.</li>
<li><b>from-json-bool</b> - Convert :true or :false to its boolean equivalent.</li>
<li><b>getjso</b> - Fetch a value from a JS object. Returns a second value like gethash.</li>
<li><b>getjso*</b> - The getjso* function in theory allows you to take a key in the form of "a.b.c" and st-json will generate a series of getjso calls to go down each level and return the value for key c. This, however, does not seem to work if read-json does not result in jso objects all the way down. Consider, for example, if we have is a jso object which wraps a cons which wraps a jso object. The intermediary cons prevents getjso* from walking down the nested list.</li>
<li><b>jso</b> - Create a JS object. Arguments should be alternating labels and values.</li>
<li><b>json-bool</b> - (deftype json-bool () '(member :true :false))</li>
<li><b>json-eof-error</b></li>
<li><b>json-error</b></li>
<li><b>json-null</b> - (deftype json-null () '(eql :null))</li>
<li><b>json-parse-error</b></li>
<li><b>json-type-error</b></li>
<li><b>mapjso</b> - Iterate over the key/value pairs in a JS object.</li>
<li><b>read-json</b> - Read a JSON-encoded value from a stream or a string.</li>
<li><b>read-json-as-type</b> - Read a JSON value and assert the result to be of a given type. Raises a json-type-error when the type is wrong.</li>
<li><b>read-json-from-string</b></li>
<li><b>write-json</b> - Write a value's JSON representation to a stream.</li>
<li><b>write-json-element</b> - Method used for writing values of a specific type. You can specialise this for your own types.</li>
<li><b>write-json-to-string</b></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-trivial-json-codec" class="outline-3">
<h3 id="trivial-json-codec">trivial-json-codec</h3>
<div class="outline-text-3" id="text-trivial-json-codec">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#trivial-json-codec">trivial-json-codec</a></td>
<td class="org-left">Eric Diethelm</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://gitlab.com/ediethelm/trivial-json-codec">https://gitlab.com/ediethelm/trivial-json-codec</a></td>
</tr>
</tbody>
</table>

<p>
As the website says, trivial-json-codec is a JSON parser focused on the ability to handle class hierarchies. The classes must be defined each class in a hierarchy must have at least one slot named differently. It does not handle the difference between JSON's null and false (everything is nil once it gets to the CL side). The one thing I do not understand is its use of angle brackets when encoding lists to JSON. E.g.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(trivial-json-codec:serialize '(1 2 3) *standard-output*)
&lt;1,2,3&gt;
</pre>
</div>
<p>
Encoding vectors looks perfectly standard:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(trivial-json-codec:serialize #(1 2 3) *standard-output*)
[1,2,3]
</pre>
</div>
<p>
I see this encoding of lists as resulting in invalid JSON, but maybe I am missing something.
</p>
</div>

<div id="outline-container-trivial-json-codec-mapping" class="outline-4">
<h4 id="trivial-json-codec-mapping">Default Mappping</h4>
<div class="outline-text-4" id="text-trivial-json-codec-mapping">
<p>
Please note the direction of the arrows in the following table.
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Lisp</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">integer</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with no frac or exp parts</td>
</tr>

<tr>
<td class="org-left">float</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">rational</td>
<td class="org-left">-&gt;</td>
<td class="org-left">number with frac or exp parts</td>
</tr>

<tr>
<td class="org-left">ratio</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error (1)</td>
</tr>

<tr>
<td class="org-left">T</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">true</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">[]</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-</td>
<td class="org-left">false</td>
</tr>

<tr>
<td class="org-left">nil</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">null</td>
</tr>

<tr>
<td class="org-left">other symbol</td>
<td class="org-left">-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">character</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error  (1)</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">string</td>
</tr>

<tr>
<td class="org-left">list (except alists)</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">invalid angle bracket array?</td>
</tr>

<tr>
<td class="org-left">vector</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">array</td>
</tr>

<tr>
<td class="org-left">alist w/o dotted pairs</td>
<td class="org-left">-&gt;</td>
<td class="org-left">invalid angle bracket array</td>
</tr>

<tr>
<td class="org-left">alist with dotted pairs</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error (1)</td>
</tr>

<tr>
<td class="org-left">hash-table</td>
<td class="org-left">-&gt;</td>
<td class="org-left">Error (1)</td>
</tr>

<tr>
<td class="org-left">plist</td>
<td class="org-left">&lt;-</td>
<td class="org-left">invalid angle bracket array</td>
</tr>

<tr>
<td class="org-left">standard object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">object</td>
</tr>

<tr>
<td class="org-left">alist</td>
<td class="org-left">&lt;-</td>
<td class="org-left">object  (2)</td>
</tr>

<tr>
<td class="org-left">alist</td>
<td class="org-left">&lt;-</td>
<td class="org-left">object  (3)</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) You could write a method to handle these</li>
<li>(2) Using deserialize-raw</li>
<li>(3) Using deserialize-json if a base class is given</li>
</ul>
</div>
</div>

<div id="outline-container-trivial-json-codec-decoding" class="outline-4">
<h4 id="trivial-json-codec-decoding">Decoding</h4>
<div class="outline-text-4" id="text-trivial-json-codec-decoding">
<p>
Trivial-json-codec has two functions that "deserialize" JSON strings. The first is deserialize-raw. JSON arrays are converted to vectors and JSON objects are converted to alists.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(trivial-json-codec:deserialize-raw <span class="org-string">"[1.23,\"alpha\",false,null]"</span>)
#(1.23 <span class="org-string">"alpha"</span> NIL NIL)

(trivial-json-codec:deserialize-raw *address-1*)
((<span class="org-builtin">:NAME</span> <span class="org-string">"George Washington"</span>) (<span class="org-builtin">:BIRTHDAY</span> <span class="org-string">"February 22, 1732"</span>)
                             (<span class="org-builtin">:ADDRESS</span> <span class="org-string">"Mount Vernon, Virginia, United States"</span>))
</pre>
</div>
<p>
The second is deserialize-json. This function takes a JSON string, a CL class, a read-table and constructors. The last three default to nil. If you do not supply a CL class, deserialize-json can only handle native types:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(trivial-json-codec:deserialize-json <span class="org-string">"[1.23,\"alpha\",false,null]"</span>)
#(1.23 <span class="org-string">"alpha"</span> NIL NIL)
</pre>
</div>
<p>
If you do supply a class, it will try to create an instance of the class with data from the JSON string. Lets try with our simple person class which only has slots name and eye-colour.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(describe
 (trivial-json-codec:deserialize-json <span class="org-string">"{\"name\":\"Rebecca\",\"eye-colour\":\"blue\"}"</span>
                                      <span class="org-builtin">:class</span> (find-class 'person)))
#&lt;PERSON {1010770303}&gt;
  [standard-object]

Slots with <span class="org-builtin">:INSTANCE</span> allocation:
  NAME                           = <span class="org-string">"Rebecca"</span>
  EYE-COLOUR                     = <span class="org-string">"blue"</span>
</pre>
</div>
<p>
To no one's surprise, if the JSON string is an array, it will just return a vector. If the array contains the proper JSON objects, it will return a vector of class objects:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(describe
 (aref
  (trivial-json-codec:deserialize-json
   <span class="org-string">"[{\"name\":\"Rebecca\",\"eye-colour\":\"blue\"}, {\"name\":\"Johann\",\"eye-colour\":\"brown\"}]"</span>
   <span class="org-builtin">:class</span> (find-class 'person))
  1))
#&lt;PERSON {1011E67053}&gt;
[standard-object]
Slots with <span class="org-builtin">:INSTANCE</span> allocation:
NAME                           = <span class="org-string">"Johann"</span>
EYE-COLOUR                     = <span class="org-string">"brown"</span>
</pre>
</div>
<p>
If you have a class hierarchy, it will work through the inherited classes. Each class will need to have at least one slot named differently.
</p>
</div>
</div>

<div id="outline-container-trivial-json-codec-encoding" class="outline-4">
<h4 id="trivial-json-codec-encoding">Encoding</h4>
<div class="outline-text-4" id="text-trivial-json-codec-encoding">
<p>
Trivial-json-codec has two functions for encoding: serialize and serialize-json. Serialize is the underlying generic function and takes a stream parameter as well as the data. Serialize-json uses serialize and returns a string.
</p>

<p>
It does encode CLOS objects although you might want to write specialized methods to handle particular formatting. For example, local-time:timestamps were encoded as {"DAY": 7990,  "SEC": 0,  "NSEC": 0}, so if you wanted them to be in any particular javascript time representation, you would have to write a specialized method.
</p>

<p>
You would also need to write applicable methods for any structs, pathnames or hash-tables.
</p>

<p>
As mentioned above, encoding lists returns strings with angle brackets.
</p>
</div>
<div id="outline-container-trivial-json-codec-hierarchy" class="outline-5">
<h5 id="trivial-json-codec-hierarchy">Hierarchy Use Case</h5>
<div class="outline-text-5" id="text-trivial-json-codec-hierarchy">
<p>
I am just going to quote from the README here:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defclass</span> <span class="org-type">Payload</span> ()
  ())

(<span class="org-keyword">defclass</span> <span class="org-type">SimplePayload</span> (Payload)
  ((value <span class="org-builtin">:type</span> integer
          <span class="org-builtin">:initarg</span> <span class="org-builtin">:value</span>)))

(<span class="org-keyword">defclass</span> <span class="org-type">ComplicatedPayload</span> (Payload)
  ((value <span class="org-builtin">:type</span> string
          <span class="org-builtin">:initarg</span> <span class="org-builtin">:value</span>)
   (additional-info <span class="org-builtin">:type</span> string
                    <span class="org-builtin">:initarg</span> <span class="org-builtin">:additional-info</span>)
   (message-id <span class="org-builtin">:type</span> trivial-utilities:positive-fixnum
               <span class="org-builtin">:initarg</span> <span class="org-builtin">:message-id</span>)))

(<span class="org-keyword">defclass</span> <span class="org-type">DifferentPayload</span> (Payload)
  ((cargo <span class="org-builtin">:type</span> fixnum
          <span class="org-builtin">:initarg</span> <span class="org-builtin">:cargo</span>)))

(<span class="org-keyword">defclass</span> <span class="org-type">Message</span> ()
  ((uid <span class="org-builtin">:initarg</span> <span class="org-builtin">:uid</span>
        <span class="org-builtin">:initform</span> nil
        <span class="org-builtin">:accessor</span> uid)
   (payload <span class="org-builtin">:type</span> (or null Payload)
            <span class="org-builtin">:initarg</span> <span class="org-builtin">:payload</span>
            <span class="org-builtin">:accessor</span> payload)))

(c2mop:ensure-finalized (find-class 'Payload))
(c2mop:ensure-finalized (find-class 'SimplePayload))
(c2mop:ensure-finalized (find-class 'ComplicatedPayload))
(c2mop:ensure-finalized (find-class 'DifferentPayload))
(c2mop:ensure-finalized (find-class 'Message))

(<span class="org-keyword">let</span> ((message (make-instance 'Message <span class="org-builtin">:uid</span> 1
                                       <span class="org-builtin">:payload</span> (make-instance 'Simplepayload
                                                               <span class="org-builtin">:value</span> 12345))))
  (trivial-json-codec:serialize-json message))
=&gt; <span class="org-string">"{ \"UID\" : 1,  \"PAYLOAD\" : { \"VALUE\" : 12345}}"</span>

(deserialize-json <span class="org-string">"{ \"UID\" : 1,  \"PAYLOAD\" : { \"VALUE\" : 12345}}"</span>
                  <span class="org-builtin">:class</span> (find-class 'Message))
=&gt; #&lt;MESSAGE&gt; with a payload of type SimplePayload


(<span class="org-keyword">let</span> ((message (make-instance 'Message
                              <span class="org-builtin">:uid</span> 2
                              <span class="org-builtin">:payload</span> (make-instance 'ComplicatedPayload
                                                      <span class="org-builtin">:value</span> <span class="org-string">"abc"</span>
                                                      <span class="org-builtin">:message-id</span> 17
                                                      <span class="org-builtin">:additional-info</span> <span class="org-string">"1234"</span>))))
  (trivial-json-codec:serialize-json message))
=&gt; <span class="org-string">"{ \"UID\" : 2,  \"PAYLOAD\" : { \"VALUE\" : \"abc\",</span>
<span class="org-string">                                    \"ADDITIONAL-INFO\" : \"1234\",</span>
<span class="org-string">                                    \"MESSAGE-ID\" : 17}}"</span>

(deserialize-json <span class="org-string">"{ \"UID\" : 2,</span>
<span class="org-string">                     \"PAYLOAD\" : { \"VALUE\" : \"abc\",</span>
<span class="org-string">                                     \"ADDITIONAL-INFO\" : \"1234\",</span>
<span class="org-string">                                     \"MESSAGE-ID\" : 17}}"</span>
                  <span class="org-builtin">:class</span> (find-class 'Message))
=&gt; #&lt;MESSAGE&gt; with a payload of type ComplicatedPayload

(<span class="org-keyword">let</span> ((message (make-instance 'Message <span class="org-builtin">:uid</span> 2
                                       <span class="org-builtin">:payload</span> (make-instance 'DifferentPayload
                                                               <span class="org-builtin">:cargo</span> -147))))
  (trivial-json-codec:serialize-json message))
=&gt; <span class="org-string">"{ \"UID\" : 2,  \"PAYLOAD\" : { \"CARGO\" : -147}}"</span>

(deserialize-json <span class="org-string">"{ \"UID\" : 2,  \"PAYLOAD\" : { \"CARGO\" : -147}}"</span>
                  <span class="org-builtin">:class</span> (find-class 'Message))
=&gt;  #&lt;MESSAGE&gt; with a payload of type DifferentPayload
</pre>
</div>
<p>
Due to the known limitation mentioned in the description, the following is NOT possible:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defclass</span> <span class="org-type">StringPayload</span> (Payload)
  ((value <span class="org-builtin">:type</span> string
          <span class="org-builtin">:initarg</span> <span class="org-builtin">:value</span>)))

(<span class="org-keyword">let</span> ((message
       (make-instance 'Message <span class="org-builtin">:uid</span> 2
                      <span class="org-builtin">:payload</span> (make-instance 'StringPayload
                                              <span class="org-builtin">:value</span> <span class="org-string">"abc"</span>))))
  (trivial-json-codec:serialize-json message))
=&gt; <span class="org-string">"{ \"UID\" : 2,  \"PAYLOAD\" : { \"VALUE"</span> : \"abc\"}}<span class="org-string">"</span>

<span class="org-string">(deserialize-json "</span>{ \"UID\" : 2,  \"PAYLOAD\" : { \"VALUE<span class="org-string">" : \"abc\"}}"</span>
  <span class="org-builtin">:class</span> (find-class 'Message))
=&gt; This terminates with an error due to non-unique class mapping.
   StringPayload and Simplepayload differ only on the slot's type.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-trivial-json-codec-symmetry" class="outline-4">
<h4 id="trivial-json-codec-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-trivial-json-codec-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, trivial-json-codec continued its insistence that JSON arrays should be shown as angle brackets. trivial-json-codec is really intended as a parser (one way) from JSON to CL, not really serializing to JSON.
</p>

<p>
Interestingly, trivial-json-codec had no problems going from CL-&gt;JSON-&gt;CL.
</p>
</div>
</div>
<div id="outline-container-trivial-json-codec-security" class="outline-4">
<h4 id="trivial-json-codec-security">Security</h4>
<div class="outline-text-4" id="text-trivial-json-codec-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data.  trivial-json-codec did not exhibit the first issue.
</p>

<p>
With respect to the second issue, trivial-json-codec rejected 101 out of 173 malformed test cases. It did not trigger the stack exhaustion issue exhibited by most of the other packages.
</p>
</div>
</div>
<div id="outline-container-trivial-json-codec-conformity" class="outline-4">
<h4 id="trivial-json-codec-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-trivial-json-codec-conformity">
<p>
trivial-json-codec accepted 90 of the 95 test cases that are considered "must accept". It failed to accept: [[] ], [0e+1], [1E+2], [1e+2], { "min": -1.0e+28, "max": 1.0e+28 }.  If *read-default-float-format* is set to 'single-float, it would refuse to accept:  [123e65], [123e45] and [123.456e78].
</p>

<p>
It accepted 13 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>
<div id="outline-container-trivial-json-codec-benchmarking" class="outline-4">
<h4 id="trivial-json-codec-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-trivial-json-codec-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>

<div id="outline-container-trivial-json-codec-exported-symbols" class="outline-4">
<h4 id="trivial-json-codec-exported-symbols">trivial-json-codec exported symbols</h4>
<div class="outline-text-4" id="text-trivial-json-codec-exported-symbols">
<ul class="org-ul">
<li><b>serialize-json obj</b> - takes obj and serializes it into a string. uses the generic serialize to do the job.</li>
<li><b>deserialize-json json-str &amp;key (class nil) (read-table nil) (constructors nil)</b> - reads json-str and creates an according object. If class is non-nil and represents a class, an instance of it is returned. otherwise only built-in types can be deserialized. Read-table makes it possible to inject specific readers, as pondons to serialize. it has the form of an alist containing the dispatch character as car and the deserialization function as cdr. constructors holds an alist mapping the keyword returned by a specific reader to a object construction function.</li>
<li><b>serialize obj stream</b> - serialize an object obj into stream. implementations for some built-in types already exist. the user might extend with methods for specific types.</li>
<li><b>deserialize-raw json-str &amp;key (read-table nil)</b> - deserialize json-str into a property list. as opposed to deserialize-json this function does not require a base class to deserialize.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-yason" class="outline-3">
<h3 id="yason">yason</h3>
<div class="outline-text-3" id="text-yason">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#yason">yason</a></td>
<td class="org-left">Hans Huebner</td>
<td class="org-left">BSD</td>
<td class="org-left"><a href="https://github.com/phmarek/yason">https://github.com/phmarek/yason</a></td>
</tr>
</tbody>
</table>

<p>
IMPORTANT: Notice the GitHub location has moved. Hans Huebner's old GitHub location will automatically redirect to Phil Marek's, but Quicklisp is not (as of the time of this writing) pulling code from the new GitHub location. It is actively maintained by Phil Marek and he is very responsive.
</p>

<p>
From the author: "the major difference between YASON and the other JSON libraries that were available when I wrote it is that YASON does not require the user to come up with a Lisp data structure that reflects the JSON data structure that should be generated. Rather, I wanted a way to generate JSON directly from my internal data structures.
</p>

<p>
The reason for that desire was that I had to generate different JSON format in different contexts. That is, a class instance would sometimes be generated including all its attributes, sometimes just with a select set of attributes and sometimes as a reference. Thus, there was no right way to render an object as JSON, and I found the approach to first generate a data structure that would then be rendered as JSON to be wasteful and, as CL has no literal syntax for hash tables, ugly.
</p>

<p>
Instead of going through an intermediate data structure, YASON allows you to encode to a JSON stream on the fly (<a href="http://common-lisp.net/project/yason/#stream-encoder">http://common-lisp.net/project/yason/#stream-encoder</a>."
</p>
</div>

<div id="outline-container-yason-mapping" class="outline-4">
<h4 id="yason-mapping">Mapping DataTypes and Structures</h4>
<div class="outline-text-4" id="text-yason-mapping">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">JSON</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">cl</th>
<th scope="col" class="org-left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">object</td>
<td class="org-left">-&gt;</td>
<td class="org-left">hash-table :test #'equal</td>
<td class="org-left">Keys are strings by default (see *parse-object-key-fn*). Set *parse-object-as* to :alist in order to have yason parse objects as alists or to :plist to parse them as plists. When using plists, you probably want to also set *parse-object-key-fn* to a function that interns the object's keys to symbols.</td>
</tr>

<tr>
<td class="org-left">array</td>
<td class="org-left">-&gt;</td>
<td class="org-left">list</td>
<td class="org-left">Can be changed to read to vectors (see *parse-json-arrays-as-vectors*)</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">string</td>
<td class="org-left">JSON escape characters are recognized upon reading. Upon writing, known escape characters are used, but non-ASCII Unicode characters are written as is.</td>
</tr>

<tr>
<td class="org-left">number</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">number</td>
<td class="org-left">Parsed with READ, printed with PRINC</td>
</tr>

<tr>
<td class="org-left">true</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">t</td>
<td class="org-left">Can be changed to read as TRUE (see *parse-json-booleans-as-symbols*).</td>
</tr>

<tr>
<td class="org-left">false</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">nil</td>
<td class="org-left">Can be changed to read as FALSE (see *parse-json-booleans-as-symbols*).</td>
</tr>

<tr>
<td class="org-left">null</td>
<td class="org-left">&lt;-&gt;</td>
<td class="org-left">nil or :NULL</td>
<td class="org-left">nil unless yason:parse is called with yason:*parse-json-null-as-keyword* set to t or passing the keyword parameter :json-nulls-as-keyword t to yason:parse</td>
</tr>

<tr>
<td class="org-left">(1)</td>
<td class="org-left">&lt;-</td>
<td class="org-left">symbol</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(2)</td>
<td class="org-left">&lt;-</td>
<td class="org-left">object</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">(3)</td>
<td class="org-left">&lt;-</td>
<td class="org-left">alists</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) If you are working with yason version 0.8.2 or above, you can set the special variable *symbol-encoder* to the function #'YASON:ENCODE-SYMBOL-AS-LOWERCASE. In that case symbols will be encoded as lower case strings in JSON. Otherwise attempts to encode symbols will trigger a no-applicable-method error.</li>
<li>(2) Will trigger a no-applicable-method error. So you could write class specific encoding methods for your objects.</li>
<li>(3) Will return an object. Undotted alists will return values in an array, dotted alists will return individual values for each key. See <a href="#yason-encoding-alists">Yason Encoding Alists</a> below.</li>
</ul>
</div>
</div>

<div id="outline-container-yason-decoding" class="outline-4">
<h4 id="yason-decoding">Decoding</h4>
<div class="outline-text-4" id="text-yason-decoding">
<p>
Yason uses its generic function parse to generate a hash-table of the received json-object. It is possible to set the special variable *parse-object-as* :hash-table, :plist or :alist to specify the data structure that objects are parsed into. The default is :hash-table with test being equal. It is also possible to set the special variable *parse-json-arrays-as-vectors* to t, in which case the JSON arrays will be parsed as vectors and not as lists.
</p>

<p>
The following are decoding tests on JSON arrays, arrays in arrays and embedded arrays in an object and the results. I am using the additional yason parameters to show the alist representation instead of a hash-table and to return JSON arrays as vectors rather than lists.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*short-encoded-items-A*</span>

<span class="org-string">"[\"items\",</span>
<span class="org-string">  {\"index\":1,</span>
<span class="org-string">     \"float\":19.2041,</span>
<span class="org-string">     \"name\":\"Jennifer\",</span>
<span class="org-string">     \"surname\":\"Snow7\",</span>
<span class="org-string">     \"fullname\":\"Andrew4 Vaughan\",\"email\":\"sherri@ritchie.zw\",</span>
<span class="org-string">     \"bool\":null},</span>
<span class="org-string">   {\"index\":2,</span>
<span class="org-string">     \"float\":14.9888,\"name\":\"Alfred\",</span>
<span class="org-string">     \"surname\":\"Pitts\",\"fullname\":\"Barry Weiner\",</span>
<span class="org-string">     \"email\":\"cheryl@craven.re\",\"bool\":null}]"</span>)

(yason:parse *short-encoded-items-A* <span class="org-builtin">:json-arrays-as-vectors</span> t <span class="org-builtin">:object-as</span> <span class="org-builtin">:alist</span>)

'(<span class="org-string">"items"</span>
 ((<span class="org-string">"bool"</span>) (<span class="org-string">"email"</span> . <span class="org-string">"sherri@ritchie.zw"</span>) (<span class="org-string">"fullname"</span> . <span class="org-string">"Andrew Vaughan"</span>)
 (<span class="org-string">"surname"</span> . <span class="org-string">"Snow7"</span>) (<span class="org-string">"name"</span> . <span class="org-string">"Jennifer"</span>) (<span class="org-string">"float"</span> . 19.2041)
 (<span class="org-string">"index"</span> . 1))
 ((<span class="org-string">"bool"</span>) (<span class="org-string">"email"</span> . <span class="org-string">"cheryl@craven.re"</span>) (<span class="org-string">"fullname"</span> . <span class="org-string">"Barry Weiner"</span>)
 (<span class="org-string">"surname"</span> . <span class="org-string">"Pitts"</span>) (<span class="org-string">"name"</span> . <span class="org-string">"Alfred"</span>) (<span class="org-string">"float"</span> . 14.9888)
 (<span class="org-string">"index"</span> . 2)))
</pre>
</div>
</div>

<div id="outline-container-yason-nested-json-objects" class="outline-5">
<h5 id="yason-nested-json-objects">Nested JSON Objects</h5>
<div class="outline-text-5" id="text-yason-nested-json-objects">
<p>
Yason does require that you completely parse the JSON data instead of being able to filter it while taking it in. Taking the nested JSON object below, how could we get a information out of the innermost nested object?
</p>

<div class="org-src-container">
<pre class="src src-javascript">{
  <span class="org-string">"items"</span>: [
    {
      <span class="org-string">"index"</span>: 1,
      <span class="org-string">"integer"</span>: 29,
      <span class="org-string">"float"</span>: 16.8278,
      <span class="org-string">"fullname"</span>: <span class="org-string">"Milton Jensen"</span>,
      <span class="org-string">"bool"</span>: <span class="org-constant">false</span>
    }
  ]
}
</pre>
</div>
<p>
You need to know your data structure so that you can figure out how to walk the tree. How would we get the value of the key "integer"? Looking at it, it is a JSON object which keyword "items"contains an array which contains a JSON object.
</p>

<p>
By default, yason decodes JSON objects to hash-tables and arrays into lists. So we can descend the parsed JSON tree in this particular example something like this (assuming the JSON object was in a file named json4.txt):
</p>
<div class="org-src-container">
<pre class="src src-lisp">(gethash <span class="org-string">"integer"</span>
         (first
          (gethash <span class="org-string">"items"</span>
                   (yason:parse
                    (alexandria:read-file-into-string #P<span class="org-string">"/home/sabra/json4.txt"</span>)))))

29
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-yason-encloding" class="outline-4">
<h4 id="yason-encloding">Encoding</h4>
<div class="outline-text-4" id="text-yason-encloding">
<p>
The base yason encoding function is encode, which takes some data and an optional stream, defaulting to *standard-output*. It returns first the json-encoded item and second the lisp item:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(yason:encode '(<span class="org-string">"a"</span> 1 <span class="org-string">"b"</span> 2))
[<span class="org-string">"a"</span>,1,<span class="org-string">"b"</span>,2]
(<span class="org-string">"a"</span> 1 <span class="org-string">"b"</span> 2)
</pre>
</div>
<p>
Yason has multiple specialized methods that may be required, depending on the data structure to be encoded. For example:
yason:encode-alist, yason:encode-plist, yason:encode-object, etc. The following demonstrates that providing a plist to yason:encode results in an JSON array, but providing a plist to yason:encode-plist results in a JSON object.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(yason:encode '(<span class="org-string">"a"</span> 1 <span class="org-string">"b"</span> 2))
[<span class="org-string">"a"</span>,1,<span class="org-string">"b"</span>,2]

(yason:encode-plist '(<span class="org-string">"a"</span> 1 <span class="org-string">"b"</span> 2))
{<span class="org-string">"a"</span><span class="org-builtin">:1</span>,<span class="org-string">"b"</span><span class="org-builtin">:2}</span>
</pre>
</div>
</div>

<div id="outline-container-yason-encloding-symbols" class="outline-5">
<h5 id="yason-encloding-symbols">Encoding Symbols</h5>
<div class="outline-text-5" id="text-yason-encloding-symbols">
<p>
The version of yason in Quicklisp as of this writing (version 7.8) has no applicable method for encoding a symbol. This also means that  by default, yason will not encode lists with symbols. That is resolved in version 8.2 on GitHub, but for some reason it is not getting picked up in Quicklisp. You can resolve this in version 7.8 by writing a new method to handle symbols. Such a method could look like this:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmethod</span> <span class="org-function-name">encode</span> ((object symbol) <span class="org-type">&amp;optional</span> (stream *json-output*))
  (<span class="org-keyword">let</span> ((new (funcall #'ENCODE-SYMBOL-AS-LOWERCASE object)))
    (<span class="org-warning">assert</span> (stringp new))
    (encode new stream)))
</pre>
</div>
<p>
If you have symbols in alists as keys, you can (setf yason:*symbol-key-encoder* 'yason:ENCODE-SYMBOL-AS-LOWERCASE) and then yason:encode-alist will work, but not yason:encode.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(yason:encode-alist '((a 1) (b 2)))
{<span class="org-string">"a"</span><span class="org-builtin">:[1]</span>,<span class="org-string">"b"</span><span class="org-builtin">:[2]}</span>
((A 1) (B 2))
</pre>
</div>
</div>
</div>

<div id="outline-container-yason-encoding-alists" class="outline-5">
<h5 id="yason-encoding-alists">Encoding Alists</h5>
<div class="outline-text-5" id="text-yason-encoding-alists">
<p>
Unlike some other libraries, yason's encode-alist function handles both dotted and undotted alists. It will return an object. The values in undotted alists will be returned as arrays, the values in dotted alists will be returned as individual values. As mentioned in just above in dealing with symbols, if you have symbols as keys in your alist, you need to have set *symbol-key-encoder* to 'yason:ENCODE-SYMBOL-AS-LOWERCASE in order to make them usable without triggering errors.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(setf yason:*symbol-key-encoder* 'yason:ENCODE-SYMBOL-AS-LOWERCASE)

(yason:encode-alist '((a 1 2 3 4) (b 5 6 7)))
{<span class="org-string">"a"</span><span class="org-builtin">:[1</span>,2,3,4],<span class="org-string">"b"</span><span class="org-builtin">:[5</span>,6,7]}

(yason:encode-alist '((a . 1) (b . 2)))
{<span class="org-string">"a"</span><span class="org-builtin">:1</span>,<span class="org-string">"b"</span><span class="org-builtin">:2}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-yason-encoding-clos" class="outline-5">
<h5 id="yason-encoding-clos">Encoding CLOS</h5>
<div class="outline-text-5" id="text-yason-encoding-clos">
<p>
For objects, you will have to write your own method to extend yason to encode objects using the generic functions encode-object and encode-slots or encode-object-slots. Taking our simple person class, we can define a new encode-slots, then within an output context, we can call encode-object and output the clos class instance.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defmethod</span> <span class="org-function-name">yason:encode-slots</span> progn ((person person))
  (yason:encode-object-slots person '(name eye-colour)))

(<span class="org-keyword">yason:with-output-to-string*</span> ()
  (yason:encode-object (make-instance 'person)))
<span class="org-string">"{\"NAME\":\"Sabra\",\"EYE-COLOUR\":\"brown\"}"</span>
</pre>
</div>
<p>
Or you can take a look at <a href="#json-mop">json-mop</a> or <a href="#herodotus">herodotus</a>. I have a preference for json-mop with the caveat that, at the moment, you cannot redefine classes.
</p>
</div>
</div>

<div id="outline-container-yason-incremental" class="outline-5">
<h5 id="yason-incremental">Incremental Encoding</h5>
<div class="outline-text-5" id="text-yason-incremental">
<p>
The following examples use two exercises. First, incrementally build a JSON array. Second, incrementally build a JSON object which also contains an incrementally built JSON array.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">yason:with-output</span> (*standard-output*)
  (<span class="org-keyword">yason:with-array</span> ()
    (<span class="org-keyword">dotimes</span> (i 3)
      (yason:encode-array-element i))))
[0,1,2]
</pre>
</div>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">yason:with-output</span> (*standard-output*)
  (<span class="org-keyword">yason:with-object</span> ()
    (yason:encode-object-element <span class="org-string">"hello"</span> <span class="org-string">"hu hu"</span>)
    (<span class="org-keyword">yason:with-object-element</span> (<span class="org-string">"harr"</span>)
      (<span class="org-keyword">yason:with-array</span> ()
        (<span class="org-keyword">dotimes</span> (i 3)
          (yason:encode-array-element i))))))
{<span class="org-string">"hello"</span>:<span class="org-string">"hu hu"</span>,<span class="org-string">"harr"</span><span class="org-builtin">:[0</span>,1,2]}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-yason-symmetry" class="outline-4">
<h4 id="yason-symmetry">Symmetry</h4>
<div class="outline-text-4" id="text-yason-symmetry">
<p>
From the standpoint of symmetry or round-tripping, going from JSON-&gt;CL-&gt;JSON, yason had no issues.
Going from CL-&gt;JSON-&gt;CL was more problematic solely because keyword symbols were written to strings and :NULL was converted to nil.
</p>
</div>
</div>
<div id="outline-container-yason-security" class="outline-4">
<h4 id="yason-security">Security</h4>
<div class="outline-text-4" id="text-yason-security">
<p>
There were two general security issues we considered: (1) interning keywords and (2) issues with malformed data. yason did not exhibit the first issue.
</p>

<p>
With respect to the second issue, yason rejected 119 out of 173 malformed test cases. Unfortunately it did trigger the stack exhaustion issue exhibited by most of the other packages.
</p>
</div>
</div>

<div id="outline-container-yason-conformity" class="outline-4">
<h4 id="yason-conformity">Conformity with JSON Standard</h4>
<div class="outline-text-4" id="text-yason-conformity">
<p>
yason accepted 95 of the 95 test cases that are considered "must accept".  If *read-default-float-format* is set to 'single-float, it would refuse to accept:  [123e65], [123e45] and [123.456e78].
</p>

<p>
It accepted 8 of the 17 test cases considered to be part of the gray area of the JSON specification - you could accept or reject.
</p>
</div>
</div>
<div id="outline-container-yason-benchmarking" class="outline-4">
<h4 id="yason-benchmarking">Benchmarking</h4>
<div class="outline-text-4" id="text-yason-benchmarking">
<p>
See <a href="#benchmarking">Benchmarking</a>
</p>
</div>
</div>

<div id="outline-container-yason-exported-symbols" class="outline-4">
<h4 id="yason-exported-symbols">yason exported symbols</h4>
<div class="outline-text-4" id="text-yason-exported-symbols">
<ul class="org-ul">
<li><b>*list-encoder*</b> - function to call to translate a cl list into JSON data. 'yason:encode-plain-list-to-array is the default; 'yason:encode-plist and 'yason:encode-alist are available to produce JSON objects. this is useful to translate a deeply recursive structure in a single yason:encode call.</li>
<li><b>*parse-json-arrays-as-vectors*</b> - if set to a true value, JSON arrays will be parsed as vectors, not as lists. nil is the default.</li>
<li><b>*parse-json-booleans-as-symbols*</b> - if set to a true value, JSON booleans will be read as the symbols true and false instead of t and nil, respectively. nil is the default.</li>
<li><b>*parse-json-null-as-keyword*</b> - if set to a true value, JSON null will be read as the keyword :null, instead of nil. nil is the default.</li>
<li><b>*parse-object-as*</b> - can be set to :hash-table to parse objects as hash tables, :alist to parse them as alists or :plist to parse them as plists. :hash-table is the default.</li>
<li><b>*parse-object-as-alist*</b></li>
<li><b>*parse-object-key-fn*</b> - function to call to convert a key string in a JSON object to a key in the cl hash produced. identity is the default.</li>
<li><b>*symbol-encoder*</b> - warning: as of the time of this writing, this variable is in version 0.8.2 on GitHub and not in version 0.7.8 in Quicklisp. function to call to translate a cl symbol into a JSON string. the default is to error out, to provide backwards-compatible behaviour. a useful function that can be bound to this variable is yason:encode-symbol-as-lowercase</li>
<li><b>*symbol-key-encoder</b>- defines the policy to encode symbols as keys (eg. in hash tables). the default is to error out, to provide backwards-compatible behaviour. a useful function that can be bound to this variable is yason:encode-symbol-as-lowercase</li>
<li><b>encode</b> - encode object in JSON format and write to stream. may be specialized by applications to perform specific rendering. stream defaults to *standard-output*.</li>
<li><b>encode-alist</b> - encodes object, an alist, in JSON format and write to stream.</li>
<li><b>encode-array-element</b> - encode object as next array element to the last JSON array opened with with-array in the dynamic context. object is encoded using the encode generic function, so it must be of a type for which an encode method is defined.</li>
<li><b>encode-array-elements</b> - encode objects, a series of JSON encodable objects, as the next array elements in a JSON array opened with with-array. encode-array-elements uses encode-array-element, which must be applicable to each object in the list (i.e. encode must be defined for each object type). additionally, this must be called within a valid stream context.</li>
<li><b>encode-object</b> - generic function to encode an object. the default implementation opens a new object encoding context and calls encode-slots on the argument.</li>
<li><b>encode-object-element</b> - encode key and value as object element to the last JSON object opened with with-object in the dynamic context. key and value are encoded using the encode generic function, so they both must be of a type for which an encode method is defined.</li>
<li><b>encode-object-elements</b> - encodes the parameters into JSON in the last object opened with with-object using encode-object-element. the parameters should consist of alternating key/value pairs, and this must be called within a valid stream context.</li>
<li><b>encode-object-slots</b> - encodes each slot in slots for object in the last object opened with with-object using encode-object-element. the key is the slot name, and the value is the slot value for the slot on object.</li>
<li><b>encode-plain-list-to-array</b></li>
<li><b>encode-plist</b> - encodes object, a plist, in JSON format and write to stream.</li>
<li><b>encode-slots</b> - generic function to encode object slots. there is no default implementation. it should be called in an object encoding context. it uses progn combinatation with most-specific-last order, so that base class slots are encoded before derived class slots.</li>
<li><b>encode-symbol-as-lowercase</b></li>
<li><b>false</b></li>
<li><b>make-json-output-stream</b> - creates a json-output-stream instance that wraps the supplied stream and optionally performs indentation of the generated JSON data. the indent argument is described in with-output. note that if the indent argument is nil, the original stream is returned in order to avoid the performance penalty of the indentation algorithm.</li>
<li><b>no-json-output-context</b> - this condition is signalled when one of the stream encoding functions is used outside the dynamic context of a with-output or with-output-to-string* body.</li>
<li><b>null</b></li>
<li><b>parse</b> - input &amp;key (object-key-fn *parse-object-as-key-fn*) (object-as *parse-object-as*) (json-arrays-as-vectors *parse-json-arrays-as-vectors*) (json-booleans-as-symbols *parse-json-booleans-as-symbols*) (json-nulls-as-keyword *parse-json-null-as-keyword*) =&gt; object parse input, which must be a string or a stream, as JSON. returns the lisp representation of the JSON structure parsed. the keyword arguments object-key-fn, object-as, json-arrays-as-vectors, json-booleans-as-symbols, and json-null-as-keyword may be used to specify different values for the parsing parameters from the current bindings of the respective special variables.</li>
<li><b>true</b></li>
<li><b>with-array</b> - open a JSON array, then run body. inside the body, encode-array-element must be called to encode elements to the opened array. must be called within an existing JSON encoder context (see with-output and with-output-to-string*)</li>
<li><b>with-object</b> - open a JSON object, then run body. inside the body, encode-object-element or with-object-element must be called to encode elements to the object. must be called within an existing JSON encoder with-output and with-output-to-string*.</li>
<li><b>with-object-element</b> -  open a new encoding context to encode a JSON object element. key is the key of the element. the value will be whatever body serializes to the current JSON output context using one of the stream encoding functions. this can be used to stream out nested object structures.</li>
<li><b>with-output</b> - macro: set up a JSON streaming encoder context on stream, then evaluate body. indent can be set to t to enable indentation with a default indentation width or to an integer specifying the desired indentation width. by default, indentation is switched off.</li>
<li><b>with-output-to-string*</b> - set up a JSON streaming encoder context on stream-symbol (by default a gensym), then evaluate body. return a string with the generated JSON output. see with-output for the description of the indent keyword argument.</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-helper-libraries" class="outline-2">
<h2 id="helper-libraries">Helper Libraries</h2>
<div class="outline-text-2" id="text-helper-libraries">
</div>
<div id="outline-container-cl-json-helper" class="outline-3">
<h3 id="cl-json-helper">cl-json-helper</h3>
<div class="outline-text-3" id="text-cl-json-helper">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Works With</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#cl-json-helper">cl-json-helper</a></td>
<td class="org-left">Bob Felts</td>
<td class="org-left">BSD</td>
<td class="org-left"><a href="https://github.com/stablecross/cl-json-helper">homepage</a></td>
<td class="org-left">cl-json</td>
<td class="org-left">Last updated 2018</td>
</tr>
</tbody>
</table>

<p>
cl-json-helper is a very small package that adds two functions to help cl-json encoding JSON data and one function to help in processing decoded JSON data. I will use its nickname :xjson in the examples. At the end of the day, I see a slight benefit here, but given that it is really just a cl-json helper and the latest generation of JSON libraries have passed cl-json by, I think this is only for cl-json devotees.
</p>
</div>

<div id="outline-container-cl-json-helper-exported-symbols" class="outline-4">
<h4 id="cl-json-helper-exported-symbols">cl-json-helper exported symbols</h4>
<div class="outline-text-4" id="text-cl-json-helper-exported-symbols">
<ul class="org-ul">
<li><b>json-bool</b> - (json-bool val) returns an object that cl-json will decode to "true" or "false"</li>
<li><b>json-empty</b> - (json-empty) returns an object that cl-json will decode to '{}'</li>
<li><b>json-key-value</b> - (json-key-value key list) returns the value associated with key</li>
<li><b>value-of</b></li>
</ul>
</div>
</div>
<div id="outline-container-json-bool" class="outline-4">
<h4 id="json-bool">Json-bool</h4>
<div class="outline-text-4" id="text-json-bool">
<p>
json-bool simply adds the ability for nil to be translated to JSON as false.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(cl-json:encode-json-to-string '(t nil))
<span class="org-string">"[true,null]"</span>

(cl-json:encode-json-to-string `(,(xjson:json-bool t) ,(xjson:json-bool nil)))
<span class="org-string">"[true,false]"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-json-empty" class="outline-4">
<h4 id="json-empty">json-empty</h4>
<div class="outline-text-4" id="text-json-empty">
<p>
json-empty provides the ability to return an empty object. E.g.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(cl-json:encode-json-to-string `((<span class="org-string">"Empty"</span> . ,(xjson:json-empty))))
<span class="org-string">"{\"Empty\":{}}"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-json-key-value" class="outline-4">
<h4 id="json-key-value">Json-key-value</h4>
<div class="outline-text-4" id="text-json-key-value">
<p>
If cl-json:decode-json-from-string *nested-address-1* looks like this:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(cl-json:decode-json-from-string *nested-address-1*)
((<span class="org-builtin">:FIRST--NAME</span> . <span class="org-string">"George"</span>) (<span class="org-builtin">:LAST--NAME</span> . <span class="org-string">"Washington"</span>)
 (<span class="org-builtin">:BIRTHDAY</span> . <span class="org-string">"1732-02-22"</span>)
 (<span class="org-builtin">:ADDRESS</span> (<span class="org-builtin">:STREET--ADDRESS</span> . <span class="org-string">"3200 Mount Vernon Memorial Highway"</span>)
  (<span class="org-builtin">:CITY</span> . <span class="org-string">"Mount Vernon"</span>) (<span class="org-builtin">:STATE</span> . <span class="org-string">"Virginia"</span>) (<span class="org-builtin">:COUNTRY</span> . <span class="org-string">"United States"</span>)))
</pre>
</div>
<p>
Then you can access the address using cl-json-helper
</p>
<div class="org-src-container">
<pre class="src src-lisp">(xjson:json-key-value <span class="org-builtin">:address</span> (cl-json:decode-json-from-string *nested-address-1*))
((<span class="org-builtin">:STREET--ADDRESS</span> . <span class="org-string">"3200 Mount Vernon Memorial Highway"</span>)
 (<span class="org-builtin">:CITY</span> . <span class="org-string">"Mount Vernon"</span>) (<span class="org-builtin">:STATE</span> . <span class="org-string">"Virginia"</span>) (<span class="org-builtin">:COUNTRY</span> . <span class="org-string">"United States"</span>))
</pre>
</div>
<p>
The only difference between using this and using (assoc ..) is that assoc will also keep the key:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(assoc <span class="org-builtin">:address</span> (cl-json:decode-json-from-string *nested-address-1*))
(<span class="org-builtin">:ADDRESS</span> (<span class="org-builtin">:STREET--ADDRESS</span> . <span class="org-string">"3200 Mount Vernon Memorial Highway"</span>)
 (<span class="org-builtin">:CITY</span> . <span class="org-string">"Mount Vernon"</span>) (<span class="org-builtin">:STATE</span> . <span class="org-string">"Virginia"</span>) (<span class="org-builtin">:COUNTRY</span> . <span class="org-string">"United States"</span>))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-define-json-expander" class="outline-3">
<h3 id="define-json-expander">define-json-expander</h3>
<div class="outline-text-3" id="text-define-json-expander">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Works With</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#define-json-expander">define-json-expander</a></td>
<td class="org-left">Johan Sjölén</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/ejbs/define-json-expander">homepage</a></td>
<td class="org-left">cl-json</td>
<td class="org-left">Last updated 2014</td>
</tr>
</tbody>
</table>

<p>
Define-json-expander is, I think, something interesting to look at, but I do not see it adding a great deal of value. Given the last time it was updated was eight years ago, I think it is of historical interest only.
</p>
</div>
<div id="outline-container-define-json-expander-exported-symbols" class="outline-4">
<h4 id="define-json-expander-exported-symbols">define-json-expander exported symbols</h4>
<div class="outline-text-4" id="text-define-json-expander-exported-symbols">
<ul class="org-ul">
<li>*accessor-prefix*</li>
<li>define-json-expander</li>
</ul>
</div>
</div>

<div id="outline-container-define-json-expander-explanation" class="outline-4">
<h4 id="define-json-expander-explanation">Explanation</h4>
<div class="outline-text-4" id="text-define-json-expander-explanation">
<p>
Let's take our simplest JSON object address example which we keep in <b>address-1</b>:
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span class="org-string">"{</span>
<span class="org-string">  \"name\": \"George Washington\",</span>
<span class="org-string">  \"birthday\": \"February 22, 1732\",</span>
<span class="org-string">  \"address\": \"Mount Vernon, Virginia, United States\"</span>
<span class="org-string">}"</span>
</pre>
</div>
<p>
We now use define-json-expander to create an address class that can be used:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">define-json-expander:define-json-expander</span> address-class ()
 ((name) (birthday) (address)))
DECODE-ADDRESS
</pre>
</div>
<p>
Now we have a decode-address function that we can apply to a cl-json decoded JSON string:
</p>
<div class="org-src-container">
<pre class="src src-lisp">  (decode-address-class  (cl-json:decode-json-from-string *address-1*))

(describe (decode-address-class  (cl-json:decode-json-from-string *address-1*)))
#&lt;ADDRESS-CLASS {100D67F9E3}&gt;
  [standard-object]

Slots with <span class="org-builtin">:INSTANCE</span> allocation:
  REST                           = NIL
  NAME                           = <span class="org-string">"George Washington"</span>
  BIRTHDAY                       = <span class="org-string">"February 22, 1732"</span>
  ADDRESS                        = <span class="org-string">"Mount Vernon, Virginia, United States"</span>
</pre>
</div>
<p>
HOWEVER, as far as I can tell, the only accessor or reader method defined is for REST, which has a nil value. Net result, even after reading the docs and the test cases in the source files, I'm confused on whether this is fully baked. Given the last update was 8 years ago, I would give this a pass.
</p>
</div>
</div>
</div>

<div id="outline-container-herodotus" class="outline-3">
<h3 id="herodotus">herodotus</h3>
<div class="outline-text-3" id="text-herodotus">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Works With</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#herodotus">herodotus</a></td>
<td class="org-left">Henry Steere</td>
<td class="org-left">BSD (1)</td>
<td class="org-left"><a href="https://github.com/HenryS1/herodotus">homepage</a></td>
<td class="org-left">yason</td>
<td class="org-left">Wrapper around yason to handle CLOS classes more easily. Last updated 16 Jun 2021</td>
</tr>
</tbody>
</table>

<p>
Yason does the JSON parsing and serialisation for herodotus. The other dependencies are cl-ppcre and alexandria. I think it may be useful if you are a yason user.
</p>
</div>

<div id="outline-container-herodotus-exported-symbols" class="outline-4">
<h4 id="herodotus-exported-symbols">herodotus exported symbols</h4>
<div class="outline-text-4" id="text-herodotus-exported-symbols">
<ul class="org-ul">
<li><b>define-json-model</b></li>
<li><b>to-json</b></li>
</ul>
</div>
</div>

<div id="outline-container-herodotus-setup" class="outline-4">
<h4 id="herodotus-setup">Setup</h4>
<div class="outline-text-4" id="text-herodotus-setup">
<p>
Let's make an anologue of our simple person class with herodotus:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">herodotus:define-json-model</span> herodotus-person (name eye-colour) <span class="org-builtin">:snake-case</span>)
</pre>
</div>
<p>
This creates a package name HERODOTUS-PERSON-JSON with a function for parsing JSON HERODOTUS-PERSON-JSON:FROM-JSON and a generic method for writing to JSON. It has accessors and initargs of name and eye-colour. The created class only has accessor and initarg specs for the slots; it does not have the ability to create default values. That last value specifies that it expects JSON keys to be using snake-case. (The default is :camel-case, the other options are :snake-case, :kebab-case or :screaming-snake-case.)
</p>

<p>
From the README:
"The define-json-model macro takes three arguments: name, slots and an optional argument for case-type. The name argument is the name of the generated CLOS class. The slots argument is a collection of slot descriptors and the case-type argument is a keyword.
</p>

<p>
Slot descriptors can be either symbols or lists. If a slot descriptor is a symbol then the value of the corresponding CLOS slot will be a deserialised JSON primitive in lisp form: a number, boolean, string, vector (for arrays), or hash-table (for objects).
</p>

<p>
If a slot descriptor is a list then first argument is the CLOS slot name, the second argument is either () or the name of a previously defined JSON model to deserialise the value of this field to. The optional third argument is a special case name for this field which can have custom formatting."
</p>
</div>
</div>
<div id="outline-container-herodotus-decoding" class="outline-4">
<h4 id="herodotus-decoding">Decoding</h4>
<div class="outline-text-4" id="text-herodotus-decoding">
<p>
At this point a simple JSON object could then be decoded into a herodotus-person instance.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(eye-colour
 (herodotus-person-json:from-json <span class="org-string">"{\"name\":\"Claudia\",\"eye_colour\":\"blue\"}"</span>))
<span class="org-string">"blue"</span>
</pre>
</div>
<p>
If the JSON object key was "eye-colour" instead of "eye_colour", the return value would have been nil because the case would have been wrong.
</p>

<p>
If you have an array of JSON objects, the from-json function would return a vector of herodotus-person objects:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(name
 (aref
  (herodotus-person-json:from-json
   <span class="org-string">"[{\"name\":\"Rebecca\",\"eye_colour\":\"blue\"},{\"name\":\"Johann\",\"eye_colour\":\"brown\"}]"</span>)
  1))
<span class="org-string">"Johann"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-herodotus-encoding" class="outline-4">
<h4 id="herodotus-encoding">Encoding</h4>
<div class="outline-text-4" id="text-herodotus-encoding">
<p>
Encoding usage looks much like yason:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(herodotus:to-json (make-instance 'herodotus-person <span class="org-builtin">:eye-colour</span> <span class="org-string">"Green"</span> <span class="org-builtin">:name</span> <span class="org-string">"Persephone"</span>))
<span class="org-string">"{\"name\":\"Persephone\",\"eye_colour\":\"Green\"}"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-herodotus-additional-info" class="outline-4">
<h4 id="herodotus-additional-info">Additional Info</h4>
<div class="outline-text-4" id="text-herodotus-additional-info">
<p>
From the README
</p>
</div>

<div id="outline-container-herodotus-additional-info-nested-classes" class="outline-5">
<h5 id="herodotus-additional-info-nested-classes">Nested classes</h5>
<div class="outline-text-5" id="text-herodotus-additional-info-nested-classes">
<p>
You can also define classes that have class members using the type specifier syntax. This block defines two JSON models tree and branch. A tree has branch members and the branch members will be parsed from JSON using the parser defined for the tree.
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (<span class="org-keyword">herodotus:define-json-model</span> branch (size))
CL-USER&gt; (<span class="org-keyword">herodotus:define-json-model</span> tree ((branches branch)))
</pre>
</div>

<p>
The syntax (branches branch) declares that the field named branches must be parsed as the type branch. JSON models for nested classes need to be defined before the models for the classes they are nested in or an error will be thrown. The error is thrown at macro expansion time.
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (<span class="org-keyword">herodotus:define-json-model</span> test-no-parser ((things not-parseable)))
CL-USER&gt; (<span class="org-keyword">herodotus:define-json-model</span> test-no-parser ((things not-parseable)))
class-name TEST-NO-PARSER slots ((THINGS NOT-PARSEABLE))
<span class="org-comment-delimiter">; </span><span class="org-comment">Evaluation aborted on #&lt;SIMPLE-ERROR "Could not find parser for</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">class NOT-PARSEABLE. Please define a json model for it."</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">{100599D903}&gt;.</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-herodotus-additional-info-none" class="outline-5">
<h5 id="herodotus-additional-info-none">None, one or many semantics</h5>
<div class="outline-text-5" id="text-herodotus-additional-info-none">
<p>
Fields in class definitions are parsed as either nil (if missing from the JSON), a single instance if the field is not an array and isn’t empty or a vector if the JSON contains an array of elements.
</p>
<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (<span class="org-keyword">herodotus:define-json-model</span> numbers (ns))
CL-USER&gt; (ns (numbers-json:from-json <span class="org-string">"{ }"</span>))
NIL
CL_USER&gt; (ns (numbers-json:from-json <span class="org-string">"{ \"ns\": 1 }"</span>))
1
CL-USER&gt; (ns (numbers-json:from-json <span class="org-string">"{ \"ns\": [1, 2, 3] }"</span>))
#(1 2 3)
</pre>
</div>
</div>
</div>

<div id="outline-container-herodotus-additional-info-field-names" class="outline-5">
<h5 id="herodotus-additional-info-field-names">Special case field names</h5>
<div class="outline-text-5" id="text-herodotus-additional-info-field-names">
<p>
Parsing specific field names can be done using the third argument of a field specifier. If a special field name is provided it doesn’t have to match the name of the slot in the CLOS class and can use any formatting convention.
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">herodotus:define-json-model</span> special-case ((unusual-format () <span class="org-string">"A_very-UniqueNAME"</span>))
(unusual-format (special-case-json:from-json <span class="org-string">"{ \"A_very-UniqueNAME\": \"Phineas Fog\" }"</span>))
<span class="org-string">"Phineas Fog"</span>
(herodotus:to-json (special-case-json:from-json <span class="org-string">"{ \"A_very-UniqueNAME\": \"Phineas Fog\" }"</span>))
<span class="org-string">"{\"A_very-UniqueNAME\":\"Phineas Fog\"}"</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-json-mop" class="outline-3">
<h3 id="json-mop">json-mop</h3>
<div class="outline-text-3" id="text-json-mop">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Works With</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#json-mop">json-mop</a></td>
<td class="org-left">Grim Schjetne</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/gschjetne/json-mop">homepage</a></td>
<td class="org-left">yason</td>
<td class="org-left">Last updated 9 Mar 2021</td>
</tr>
</tbody>
</table>

<p>
Unlike <a href="#herodotus">herodotus</a> which creates a new package, json-mop wants you to define your classes with the class option
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-builtin">:metaclass</span> json-serializable-class)
</pre>
</div>
<p>
I quite like json-mop (assuming I was using yason), but you do need to watch for one issue: At the moment you cannot redefine a class. The issue has been flagged twice on GitHub and I ran into it in testing.
</p>

<p>
For slots that you want to appear in the JSON representation of your class, add the slot option :json-key with the string to use as the attribute name. The option :json-type defaults to :any, but you can control how each slot value is transformed to and from JSON with one of the following JSON type specifiers:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">:any</td>
<td class="org-left">Guesses the way to encode and decode the value</td>
</tr>

<tr>
<td class="org-left">:string</td>
<td class="org-left">Enforces a string value</td>
</tr>

<tr>
<td class="org-left">:number</td>
<td class="org-left">Enforces a number value</td>
</tr>

<tr>
<td class="org-left">:hash-table</td>
<td class="org-left">Enforces a hash table value</td>
</tr>

<tr>
<td class="org-left">:vector</td>
<td class="org-left">Enforces a vector value</td>
</tr>

<tr>
<td class="org-left">:list</td>
<td class="org-left">Enforces a list value</td>
</tr>

<tr>
<td class="org-left">:bool</td>
<td class="org-left">Maps T and NIL with true and false</td>
</tr>

<tr>
<td class="org-left">&lt;symbol&gt;</td>
<td class="org-left">Uses a (:metaclass json-serializable-class) class definition to direct the transformation of the value</td>
</tr>
</tbody>
</table>
<p>
so taking our minimal person object and following these instructions:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defclass</span> <span class="org-type">mop-person</span> ()
  ((name
    <span class="org-builtin">:initarg</span> <span class="org-builtin">:name</span> <span class="org-builtin">:initform</span> <span class="org-string">"Sabra"</span> <span class="org-builtin">:json-key</span> <span class="org-string">"name"</span> <span class="org-builtin">:json-type</span> <span class="org-builtin">:string</span>
    <span class="org-builtin">:accessor</span> name)
   (eye-colour <span class="org-builtin">:initarg</span> <span class="org-builtin">:eye-colour</span> <span class="org-builtin">:json-key</span> <span class="org-string">"eye-colour"</span> <span class="org-builtin">:json-type</span> <span class="org-builtin">:string</span>
               <span class="org-builtin">:initform</span> <span class="org-string">"brown"</span>
               <span class="org-builtin">:accessor</span> eye-colour))
  (<span class="org-builtin">:metaclass</span> json-mop:json-serializable-class))
#&lt;JSON-MOP:JSON-SERIALIZABLE-CLASS JSON-TESTS::MOP-PERSON&gt;

(json-mop:encode (make-instance 'mop-person))
{<span class="org-string">"name"</span>:<span class="org-string">"Sabra"</span>,<span class="org-string">"eye-colour"</span>:<span class="org-string">"brown"</span>}
</pre>
</div>
<p>
We can get a CLOS instance out of an appropriate json object with (json-to-clos data class-name)
</p>
<div class="org-src-container">
<pre class="src src-lisp">(describe (json-mop:json-to-clos <span class="org-string">"{\"name\":\"Karla\",\"eye-colour\":\"green\"}"</span>
                                 'mop-person))
#&lt;MOP-PERSON {1009BE24B3}&gt;
[standard-object]

Slots with <span class="org-builtin">:INSTANCE</span> allocation:
NAME                           = <span class="org-string">"Karla"</span>
EYE-COLOUR                     = <span class="org-string">"green"</span>
</pre>
</div>

<p>
It gets interesting when you create an instance with an invalid data type. Suppose we create a mop-person with a list for a name and an integer for an eye colour. The instance gets created that way, but when we try to encode it, we get an errro:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(json-mop:encode (make-instance 'mop-person <span class="org-builtin">:name</span> '(1 2 3) <span class="org-builtin">:eye-colour</span> 12))
{

  There is no class named <span class="org-builtin">:STRING.</span>
     [Condition of type SB-PCL:CLASS-NOT-FOUND-ERROR]
</pre>
</div>
<p>
If the JSON object actually has a null value for eye-colour, that will be treated as an unbound slot. Our mop-person class has an initform of "brown" for eye-colour and our initform will overrule the JSON null:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(describe (json-mop:json-to-clos <span class="org-string">"{\"name\":\"Andre\",\"eye-colour\":null}"</span>  'mop-person))
#&lt;MOP-PERSON {1009C0C693}&gt;
  [standard-object]

Slots with <span class="org-builtin">:INSTANCE</span> allocation:
  NAME                           = <span class="org-string">"Andre"</span>
  EYE-COLOUR                     = <span class="org-string">"brown"</span>
</pre>
</div>

<p>
The README has an example of nested objects:
</p>
<div class="org-src-container">
<pre class="src src-lisp">  (<span class="org-keyword">defclass</span> <span class="org-type">book</span> ()
    ((title <span class="org-builtin">:initarg</span> <span class="org-builtin">:title</span>
            <span class="org-builtin">:json-type</span> <span class="org-builtin">:string</span>
            <span class="org-builtin">:json-key</span> <span class="org-string">"title"</span>)
     (published-year <span class="org-builtin">:initarg</span> <span class="org-builtin">:year</span>
           <span class="org-builtin">:json-type</span> <span class="org-builtin">:number</span>
           <span class="org-builtin">:json-key</span> <span class="org-string">"year_published"</span>)
     (fiction <span class="org-builtin">:initarg</span> <span class="org-builtin">:fiction</span>
              <span class="org-builtin">:json-type</span> <span class="org-builtin">:bool</span>
              <span class="org-builtin">:json-key</span> <span class="org-string">"is_fiction"</span>))
    (<span class="org-builtin">:metaclass</span> json-serializable-class))

  (<span class="org-keyword">defclass</span> <span class="org-type">author</span> ()
    ((name <span class="org-builtin">:initarg</span> <span class="org-builtin">:name</span>
           <span class="org-builtin">:json-type</span> <span class="org-builtin">:string</span>
           <span class="org-builtin">:json-key</span> <span class="org-string">"name"</span>)
     (birth-year <span class="org-builtin">:initarg</span> <span class="org-builtin">:year</span>
                 <span class="org-builtin">:json-type</span> <span class="org-builtin">:number</span>
                 <span class="org-builtin">:json-key</span> <span class="org-string">"year_birth"</span>)
     (bibliography <span class="org-builtin">:initarg</span> <span class="org-builtin">:bibliography</span>
                   <span class="org-builtin">:json-type</span> (<span class="org-builtin">:list</span> book)
                   <span class="org-builtin">:json-key</span> <span class="org-string">"bibliography"</span>))
    (<span class="org-builtin">:metaclass</span> json-serializable-class))

(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*author*</span>
  (make-instance 'author
                 <span class="org-builtin">:name</span> <span class="org-string">"Mark Twain"</span>
                 <span class="org-builtin">:year</span> 1835
                 <span class="org-builtin">:bibliography</span>
                 (list
                  (make-instance 'book
                                 <span class="org-builtin">:title</span> <span class="org-string">"The Gilded Age: A Tale of Today"</span>
                                 <span class="org-builtin">:year</span> 1873
                                 <span class="org-builtin">:fiction</span> t)
                  (make-instance 'book
                                 <span class="org-builtin">:title</span> <span class="org-string">"Life on the Mississippi"</span>
                                 <span class="org-builtin">:year</span> 1883
                                 <span class="org-builtin">:fiction</span> nil)
                  (make-instance 'book
                                 <span class="org-builtin">:title</span> <span class="org-string">"Adventures of Huckleberry Finn"</span>
                                 <span class="org-builtin">:year</span> 1884
                                 <span class="org-builtin">:fiction</span> t))))
</pre>
</div>
</div>

<div id="outline-container-json-mop-exported-symbols" class="outline-4">
<h4 id="json-mop-exported-symbols">json-mop exported symbols</h4>
<div class="outline-text-4" id="text-json-mop-exported-symbols">
<ul class="org-ul">
<li>json-mop:encode</li>
<li>json-mop:json-serializable</li>
<li>json-mop:json-serializable-class</li>
<li>json-mop:json-to-clos</li>
<li>json-mop:json-type</li>
<li>json-mop:json-type-error</li>
<li>json-mop:no-values-class</li>
<li>json-mop:no-values-hash-table</li>
<li>json-mop:no-values-parsed</li>
<li>json-mop:null-in-homogenous-sequence</li>
<li>json-mop:null-value</li>
<li>json-mop:slot-name</li>
<li>json-mop:slot-not-serializable</li>
<li>json-mop:to-json-value</li>
<li>json-mop:to-lisp-value</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-cl-json-pointer" class="outline-3">
<h3 id="cl-json-pointer">cl-json-pointer</h3>
<div class="outline-text-3" id="text-cl-json-pointer">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Works With</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#cl-json-pointer">cl-json-pointer</a></td>
<td class="org-left">Yokata Yuki</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/y2q-actionman/cl-json-pointer">homepage</a></td>
<td class="org-left">cl-json, st-json, yason, jsown, jonathan, json-streams, com.gigamonkeys.json (1)</td>
<td class="org-left"><a href="https://40ants.com/lisp-project-of-the-day/2020/08/0158-cl-json-pointer.html">40ants comments</a></td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>(1) There is an outstanding issue asking for com.inuoe.jzon support opened on May 14, 2021, but no action.</li>
</ul>

<p>
I am going to borrow 40ants review <a href="https://40ants.com/lisp-project-of-the-day/2020/08/0158-cl-json-pointer.html">here</a>:
</p>

<p>
This library implements <a href="https://datatracker.ietf.org/doc/html/rfc6901">RFC 6901</a> - a format for accessing nested JSON data-structures. It some sense, JSON pointer is similar to JSON path, but more suitable for use as a part of the URL fragment.
</p>

<p>
cl-json-pointer's README provides many examples, but all of them are applied to the object which almost flat. Let's try to reproduce an example from the JSON path's site:
</p>
<div class="org-src-container">
<pre class="src src-javascript">{
  <span class="org-string">"firstName"</span>: <span class="org-string">"John"</span>,
  <span class="org-string">"lastName"</span> : <span class="org-string">"doe"</span>,
  <span class="org-string">"age"</span>      : 26,
  <span class="org-string">"address"</span>  : {
    <span class="org-string">"streetAddress"</span>: <span class="org-string">"naist street"</span>,
    <span class="org-string">"city"</span>         : <span class="org-string">"Nara"</span>,
    <span class="org-string">"postalCode"</span>   : <span class="org-string">"630-0192"</span>
  },
  <span class="org-string">"phoneNumbers"</span>: [
    {
      <span class="org-string">"type"</span>  : <span class="org-string">"iPhone"</span>,
      <span class="org-string">"number"</span>: <span class="org-string">"0123-4567-8888"</span>
    },
    {
      <span class="org-string">"type"</span>  : <span class="org-string">"home"</span>,
      <span class="org-string">"number"</span>: <span class="org-string">"0123-4567-8910"</span>
    }
  ]
}
</pre>
</div>
<p>
Now we'll translate this JSON path: $.phoneNumbers[0].type into JSON pointer /phoneNumbers/0/type:
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">defparameter</span> <span class="org-variable-name">*obj*</span>
  (jsown:parse
   (alexandria:read-file-into-string <span class="org-string">"data.json"</span>)))

(cl-json-pointer:get-by-json-pointer *obj* <span class="org-string">"/phoneNumbers/0/type"</span>
                                     <span class="org-builtin">:flavor</span> <span class="org-builtin">:jsown</span>)
<span class="org-string">"iPhone"</span>
(<span class="org-string">"type"</span> . <span class="org-string">"iPhone"</span>)
NIL
</pre>
</div>
<p>
It is also possible to add/set/delete elements using cl-json-pointer.
</p>

<p>
You will find more examples in the official <a href="https://github.com/y2q-actionman/cl-json-pointer">docs</a>.
</p>

<p>
Comparing to the JSON path, the pointer has clearer character escaping rules and is able to work with keys containing dots and slashes and other symbols. But it does not support slicing and some other features of the JSON path.
</p>
</div>

<div id="outline-container-cl-json-pointer-exported-symbols" class="outline-4">
<h4 id="cl-json-pointer-exported-symbols">cl-json-pointer exported symbols</h4>
<div class="outline-text-4" id="text-cl-json-pointer-exported-symbols">
<ul class="org-ul">
<li><b>json-pointer-error</b> -</li>
<li><b>*json-object-flavor</b> - Default flavor of JSON library currently used.This value is used for :FLAVOR argument of exported functions.</li>
</ul>
<p>
Currently acceptable values are held by '*cl-json-pointer-supported-json-flavors*
</p>
<ul class="org-ul">
<li><b>*cl-json-pointer-supported-json-flavors*</b> -</li>
<li><b>parse-json-pointer</b> - Parses OBJ to an internal representation</li>
<li><b>get-by-json-pointer</b> - Traverses OBJ with POINTER and returns three values: the found value (`nil' if not found), a generalized boolean saying the existence of the place pointed by POINTER, and NIL.</li>
<li><b>exists-p-by-json-pointer</b> - raverses OBJ with POINTER and returns the existence of the place pointed by POINTER.</li>
<li><b>set-by-json-pointer</b> - Traverses OBJ with POINTER, sets VALUE into the pointed place, and returns the modified OBJ</li>
<li><b>add-by-json-pointer</b> - Works same as `set-by-json-pointer', except this try to make a new list when setting to lists.</li>
<li><b>delete-by-json-pointer</b> - Traverses OBJ with POINTER, deletes the pointed place, and returns the modified OBJ</li>
<li><b>remove-by-json-pointer</b> - Works same as `delete-by-json-pointer', except this try to make a new list when deleting from lists.</li>
<li><b>update-by-json-pointer</b> - Modify macro of `set-by-json-pointer'. This sets results of `set-by-json-pointer' to the referred place.</li>
<li><b>deletef-by-json-pointer</b> - Modify macro of `delete-by-json-pointer'. This sets results of `delete-by-json-pointer' to the referred place.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-cl-json-schema" class="outline-3">
<h3 id="cl-json-schema">cl-json-schema</h3>
<div class="outline-text-3" id="text-cl-json-schema">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Author</th>
<th scope="col" class="org-left">License</th>
<th scope="col" class="org-left">Website</th>
<th scope="col" class="org-left">Works With</th>
<th scope="col" class="org-left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="#cl-json-schema">cl-json-schema</a></td>
<td class="org-left">Mark Skilbeck</td>
<td class="org-left">MIT</td>
<td class="org-left"><a href="https://github.com/notmgsk/cl-json-schema">homepage</a></td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
Per <a href="https://json-schema.org/">https://json-schema.org/</a>, JSON Schema is a vocabulary that allows you to annotate and validate JSON documents. Json-schema is an attempt to go from JSON schema to clos class definition. The intended sequel, <a href="https://gitlab.com/Gnuxie/json-schema2/">https://gitlab.com/Gnuxie/json-schema2/</a>, has not been really developed. The author's description on a reddit post found <a href="https://old.reddit.com/r/Common_Lisp/comments/pbpa9o/create_clos_classes_from_jsonschema/">here</a> was "It is bad. It should only be used to learn and do things better. I don't feel comfortable providing any form of support for this hack. But if you have a directory on the filesystem with some JSON schema in it, you should be able to use the macro json-schema2:define-schema-spec and list the pathname in there. You might get lucky and find everything you need is supported when you view the macroexpansion."
</p>

<p>
The sum total of documentation for cl-json-schema is the following: The main entrypoint is (cl-json-schema:validate thing schema) where thing is a JSON-compatible value, and schema is a hash-table. (Alternatively, if you prefer, (json-schema:validate thing schema).
</p>

<p>
For example
</p>
<div class="org-src-container">
<pre class="src src-lisp">(<span class="org-keyword">let</span> ((schema (yason:parse <span class="org-string">"{</span>
<span class="org-string">  \"type\": \"object\",</span>
<span class="org-string">  \"propertyNames\": {</span>
<span class="org-string">    \"pattern\": \"^[A-Za-z_][A-Za-z0-9_]*$\"</span>
<span class="org-string">  }</span>
<span class="org-string">}</span>
<span class="org-string">"</span>)))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">NEAT!</span>
  (json-schema:validate (yason:parse <span class="org-string">"{\"_a_proper_token_001\": \"value\"}"</span>)
                        schema)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">NO BUENO! Key does not match the required pattern</span>
  (json-schema:validate (yason:parse <span class="org-string">"{\"001 invalid\": \"value\"}"</span>)
                        schema))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-appendix" class="outline-2">
<h2 id="appendix">Appendix</h2>
<div class="outline-text-2" id="text-appendix">
</div>
<div id="outline-container-json-refresher" class="outline-3">
<h3 id="json-refresher">JSON Refresher</h3>
<div class="outline-text-3" id="text-json-refresher">
<p>
JSON (JavaScript Object Notation) is a lightweight data-interchange format, codified in <a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC 8259</a>. JSON has the following data structures:
</p>

<ul class="org-ul">
<li>object:     { "key1": "value1", "key2": "value2" }</li>
<li>array:     [ "first", "second", "third" ]</li>
<li>number:    42, 3.1415926 (note that there is no separate type for integer or floating point).</li>
<li>string:    "This is a string"</li>
<li>boolean:    true,    false</li>
<li>null:    null</li>
</ul>

<p>
JSON objects can be nested, potentially creating the need for a JSON schema. Taking an example from <a href="https://json-schema.org/understanding-json-schema/about.html">https://json-schema.org/understanding-json-schema/about.html</a>, we can see two JSON objects containing information about a person:
</p>
<div class="org-src-container">
<pre class="src src-javascript">{
  <span class="org-string">"name"</span>: <span class="org-string">"George Washington"</span>,
  <span class="org-string">"birthday"</span>: <span class="org-string">"February 22, 1732"</span>,
  <span class="org-string">"address"</span>: <span class="org-string">"Mount Vernon, Virginia, United States"</span>
}

{
  <span class="org-string">"first_name"</span>: <span class="org-string">"George"</span>,
  <span class="org-string">"last_name"</span>: <span class="org-string">"Washington"</span>,
  <span class="org-string">"birthday"</span>: <span class="org-string">"1732-02-22"</span>,
  <span class="org-string">"address"</span>: {
    <span class="org-string">"street_address"</span>: <span class="org-string">"3200 Mount Vernon Memorial Highway"</span>,
    <span class="org-string">"city"</span>: <span class="org-string">"Mount Vernon"</span>,
    <span class="org-string">"state"</span>: <span class="org-string">"Virginia"</span>,
    <span class="org-string">"country"</span>: <span class="org-string">"United States"</span>
  }
}
</pre>
</div>
<p>
If you wanted to validate the JSON objects, you would need a schema which you could check against the objects. The first object would fail validation and the second object would pass validation if they were validate against the following schema:
</p>
<div class="org-src-container">
<pre class="src src-javascrip">{
  "type": "object",
  "properties": {
    "first_name": { "type": "string" },
    "last_name": { "type": "string" },
    "birthday": { "type": "string", "format": "date" },
    "address": {
      "type": "object",
      "properties": {
        "street_address": { "type": "string" },
        "city": { "type": "string" },
        "state": { "type": "string" },
        "country": { "type" : "string" }
      }
    }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-decoding-benchmark-detail" class="outline-3">
<h3 id="decoding-benchmark-detail">Decoding Trivial-Benchmark Summary</h3>
<div class="outline-text-3" id="text-decoding-benchmark-detail">
<p>
The following summary table was generated by trivial-benchmarks from the libraries parsing the countries.json file (small 1.2 MB file) downloaded from <a href="https://github.com/mledoze/countries/blob/master/countries.json">https://github.com/mledoze/countries/blob/master/countries.json</a>, over a cumulated 100 runs using SBCL version 2.3.2.
</p>
<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 59:</span> Parsing a 1.2 MB JSON File, 100 iterations</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-right">User Run Time (Sec)</th>
<th scope="col" class="org-right">Bytes Consed</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">parse</td>
<td class="org-right">1.657614</td>
<td class="org-right">418080864</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">decode-json-from-string</td>
<td class="org-right">4.077347</td>
<td class="org-right">2893155200</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeys.json</td>
<td class="org-left">parse-json</td>
<td class="org-right">2.768985</td>
<td class="org-right">1336311024</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">parse</td>
<td class="org-right">1.330737</td>
<td class="org-right">782284512</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">decode-json-from-string</td>
<td class="org-right">194.9456</td>
<td class="org-right">1568784712704</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">parse</td>
<td class="org-right">5.738711</td>
<td class="org-right">3438749120</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-parse :duplicate-key-check nil</td>
<td class="org-right">10.231434</td>
<td class="org-right">1850713696</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">parse</td>
<td class="org-right">1.123939</td>
<td class="org-right">564034448</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">read-json</td>
<td class="org-right">1.993802</td>
<td class="org-right">1586599792</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">read-json</td>
<td class="org-right">2.662635</td>
<td class="org-right">429030832</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">parse</td>
<td class="org-right">5.155174</td>
<td class="org-right">1127308544</td>
</tr>
</tbody>
</table>


<table border="2" rules="all" frame="border">
<caption class="t-above"><span class="table-number">Table 60:</span> Parsing a 9.8 MB JSON File, 100 iterations</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Library</th>
<th scope="col" class="org-left">Function</th>
<th scope="col" class="org-right">User Run Time (Sec)</th>
<th scope="col" class="org-right">Bytes Consed</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">boost-json</td>
<td class="org-left">parse</td>
<td class="org-right">15.844047</td>
<td class="org-right">8121764192</td>
</tr>

<tr>
<td class="org-left">cl-json</td>
<td class="org-left">decode-json-from-string</td>
<td class="org-right">40.892357</td>
<td class="org-right">28502164224</td>
</tr>

<tr>
<td class="org-left">com.gigamonkeysjson</td>
<td class="org-left">parse-json</td>
<td class="org-right">30.002583</td>
<td class="org-right">16455712480</td>
</tr>

<tr>
<td class="org-left">com.inuoe.jzon</td>
<td class="org-left">parse</td>
<td class="org-right">7.821162</td>
<td class="org-right">4366975664</td>
</tr>

<tr>
<td class="org-left">jonathan</td>
<td class="org-left">parse</td>
<td class="org-right">1325.759500</td>
<td class="org-right">8950139810080</td>
</tr>

<tr>
<td class="org-left">json-lib</td>
<td class="org-left">parse</td>
<td class="org-right">58.481285</td>
<td class="org-right">36938784784</td>
</tr>

<tr>
<td class="org-left">json-streams</td>
<td class="org-left">json-parse :duplicate-key-check nil</td>
<td class="org-right">80.72323</td>
<td class="org-right">24938589616</td>
</tr>

<tr>
<td class="org-left">jsown</td>
<td class="org-left">parse</td>
<td class="org-right">4.989549</td>
<td class="org-right">4919389104</td>
</tr>

<tr>
<td class="org-left">shasht</td>
<td class="org-left">read-json</td>
<td class="org-right">17.84457</td>
<td class="org-right">16028649184</td>
</tr>

<tr>
<td class="org-left">st-json</td>
<td class="org-left">read-json</td>
<td class="org-right">17.739523</td>
<td class="org-right">7805457392</td>
</tr>

<tr>
<td class="org-left">yason</td>
<td class="org-left">parse</td>
<td class="org-right">67.30084</td>
<td class="org-right">13795069104</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-decoding-benchmark-detail-by-library" class="outline-3">
<h3 id="decoding-benchmark-detail-by-library">Decoding Trivial-Benchmark Detail By Library</h3>
<div class="outline-text-3" id="text-decoding-benchmark-detail-by-library">
</div>
<div id="outline-container-decoding-benchmark-detail-by-library12" class="outline-4">
<h4 id="decoding-benchmark-detail-by-library12">1.2 MB JSON File</h4>
<div class="outline-text-4" id="text-decoding-benchmark-detail-by-library12">
</div>
<div id="outline-container-orgecae93f" class="outline-5">
<h5 id="orgecae93f">Boost-json</h5>
<div class="outline-text-5" id="text-orgecae93f">
<div class="org-src-container">
<pre class="src src-ascii">-               SAMPLES  TOTAL      MINIMUM   MAXIMUM   MEDIAN    AVERAGE    DEVIATION
REAL-TIME        100      1.619998   0.013333  0.033334  0.016667  0.0162     0.002539
RUN-TIME         100      1.619314   0.015628  0.033694  0.015754  0.016193   0.002224
USER-RUN-TIME    100      1.619338   0.015629  0.033679  0.015754  0.016193   0.002223
SYSTEM-RUN-TIME  100      0.000049   0         0.000013  0         0.0        0.000002
PAGE-FAULTS      100      0          0         0         0         0          0.0
GC-RUN-TIME      100      11.174     0         6.546     0         0.11174    0.793851
BYTES-CONSED     100      418099808  4117712   4216192   4182816   4180998.0  22944.854
EVAL-CALLS       100      0          0         0         0         0          0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-orga45d4ec" class="outline-5">
<h5 id="orga45d4ec">Cl-json</h5>
<div class="outline-text-5" id="text-orga45d4ec">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL       MINIMUM   MAXIMUM   MEDIAN    AVERAGE     DEVIATION
REAL-TIME        100      4.063327    0.036666  0.05      0.04      0.040633    0.003007
RUN-TIME         100      4.063163    0.039048  0.049219  0.039521  0.040632    0.002733
USER-RUN-TIME    100      4.046636    0.039002  0.0482    0.039525  0.040466    0.002406
SYSTEM-RUN-TIME  100      0.016857    0         0.003338  0         0.000169    0.000722
PAGE-FAULTS      100      0           0         0         0         0           0.0
GC-RUN-TIME      100      107.753     0         8.268     0         1.07753     2.532335
BYTES-CONSED     100      2893124064  28892784  28960032  28927472  28931240.0  16630.285
EVAL-CALLS       100      0           0         0         0         0           0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-org153c86e" class="outline-5">
<h5 id="org153c86e">Com.gigamonkeys.json</h5>
<div class="outline-text-5" id="text-org153c86e">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL       MINIMUM   MAXIMUM   MEDIAN    AVERAGE     DEVIATION
REAL-TIME        100      2.81333     0.026665  0.06      0.026667  0.028133    0.004277
RUN-TIME         100      2.810417    0.026351  0.060089  0.026769  0.028104    0.004258
USER-RUN-TIME    100      2.727645    0.019766  0.046832  0.026694  0.027276    0.003144
SYSTEM-RUN-TIME  100      0.083058    0         0.013258  0         0.000831    0.002216
PAGE-FAULTS      100      0           0         0         0         0           0.0
GC-RUN-TIME      100      102.407     0         32.956    0         1.02407     4.182565
BYTES-CONSED     100      1336330880  13308192  13407152  13374576  13363309.0  18525.904
EVAL-CALLS       100      0           0         0         0         0           0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-orga339043" class="outline-5">
<h5 id="orga339043">Com.inuoe.jzon</h5>
<div class="outline-text-5" id="text-orga339043">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL      MINIMUM   MAXIMUM   MEDIAN    AVERAGE    DEVIATION
REAL-TIME        100      1.326664   0.009999  0.023334  0.013333  0.013267   0.00221
RUN-TIME         100      1.331578   0.012838  0.024069  0.012932  0.013316   0.001832
USER-RUN-TIME    100      1.331617   0.012839  0.024071  0.012933  0.013316   0.001832
SYSTEM-RUN-TIME  100      0.000039   0         0.000012  0         0.0        0.000002
PAGE-FAULTS      100      0          0         0         0         0          0.0
GC-RUN-TIME      100      35.118     0         10.7      0         0.35118    1.748899
BYTES-CONSED     100      782314080  7777888   7846992   7814368   7823141.0  20710.158
EVAL-CALLS       100      0          0         0         0         0          0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-org9a86640" class="outline-5">
<h5 id="org9a86640">Jonathan</h5>
<div class="outline-text-5" id="text-org9a86640">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL          MINIMUM      MAXIMUM      MEDIAN       AVERAGE        DEVIATION
REAL-TIME        100      227.00395      2.186708     2.359995     2.260044     2.27004        0.039442
RUN-TIME         100      227.33931      2.19705      2.351574     2.263612     2.273393       0.034106
USER-RUN-TIME    100      194.9456       1.876474     2.028554     1.948056     1.949456       0.034681
SYSTEM-RUN-TIME  100      32.394077      0.238007     0.417066     0.32814      0.323941       0.038221
PAGE-FAULTS      100      0              0            0            0            0              0.0
GC-RUN-TIME      100      25044.62       227.701      292.919      246.914      250.4462       12.838325
BYTES-CONSED     100      1568784712704  15687690976  15688001344  15687838672  15687847000.0  92185.85
EVAL-CALLS       100      0              0            0            0            0              0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-org7c8ba7e" class="outline-5">
<h5 id="org7c8ba7e">Json-lib</h5>
<div class="outline-text-5" id="text-org7c8ba7e">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL       MINIMUM   MAXIMUM   MEDIAN    AVERAGE     DEVIATION
REAL-TIME        100      5.79335     0.053333  0.08      0.056667  0.057934    0.004157
RUN-TIME         100      5.785923    0.055158  0.078339  0.056172  0.057859    0.003757
USER-RUN-TIME    100      5.696394    0.050573  0.068746  0.056031  0.056964    0.002951
SYSTEM-RUN-TIME  100      0.089889    0         0.016569  0         0.000899    0.002956
PAGE-FAULTS      100      0           0         0         0         0           0.0
GC-RUN-TIME      100      131.514     0         18.926    0         1.31514     3.159485
BYTES-CONSED     100      3438649392  34298176  34431824  34395536  34386492.0  30572.027
EVAL-CALLS       100      0           0         0         0         0           0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-orgacde426" class="outline-5">
<h5 id="orgacde426">Json-streams</h5>
<div class="outline-text-5" id="text-orgacde426">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL       MINIMUM   MAXIMUM   MEDIAN    AVERAGE   DEVIATION
REAL-TIME        100      9.97336     0.093333  0.12      0.1       0.099734  0.00358
RUN-TIME         100      9.966192    0.094767  0.120993  0.099149  0.099662  0.003443
USER-RUN-TIME    100      9.893029    0.091745  0.111065  0.099069  0.09893   0.00257
SYSTEM-RUN-TIME  100      0.073451    0         0.010093  0         0.000735  0.002128
PAGE-FAULTS      100      0           0         0         0         0         0.0
GC-RUN-TIME      100      65.955      0         21.973    0         0.65955   2.640409
BYTES-CONSED     100      1850613600  18431904  18564096  18497264  18506136  22893.922
EVAL-CALLS       100      0           0         0         0         0         0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-orgc17aff3" class="outline-5">
<h5 id="orgc17aff3">Jsown</h5>
<div class="outline-text-5" id="text-orgc17aff3">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL      MINIMUM   MAXIMUM   MEDIAN    AVERAGE    DEVIATION
REAL-TIME        100      1.203332   0.009999  0.043333  0.01      0.012033   0.004025
RUN-TIME         100      1.200135   0.011014  0.04474   0.011151  0.012001   0.003781
USER-RUN-TIME    100      1.123939   0.005928  0.028398  0.011122  0.011239   0.002225
SYSTEM-RUN-TIME  100      0.076273   0         0.016343  0         0.000763   0.002229
PAGE-FAULTS      100      0          0         0         0         0          0.0
GC-RUN-TIME      100      52.572     0         32.378    0         0.52572    3.640431
BYTES-CONSED     100      564034448  5604656   5658336   5625824   5640344.5  16818.484
EVAL-CALLS       100      0          0         0         0         0          0.0
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb0675a3" class="outline-5">
<h5 id="orgb0675a3">Shasht</h5>
<div class="outline-text-5" id="text-orgb0675a3">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL       MINIMUM   MAXIMUM   MEDIAN    AVERAGE     DEVIATION
REAL-TIME        100      2.060005    0.016666  0.046666  0.02      0.0206      0.004253
RUN-TIME         100      2.05557     0.018955  0.048301  0.01916   0.020556    0.004146
USER-RUN-TIME    100      1.972519    0.008969  0.031692  0.019143  0.019725    0.00262
SYSTEM-RUN-TIME  100      0.083304    0         0.016611  0         0.000833    0.002577
PAGE-FAULTS      100      0           0         0         0         0           0.0
GC-RUN-TIME      100      105.303     0         28.432    0         1.05303     3.938279
BYTES-CONSED     100      1586639328  15796880  15930032  15864640  15866393.0  28376.613
EVAL-CALLS       100      0           0         0         0         0           0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-orgf211ed0" class="outline-5">
<h5 id="orgf211ed0">St-json</h5>
<div class="outline-text-5" id="text-orgf211ed0">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL      MINIMUM   MAXIMUM   MEDIAN    AVERAGE    DEVIATION
REAL-TIME        100      2.720009   0.023333  0.05      0.026667  0.0272     0.002737
RUN-TIME         100      2.718913   0.026276  0.048607  0.026637  0.027189   0.00243
USER-RUN-TIME    100      2.672309   0.023864  0.035445  0.026506  0.026723   0.001448
SYSTEM-RUN-TIME  100      0.046662   0         0.013164  0         0.000467   0.001615
PAGE-FAULTS      100      0          0         0         0         0          0.0
GC-RUN-TIME      100      33.976     0         21.379    0         0.33976    2.333153
BYTES-CONSED     100      428995424  4250288   4316112   4283488   4289954.0  23263.066
EVAL-CALLS       100      0          0         0         0         0          0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd26c82" class="outline-5">
<h5 id="orgbd26c82">Yason</h5>
<div class="outline-text-5" id="text-orgbd26c82">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL       MINIMUM   MAXIMUM   MEDIAN    AVERAGE     DEVIATION
REAL-TIME        100      5.169989    0.049999  0.08      0.05      0.0517      0.003844
RUN-TIME         100      5.165566    0.050289  0.079555  0.050581  0.051656    0.00362
USER-RUN-TIME    100      5.155174    0.05029   0.076295  0.050571  0.051552    0.003197
SYSTEM-RUN-TIME  100      0.010577    0         0.003258  0         0.000106    0.000532
PAGE-FAULTS      100      0           0         0         0         0           0.0
GC-RUN-TIME      100      50.982      0         10.973    0         0.50982     1.959192
BYTES-CONSED     100      1127308544  11219936  11286160  11284112  11273085.0  16248.54
EVAL-CALLS       100      0           0         0         0         0           0.0
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-decoding-benchmark-detail-by-library98" class="outline-4">
<h4 id="decoding-benchmark-detail-by-library98">9.8 MB File</h4>
<div class="outline-text-4" id="text-decoding-benchmark-detail-by-library98">
</div>

<div id="outline-container-orgc71daa3" class="outline-5">
<h5 id="orgc71daa3">Boost-json</h5>
<div class="outline-text-5" id="text-orgc71daa3">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL       MINIMUM   MAXIMUM   MEDIAN    AVERAGE     DEVIATION
REAL-TIME        100      16.600002   0.143332  0.263332  0.159999  0.166       0.022166
RUN-TIME         100      16.591812   0.144675  0.262875  0.158953  0.165918    0.022023
USER-RUN-TIME    100      15.826161   0.132868  0.22961   0.150189  0.158262    0.015996
SYSTEM-RUN-TIME  100      0.766012    0         0.036679  0.000082  0.00766     0.01054
PAGE-FAULTS      100      0           0         0         0         0           0.0
GC-RUN-TIME      100      1628.348    0         116.271   0         16.28348    21.486185
BYTES-CONSED     100      8121726592  81135040  81310064  81211104  81217260.0  28616.291
EVAL-CALLS       100      0           0         0         0         0           0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-org9fbf92f" class="outline-5">
<h5 id="org9fbf92f">Cl-json</h5>
<div class="outline-text-5" id="text-org9fbf92f">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL        MINIMUM    MAXIMUM    MEDIAN     AVERAGE      DEVIATION
REAL-TIME        100      43.343338    0.39       0.500001   0.43       0.433433     0.028302
RUN-TIME         100      43.318657    0.389881   0.500517   0.430587   0.433187     0.028388
USER-RUN-TIME    100      40.892357    0.374546   0.457877   0.406374   0.408924     0.017006
SYSTEM-RUN-TIME  100      2.426699     0          0.083306   0.013432   0.024267     0.023222
PAGE-FAULTS      100      0            0          0          0          0            0.0
GC-RUN-TIME      100      5206.639     23.906     110.039    55.065     52.06639     20.941925
BYTES-CONSED     100      28502164224  284987600  285054944  285020384  285021630.0  18817.63
EVAL-CALLS       100      0            0          0          0          0            0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-org245b59b" class="outline-5">
<h5 id="org245b59b">Com.gigamonkeys.json</h5>
<div class="outline-text-5" id="text-org245b59b">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL        MINIMUM    MAXIMUM    MEDIAN     AVERAGE      DEVIATION
REAL-TIME        100      31.760002    0.256665   0.430001   0.316666   0.3176       0.03324
RUN-TIME         100      31.735737    0.254121   0.429785   0.31501    0.317357     0.033264
USER-RUN-TIME    100      30.002583    0.248119   0.396469   0.304214   0.300026     0.027704
SYSTEM-RUN-TIME  100      1.733597     0          0.063267   0.016155   0.017336     0.016309
PAGE-FAULTS      100      0            0          0          0          0            0.0
GC-RUN-TIME      100      6202.89      0          177.155    65.725     62.0289      36.170036
BYTES-CONSED     100      16455712480  164509344  164590064  164557408  164557120.0  16735.898
EVAL-CALLS       100      0            0          0          0          0            0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-orgfd1901f" class="outline-5">
<h5 id="orgfd1901f">Com.inuoe.jzon</h5>
<div class="outline-text-5" id="text-orgfd1901f">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL       MINIMUM   MAXIMUM   MEDIAN    AVERAGE     DEVIATION
REAL-TIME        100      7.853333    0.076665  0.083334  0.076667  0.078533    0.002227
RUN-TIME         100      7.850083    0.077052  0.083984  0.077664  0.078501    0.001689
USER-RUN-TIME    100      7.821162    0.064623  0.083986  0.077638  0.078212    0.002059
SYSTEM-RUN-TIME  100      0.029249    0         0.015565  0         0.000292    0.001729
PAGE-FAULTS      100      0           0         0         0         0           0.0
GC-RUN-TIME      100      64.397      0         4.54      0         0.64397     1.149026
BYTES-CONSED     100      4366975664  43620656  43707264  43666272  43669756.0  20102.645
EVAL-CALLS       100      0           0         0         0         0           0.0

</pre>
</div>
</div>
</div>

<div id="outline-container-decoding-benchmark-detail-by-library98-jonathan" class="outline-5">
<h5 id="decoding-benchmark-detail-by-library98-jonathan">Jonathan</h5>
<div class="outline-text-5" id="text-decoding-benchmark-detail-by-library98-jonathan">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL          MINIMUM      MAXIMUM      MEDIAN       AVERAGE        DEVIATION
REAL-TIME        100      1876.5785      18.566694    19.183428    18.723421    18.765785      0.153013
RUN-TIME         100      1878.7534      18.609053    19.140911    18.75922     18.787535      0.12626
USER-RUN-TIME    100      1325.7595      13.067881    13.549653    13.239522    13.257596      0.103736
SYSTEM-RUN-TIME  100      552.99426      5.264558     5.807163     5.529135     5.529942       0.099494
PAGE-FAULTS      100      0              0            0            0            0              0.0
GC-RUN-TIME      100      201864.69      1951.218     2153.499     2010.102     2018.6469      39.038464
BYTES-CONSED     100      8950139810080  89501170640  89501514624  89501406768  89501400000.0  46350.645
EVAL-CALLS       100      0              0            0            0            0              0.0
</pre>
</div>
</div>
</div>

<div id="outline-container-decoding-benchmark-detail-by-library98-json-lib" class="outline-5">
<h5 id="decoding-benchmark-detail-by-library98-json-lib">Json-lib</h5>
<div class="outline-text-5" id="text-decoding-benchmark-detail-by-library98-json-lib">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL        MINIMUM    MAXIMUM    MEDIAN     AVERAGE      DEVIATION
REAL-TIME        100      62.49986     0.583331   0.703331   0.616665   0.624999     0.03394
RUN-TIME         100      62.402306    0.582471   0.703751   0.616243   0.624023     0.034107
USER-RUN-TIME    100      58.481285    0.546558   0.641697   0.58024    0.584813     0.016765
SYSTEM-RUN-TIME  100      3.921454     0.00285    0.113307   0.029706   0.039215     0.028473
PAGE-FAULTS      100      0            0          0          0          0            0.0
GC-RUN-TIME      100      8449.81      63.201     148.833    69.068     84.4981      23.446356
BYTES-CONSED     100      36938784784  369336704  369447696  369389248  369387840.0  22078.822
EVAL-CALLS       100      0            0          0          0          0            0.0
</pre>
</div>
</div>
</div>
<div id="outline-container-decoding-benchmark-detail-by-library98-json-streams" class="outline-5">
<h5 id="decoding-benchmark-detail-by-library98-json-streams">Json-streams</h5>
<div class="outline-text-5" id="text-decoding-benchmark-detail-by-library98-json-streams">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL        MINIMUM    MAXIMUM    MEDIAN     AVERAGE      DEVIATION
REAL-TIME        100      83.553085    0.773331   0.91333    0.833331   0.835531     0.03647
RUN-TIME         100      83.30883     0.770919   0.913009   0.832009   0.833088     0.036665
USER-RUN-TIME    100      80.72323     0.756486   0.8762     0.803182   0.807232     0.020206
SYSTEM-RUN-TIME  100      2.586007     0          0.092613   0.016669   0.02586      0.024769
PAGE-FAULTS      100      0            0          0          0          0            0.0
GC-RUN-TIME      100      6292.337     21.019     155.018    54.529     62.92337     29.172997
BYTES-CONSED     100      24938589616  249331392  249428080  249386576  249385890.0  18607.875
EVAL-CALLS       100      0            0          0          0          0            0.0
</pre>
</div>
</div>
</div>
<div id="outline-container-decoding-benchmark-detail-by-library98-jsown" class="outline-5">
<h5 id="decoding-benchmark-detail-by-library98-jsown">Jsown</h5>
<div class="outline-text-5" id="text-decoding-benchmark-detail-by-library98-jsown">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL       MINIMUM   MAXIMUM   MEDIAN    AVERAGE     DEVIATION
REAL-TIME        100      5.59332     0.043332  0.126666  0.046667  0.055933    0.01773
RUN-TIME         100      5.569105    0.044441  0.126507  0.045026  0.055691    0.017726
USER-RUN-TIME    100      4.989549    0.031232  0.100324  0.044751  0.049895    0.011466
SYSTEM-RUN-TIME  100      0.579924    0         0.03667   0.000061  0.005799    0.009229
PAGE-FAULTS      100      0           0         0         0         0           0.0
GC-RUN-TIME      100      855.405     0         78.454    0         8.55405     16.65085
BYTES-CONSED     100      4919389104  49168080  49204912  49204848  49193892.0  14703.879
EVAL-CALLS       100      0           0         0         0         0           0.0
</pre>
</div>
</div>
</div>
<div id="outline-container-decoding-benchmark-detail-by-library98-shasht" class="outline-5">
<h5 id="decoding-benchmark-detail-by-library98-shasht">Shasht</h5>
<div class="outline-text-5" id="text-decoding-benchmark-detail-by-library98-shasht">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL        MINIMUM    MAXIMUM    MEDIAN     AVERAGE      DEVIATION
REAL-TIME        100      17.919956    0.173333   0.19       0.179999   0.1792       0.002911
RUN-TIME         100      17.912256    0.173717   0.191011   0.178996   0.179123     0.002458
USER-RUN-TIME    100      17.84457     0.169846   0.18917    0.178604   0.178446     0.002719
SYSTEM-RUN-TIME  100      0.068081     0          0.00844    0.000001   0.000681     0.001528
PAGE-FAULTS      100      0            0          0          0          0            0.0
GC-RUN-TIME      100      365.91       0          10.242     3.984      3.6591       1.36922
BYTES-CONSED     100      16028649184  160244432  160334912  160286432  160286500.0  21336.906
EVAL-CALLS       100      0            0          0          0          0            0.0
</pre>
</div>
</div>
</div>
<div id="outline-container-decoding-benchmark-detail-by-library98-st-json" class="outline-5">
<h5 id="decoding-benchmark-detail-by-library98-st-json">St-json</h5>
<div class="outline-text-5" id="text-decoding-benchmark-detail-by-library98-st-json">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL       MINIMUM   MAXIMUM   MEDIAN    AVERAGE     DEVIATION
REAL-TIME        100      18.69662    0.163331  0.279999  0.176667  0.186966    0.027689
RUN-TIME         100      18.646624   0.162164  0.277236  0.177811  0.186466    0.027531
USER-RUN-TIME    100      17.739523   0.146125  0.251218  0.167254  0.177395    0.018997
SYSTEM-RUN-TIME  100      0.907483    0         0.073193  0.000403  0.009075    0.013883
PAGE-FAULTS      100      0           0         0         0         0           0.0
GC-RUN-TIME      100      1844.771    0         106.111   0         18.44771    25.936756
BYTES-CONSED     100      7805457392  78012704  78078784  78046272  78054580.0  19326.176
EVAL-CALLS       100      0           0         0         0         0           0.0
</pre>
</div>
</div>
</div>
<div id="outline-container-decoding-benchmark-detail-by-library98-yason" class="outline-5">
<h5 id="decoding-benchmark-detail-by-library98-yason">Yason</h5>
<div class="outline-text-5" id="text-decoding-benchmark-detail-by-library98-yason">
<div class="org-src-container">
<pre class="src src-ascii">-                SAMPLES  TOTAL        MINIMUM    MAXIMUM    MEDIAN     AVERAGE      DEVIATION
REAL-TIME        100      69.51981     0.619999   0.796665   0.713333   0.695198     0.048038
RUN-TIME         100      69.38795     0.62071    0.794521   0.710142   0.693879     0.047837
USER-RUN-TIME    100      67.30084     0.620458   0.756178   0.674462   0.673008     0.033042
SYSTEM-RUN-TIME  100      2.087528     0          0.069886   0.01291    0.020875     0.022515
PAGE-FAULTS      100      0            0          0          0          0            0.0
GC-RUN-TIME      100      6011.343     0          156.623    77.148     60.11343     44.679024
BYTES-CONSED     100      13795069104  137923120  137990768  137958112  137950690.0  15643.376
EVAL-CALLS       100      0            0          0          0          0            0.0
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
